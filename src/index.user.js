// ==UserScript==
// @name		  eRepublik Stuff++ Unlocked
// @description An unlocked version of stuff++ (https://docs.google.com/spreadsheets/d/1nal62cgC7lUmrur6NRzlPVU3uxtE59WGV9-bZcPoIw8/edit#gid=0), that for some reason didn't want to run after Zordacz ban.
// @author		Zordacz, Humberd
// @version		5.72
// @match		  https://www.erepublik.com/*
// @updateUrl https://raw.githubusercontent.com/Humberd/Stuff-unlocked/master/src/index.user.js
// @run-at		document-start
// @grant		  none
// ==/UserScript==
if (document.head) {
  execute();
} else {
  // work-around for https://github.com/greasemonkey/greasemonkey/issues/2996
  var obs = new MutationObserver(function () {
    if (document.head) { obs.disconnect(); execute(); }
  });
  obs.observe(document, {childList: true, subtree: true});
}
function execute() {
  function getMapObjectFromIframe() {
      const iframe = document.createElement("iframe");
      iframe.style.display = "none";
      document.head.appendChild(iframe);

      const script = document.createElement("script");
      script.textContent = `
        window.getOriginalMap = function() {
          return Map;
        };
      `;
      iframe.contentDocument.body.appendChild(script);

      return iframe.contentWindow.getOriginalMap();
    }
    window.originalMap = getMapObjectFromIframe();
  // We make sure that the Map object is the original one
  ((Map) => {
     /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 403:
/***/ (() => {

// ********** OLD INDEX START **********
/* eslint-disable */// const CONTRIBUTORS_URL =
//   "https://raw.githubusercontent.com/Humberd/Stuff-unlocked/dev/src/contributors.json";
const CONTRIBUTORS_URL="https://raw.githubusercontent.com/Humberd/Stuff-unlocked/master/src/contributors.json";!function(){/** @type {!Array} */var afterRequestCallbacks=[];/** @type {function(this:XMLHttpRequest, (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string)=): undefined} */var oldSend=XMLHttpRequest.prototype.send;/**
   * @param {(ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string)=} p0
   * @return {undefined}
   */XMLHttpRequest.prototype.send=function(){this.addEventListener("load",function(){/** @type {*} */var text="{"==this.responseText.trim()[0]?JSON.parse(this.responseText):this.responseText;setTimeout(()=>{for(let requestCallback of afterRequestCallbacks){requestCallback(text,this.responseURL);}},200);});oldSend.apply(this,arguments);};// Evaluate the script after the page has loaded.
console.log(document.readyState);if(document.readyState==='loading'){window.addEventListener("DOMContentLoaded",onContentLoaded);}else{onContentLoaded();}function onContentLoaded(){/**
     * @param {!Object} args
     * @param {!Function} query
     * @return {undefined}
     */function $(args,query){for(let i in args){if(args.hasOwnProperty(i)&&false===query(i,args[i])){break;}}}/**
     * @param {string} value
     * @param {!Function} cont
     * @return {?}
     */function expect(value,cont){/** @type {!NodeList<Element>} */var n=document.querySelectorAll(value);return cont&&n.forEach((expr,className)=>{return cont(expr,className);}),n;}/**
     * @param {string} variableNames
     * @return {undefined}
     */function append(variableNames){document.head.insertAdjacentHTML("beforeEnd","<style>"+variableNames+"</style>");}/**
     * @param {!Object} name
     * @return {?}
     */function resolve(name){return name.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");}/**
     * @param {number} value
     * @param {number} precision
     * @return {?}
     */function format(value,precision){return value>999999999?(value/1e9).toFixed(precision+1)+"B":value>999999?(value/1e6).toFixed(precision)+"M":resolve(+value.toFixed(precision));}/**
     * @param {string} url
     * @param {!Function} callback
     * @return {undefined}
     */function test(url,callback){fetch(url,{credentials:"same-origin"}).then(e=>{return e.text();}).then(value=>{return callback&&callback("{"==value.trim()[0]?JSON.parse(value):value);});}/**
     * @param {string} v
     * @param {!Object} _
     * @param {!Function} done
     * @return {undefined}
     */function callback(v,_,done){/** @type {string} */var reverse_search_string="";$(_,(qov,fileFullpath)=>{return reverse_search_string=reverse_search_string+("&"+encodeURIComponent(qov)+"="+encodeURIComponent(fileFullpath));});fetch(v,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},credentials:"same-origin",body:reverse_search_string.substring(1)}).then(e=>{return e.text();}).then(result=>{return done&&done("{"==result.trim()[0]?JSON.parse(result):result);});}/**
     * @param {!Object} elem
     * @param {string} value
     * @param {!Function} resolve
     * @return {undefined}
     */function update(elem,value,resolve){/**
       * @return {undefined}
       */function init(){/** @type {string} */element.style="";var event=elem.getBoundingClientRect();var type=elem.gravity||"ns";type="ns"==type?event.top-element.offsetHeight-5<0?"s":"n":type;element.style["w"==type?"right":"left"]=("ns".includes(type)?event.left+event.width/2-element.offsetWidth/2:"w"==type?innerWidth-event.left-5:event.right+5).toFixed()+"px";element.style["n"==type?"bottom":"top"]=("ew".includes(type)?event.top+event.height/2-element.offsetHeight/2:"n"==type?innerHeight-event.top+5:event.bottom+5).toFixed()+"px";if(elem.matches(":hover")){/** @type {string} */element.style.visibility="visible";}}/** @type {string} */elem.gravity=value;elem.addEventListener("mouseenter",function(canCreateDiscussions){var value=elem.title||elem.orgtitle;/** @type {string} */element.innerHTML="";element.innerHTML=resolve?resolve(init):value;elem.orgtitle=value;/** @type {string} */elem.title="";init();});elem.addEventListener("mouseleave",()=>{return element.style="";});}/**
     * @return {undefined}
     */function load(){test(CONTRIBUTORS_URL,function(askForResult){Object.assign(data,askForResult);checkCurrentVersion();saveStuffDataToStorage();});}/**
     * @return {undefined}
     */function saveStuffDataToStorage(){/** @type {string} */localStorage.stuff=JSON.stringify(data);}/**
     * @return {undefined}
     */function resetTodayStats(){/** @type {!Array} */result=[0,0,0,0];/** @type {string} */localStorage.statsToday=JSON.stringify(result);expect("#NoKills",inventoryService=>{return inventoryService.remove();});}/**
     * @param {number} i
     * @param {!Function} callback
     * @return {undefined}
     */function u(i,callback){if(redLookupTable[i]){setTimeout(callback);}else{test("/"+side+"/economy/marketpicture/"+i,function(n){redLookupTable[i]=n;callback();});}}/**
     * @param {number} usetwemoji
     * @return {?}
     */function restart(usetwemoji){return 1==usetwemoji?"food":2==usetwemoji?"weapons":3==usetwemoji?"tickets":4==usetwemoji?"houses":7==usetwemoji?"frm":12==usetwemoji?"wrm":17==usetwemoji?"hrm":23==usetwemoji?"aircraft":"arm";}/**
     * @param {string} url
     * @param {!Function} callback
     * @return {undefined}
     */function done(url,callback){afterRequestCallbacks.push(function(canCreateDiscussions,url){if(url.includes(url)){setTimeout(callback);}});}/**
     * @param {string} key
     * @return {?}
     */function require(key){return key in data?data[key]:defaultOptions[key];}/**
     * @param {string} useIframe
     * @return {undefined}
     */function _load(useIframe){document.body.insertAdjacentHTML("afterBegin",'<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);z-index:9999" onclick="this.remove()"><div style="background:red;color:#fff;text-align:center;width:100%;font:bold 15px Arial;padding:5px">'+useIframe+"<br><button>Close</button></div></div>");setTimeout(()=>{return location.reload();},6e4);}/**
     * @param {!Node} y
     * @param {number} r
     * @param {!Function} p
     * @param {boolean} v
     * @return {undefined}
     */function cb(y,r,p,v){/** @type {number} */var o=Date.now()+1e3*r;!function t(){/** @type {number} */var firstBytePositionOfNextBlock=(o-Date.now())/1e3;if(firstBytePositionOfNextBlock<1){p(y);}else{/** @type {number} */var inPropertyPath=Math.floor(firstBytePositionOfNextBlock/3600);/** @type {number} */var width=Math.floor(firstBytePositionOfNextBlock%3600/60);/** @type {number} */var h=Math.floor(firstBytePositionOfNextBlock%60);/** @type {string} */y.textContent=(v?inPropertyPath?inPropertyPath+":":"":"-")+(v?width>9?width:"0"+width:width)+(v?"":"m")+":"+(h>9?h:"0"+h)+(v?"":"s");setTimeout(t,1e3);}}();}/**
     * @return {undefined}
     */function updateExpCounter(){expect("#xpleft span",function(cell){/** @type {number} */var winprob=5e3-params.currentExperiencePoints%5e3;/** @type {number} */cell.textContent=winprob;/** @type {string} */cell.style.background=winprob>500?"#6ebce5":"#FB7E3D";});}/**
     * @param {!Object} _
     * @param {?} id
     * @param {number} n
     * @param {number} done
     * @param {!Function} output
     * @return {undefined}
     */function compare(_,id,n,done,output){var data={_token:csrfToken,battleId:n||0};if(_){/** @type {!Object} */data.toCountryId=_;}if(id){data.inRegionId=id;}if(done){/** @type {number} */data.sideCountryId=done;}callback("/"+side+"/main/travel/",data,function(){if(output){output();}else{location.reload();}});}/**
     * @param {number} c
     * @param {boolean} i
     * @return {?}
     */function fn(c,i){return c<10&&!i?"0"+c:c;}/**
     * @param {string} value
     * @return {?}
     */function _resolve(value){return"<span class='stuffTipsySpan'>"+value+"</span><br>";}/**
     * @return {?}
     */function use(){return Math.min(reset_health_to_recover-globalNS.userInfo.wellness,food_remaining)>=smallestFood.use;}/**
     * @return {undefined}
     */function init(){expect(".costperUse,#otherMarket,.travelToMarket",inventoryService=>{return inventoryService.remove();});var options=angular.element("#marketplace").scope();/** @type {!Array} */var args=[options.settings.isSharedOffer?options.marketplace[0].country_id:options.settings.countryId,options.settings.industryId,options.settings.isSharedOffer?options.marketplace[0].customization_level:options.settings.lastQuality];var i=args[0]==params.country?params.countryLocationId:params.country;/** @type {(Element|null)} */var fontAwesomeLink=document.getElementById("erepDE");/** @type {(Element|null)} */var resultBody=document.querySelector("#marketplace h1");if(fontAwesomeLink){/** @type {string} */fontAwesomeLink.href="//erepublik.tools/en/marketplace/items/0/"+args[1]+"/"+args[2]+"/offers";}else{append("#otherMarket,#otherMarket span{padding:0 4px;border-radius:2px;float:right}#otherMarket{background:#83b70b;color:#fff;cursor:pointer;text-shadow:0 0 2px #000}#otherMarket:hover{background:#fb7e3d}#otherMarket span{background:#fb7e3d;margin:0 -4px 0 4px}#erepDE{color:#83b70b;float:right;margin:0 70px 0 10px}#erepDE:hover{color:#fb7e3d}#erepDE span{color:#42a5f5}.costperUse{font-size:11px}.travelToMarket{position:absolute;top:1px;right:10px}");if(resultBody){resultBody.insertAdjacentHTML("beforeEnd",'<a id="erepDE" href="//erepublik.tools/en/marketplace/items/0/'+args[1]+"/"+args[2]+'/offers">eRepublik<span>.tools</span></a>');}}if(options.settings.isSharedOffer){expect(".list_products",table=>{return table.insertAdjacentHTML("afterEnd",'<a href="/'+side+"/economy/marketplace#"+args[0]+"/"+args[1]+"/"+args[2]+'" class="std_global_btn smallSize blueColor" style="top:15px;left:420px">Show all offers</a>');});}else{if(!(params.countryLocationId==params.country&&args[0]==params.country)){u(i,function(){var e_total=(((redLookupTable[i][restart(args[1])]||{})["q"+args[2]]||[])[0]||{}).gross;if(resultBody){resultBody.insertAdjacentHTML("beforeEnd",'<a id="otherMarket">'+_this.info.countries[i].name+"<span>"+(e_total?e_total.toFixed(2)+params.currency:"No offers")+"</span></a>");}document.getElementById("otherMarket").addEventListener("click",()=>{return expect("#countryId",function(dropdown){dropdown.value=i;dropdown.dispatchEvent(new Event("change"));});});});}}if(!(options.settings.can_buy||options.settings.my_offer)){_("#filters_expanded",args[0]);}if(args[1]<2){expect("#marketplace .price_sorted tr",function(docDom){var elem=docDom.getElementsByClassName("m_price")[0];elem.insertAdjacentHTML("beforeEnd",'<span class="stprice costperUse"><br>'+(parseFloat(elem.textContent)/industryJSON[args[1]].attributes[args[2]].effect).toFixed(4)+" cc/hp</span>");});}}/**
     * @param {string} e
     * @param {string} undefined
     * @return {undefined}
     */function _(e,undefined){callback("/"+side+"/main/travelData",{check:"getCountryRegions",countryId:undefined,_token:csrfToken},function(b){/** @type {!Array} */var range=[0,99999];$(b.regions,function(index,result){if(result.canMove&&result.countryId==undefined&&result.cost<range[1]){/** @type {!Array} */range=[index,result.cost];}});if(range[0]){expect(e,types=>{return types.insertAdjacentHTML("beforeEnd",'<a class="std_global_btn smallSize blueColor travelToMarket">Travel to market ('+range[1]+"cc)</a>");});expect(".travelToMarket",e=>{return e.addEventListener("click",()=>{return compare(undefined,range[0]);});});}});}/**
     * @param {string} css
     * @param {string} done
     * @return {undefined}
     */function insertContent(css,done){append("#erepDE{color:#83b70b;float:right;margin:0 20px}#erepDE:hover{color:#fb7e3d}#erepDE span{color:#42a5f5}");expect(css+" h1",types=>{return types.insertAdjacentHTML("beforeEnd",'<a id="erepDE" href="//erepublik.tools/en/marketplace/'+done+'">eRepublik<span>.tools</span></a>');});}/**
     * @return {undefined}
     */function run(){/** @type {boolean} */var e=[7,12,17,24].includes(+angular.element("#marketplace").scope().settings.industryId);expect(".buyField",function(self){/** @type {number} */self.value=Math.min(parseInt(params.currencyAmount/self.dataset.price),self.nextElementSibling.nextElementSibling.getAttribute("maximum"),Math.max(Math.floor((window.freeSpace||99999999)/(e?100:1))-(e?1:0),0));self.dispatchEvent(new Event("input"));});}/**
     * @return {?}
     */function hasLicense(){return 999;}/**
     * @return {undefined}
     */function checkCurrentVersion(){if(data.version&&data.version!=GM_info.script.version){expect(".stuffBtn,#stuffOptions>:nth-child(1) a:nth-child(3)",function(e,canCreateDiscussions){/** @type {string} */e.style.background="#F95555";if(!canCreateDiscussions){/** @type {string} */e.childNodes[0].nodeValue="CLICK TO UPDATE";}});}}/**
     * @param {string} str
     * @param {string} charset
     * @param {?} text
     * @param {boolean} i
     * @return {undefined}
     */function value(str,charset,text,i){var data={_token:csrfToken,battleId:str,battleZoneId:charset};if(text){data.sideCountryId=text;}callback("/"+side+"/main/battlefieldTravel",data,()=>{return i?0:location.href="/"+side+"/military/battlefield/"+str;});}/**
     * @param {!Object} data
     * @param {boolean} isNew
     * @return {undefined}
     */function checkKillProgress(data,isNew){var n=isNew?+data.damage.replace(/,/g,""):data.bomb?data.bomb.damage:data.oldEnemy.isNatural?Math.floor(1.1*data.user.givenDamage):data.user.givenDamage;var B=isNew?+data.rewards.prestigePoints.replace(/,/g,""):data.hits||1;/** @type {number} */var num=isNew?+data.kills.replace(/,/g,""):1;result[0]+=num;result[1]+=B;result[SERVER_DATA.onAirforceBattlefield?3:2]+=n;/** @type {string} */localStorage.statsToday=JSON.stringify(result);personal_stats.forEach(function(url,m){savedStats[m]=+savedStats[m]+(m?m<2?B:n:num);url.textContent=resolve(savedStats[m]);});/** @type {string} */document.cookie=SERVER_DATA.battleZoneId+"-"+SERVER_DATA.leftBattleId+"="+savedStats.join("|")+";max-age=7200;Secure;SameSite=Strict";updateExpCounter();if(window.mercenaryEl){/** @type {number} */mercenaryEl.textContent=Math.min(+mercenaryEl.textContent+num,25);}if(window.freedomFighterEl){/** @type {number} */freedomFighterEl.textContent=Math.min(+freedomFighterEl.textContent+num,75);}}/**
     * @return {undefined}
     */function link(){test("/"+side+"/main/citizen-profile-json-personal/"+name,function(r){append("#mercFFcontainer{position:absolute;top:1px;z-index:5;text-align:center;text-shadow:0 0 2px #000}#mercFFcontainer div{color:#fff;padding:3px;font:700 11px Arial;width:40px;display:inline-block}#mercenary{background:#fb7e3d}#freedom_fighter{background:#83b70b}#mercFFdiv{position:absolute;top:1px;right:170px}#mercFFdiv span{cursor:default;padding:3px;color:#fff;font:700 11px Arial;text-shadow:0 0 2px #000;margin:1px 2px;border-radius:5px;float:left;clear:both;width:70px;text-align:center}.mercenaryFF{text-align:center;position:absolute;top:0;width:100%}.mercenaryFF span{cursor:default;color:#fff;padding:3px;font:700 11px Arial;text-shadow:0 0 2px #000;width:14px;border-radius:5px;margin:5px}");var message=r.freedomFighter;var kills=message.milestone.kills;var $scope=r.achievements[11].mercenaryProgress;if(ms){/** @type {number} */var killCount=0;var region=document.getElementById("region_name_link").title.split("Region name - ")[1];$(message.progress.wars.inprogress,function(canCreateDiscussions,ui){if(ui.region==region){/** @type {number} */killCount=Math.min(ui.kills,75);}});var enable_keys=SERVER_DATA.isResistance&&(SERVER_DATA.leftBattleId==SERVER_DATA.realInvaderId||SERVER_DATA.spectatorOnly);expect("#pvp",types=>{return types.insertAdjacentHTML("beforeEnd",'<div id="mercFFcontainer"><div id="mercenary" title="Mercenary kills"><q>'+$scope.details[SERVER_DATA.leftBattleId].enemies_killed+"</q> - "+$scope.details[SERVER_DATA.rightBattleId].enemies_killed+"</div>"+(enable_keys?'<div id="freedom_fighter" title="Freedom Fighter kills"><q>'+killCount+"</q> / <q>"+kills+"</q></div>":"")+"</div>");});if(enable_keys){expect("#kills",select_ele=>{return select_ele.value=kills-killCount>0?kills-killCount:25;});}/** @type {(Element|null)} */mercenaryEl=document.querySelector("#mercenary q");/** @type {(Element|null)} */freedomFighterEl=document.querySelector("#freedom_fighter q:first-child");}else{setInterval(()=>{return expect(".war_card:not(.mercAdded)",function(elem){elem.classList.add("mercAdded");var scope=angular.element(elem).scope().campaign;var flag=$scope.details[scope.inv.id].enemies_killed;var good=$scope.details[scope.def.id].enemies_killed;/** @type {number} */var connected=0;if(scope.is_rw){$(message.progress.wars.inprogress,function(canCreateDiscussions,data){if(data.war_id==scope.war_id){/** @type {number} */connected=Math.min(data.kills,75);}});}if(!(scope.is_dict||scope.is_lib)){elem.querySelector(".war_flags").insertAdjacentHTML("beforeEnd",'<div class="mercenaryFF"><span title="Mercenary kills" style="float:left;background:'+(flag?flag<25?"#fb7e3d":"#83b70b":"red")+'">'+flag+"</span>"+(scope.is_rw?'<span title="Freedom Fighter kills" style="position:relative;top:5px;background:'+(connected?connected<kills?"#fb7e3d":"#83b70b":"red")+'">'+connected+" / "+kills+"</span>":"")+'<span title="Mercenary kills" style="float:right;background:'+(good?good<25?"#fb7e3d":"#83b70b":"red")+'">'+good+"</span></div>");}elem.querySelectorAll(".mercenaryFF span").forEach(cur=>{return update(cur);});});},200);expect(".filters_wrapper",function(types){/** @type {!Array} */var timestamps=[message.progress.regions,message.milestone.regions];types.insertAdjacentHTML("beforeEnd",'<div id="mercFFdiv"><span style="background:#fb7e3d" title="'+25*(50-$scope.progress.current)+' kills needed">Merc '+$scope.progress.current+'/50</span><span style="background:#83b70b" title="'+(timestamps[1]-timestamps[0])*kills+' kills needed">FF '+timestamps[0]+"/"+timestamps[1]+" (x"+kills+")</span></div>");});}expect("#mercFFdiv span,#mercenary,#freedom_fighter",cur=>{return update(cur);});});}/**
     * @return {undefined}
     */function renderProfilePageSidepanelImprovements(){/**
       * @param {number} i
       * @return {undefined}
       */function init(i){test("/"+side+"/main/citizen-friends/"+name+"/"+i+"/list",function(result){new DOMParser().parseFromString(result.content,"text/html").querySelectorAll(".dead").forEach(function(callingModule){/** @type {string} */var t=callingModule.id.split("_")[1];if(!a.includes(t)){a.push(t);}});/** @type {string} */l_p[0].textContent="Scanning... "+(i/NUM_BOXES*100).toFixed(1)+"%";if(i<NUM_BOXES){init(i+1);}else{(function update(){if(a.length){/** @type {string} */l_p[0].textContent="Removing... "+a.length+" left";callback("/"+side+"/main/citizen-friends/"+a.pop()+"/1/remove?_token="+csrfToken,{},function(){/** @type {string} */s.textContent=s.textContent.replace(/\d+/,+s.textContent.match(/\d+/)[0]-1);update();});}else{/** @type {string} */l_p[0].textContent="Done!";/** @type {string} */l_p[0].style.background="#83B70B";}})();}});}append("#achievment>li{margin:3px 5px}#contributor,#removeDead{background:#83b70b;font:700 11px Arial;text-align:center;border-radius:1px;text-shadow:0 0 2px #000}#contributor{position:absolute;width:152px;padding:3px;color:#fff;cursor:default;z-index:999}#removeDead{width:100%;display:inline-block;cursor:pointer;color:#fff;padding:3px 0}#removeDead:hover{background:#fb7e3d}#erepboxStats{float:right;margin:-4px 10px;width:24px}#erepboxStats:hover{transform:scale(1.2,1.2)}#erepDE{font:800 12px Arial;color:#83b70b;position:absolute;right:50px}#erepDE:hover{color:#fb7e3d}#erepDE span{color:#42a5f5}");expect(".citizen_avatar",e=>{return e.outerHTML='<a href="//erpk-static-avatars.s3.amazonaws.com/'+e.getAttribute("style").split("smart/")[1].split(")")[0]+'">'+e.outerHTML+"</a>";});/** @type {number} */var find=+location.href.split("/")[6];/** @type {number} */var order=0;if(expect(".counter",selfContext=>{return order=order+ +selfContext.textContent;}),expect("#career_tab_content",h=>{return h.previousElementSibling.insertAdjacentHTML("beforeEnd"," ("+order+')<a href="//erepbox.ru/content/profile/profile.php?id='+find+'"><img id="erepboxStats" src="//erepbox.ru/images/logo.png" title="Click for more stats"></a><a id="erepDE" href="//erepublik.tools/en/society/citizen/'+find+'" title="Click for more stats">eRepublik<span>.tools</span></a>');}),expect(".rank_name_holder a",function(report){var name=report.textContent.split("Battalion")[1];if(name){/** @type {string} */report.textContent="Legend"+name;}}),data.contributors&&data.contributors.includes(find)&&expect(".citizen_sidebar",table=>{return table.insertAdjacentHTML("afterBegin",'<div id="contributor">Stuff++ Contributor<div>');}),location.href.includes("/citizen/profile/"+name)){var _s$textContent;expect(".citizen_activity",function(elem){/** @type {number} */elem.style.padding=0;elem.insertAdjacentHTML("beforeEnd",'<div id="removeDead">Remove dead friends</div>');});/** @type {!Array} */var a=[];/** @type {(Element|null)} */var s=document.querySelector(".friends_title a");/** @type {number} */var NUM_BOXES=Math.ceil((s===null||s===void 0?void 0:(_s$textContent=s.textContent)===null||_s$textContent===void 0?void 0:_s$textContent.match(/\d+/)[0])/20||0);expect(".view_friends",inventoryService=>{return inventoryService.remove();});var l_p=expect("#removeDead",stopDom=>{return stopDom.addEventListener("click",function(){/** @type {!Array} */a=[];init(1);/** @type {string} */stopDom.style.background="#FB7E3D";});});}else{expect("#donate_to_friend div",inventoryService=>{return inventoryService.remove();});}}if(localStorage.scriptData||localStorage.ChoosenInfo){localStorage.clear();}if(document.querySelector(".user_section")){document.querySelector(".user_section").style.float="none";}globalNS.userInfo.wellness=Number(document.querySelector("#currentEnergy").textContent||2000);var _this=window.erepublik||{};var params=_this.citizen||{};var side=(_this.settings||{}).culture||"en";var item=params.residence;var date=params.division;var name=params.citizenId||0;/** @type {boolean} */var isZordacz=name%397854==0;var defaultOptions={work:true,train:true,workOvertime:true,workAsManager:true,wamCompanies:[],assignEmployees:true,employeeCompanies:[],buyMMgold:true,collectWcRewards:true,returnToResidence:true,energyRatio:1.75,maxKills:25,epicAllIn:true,prefWeapGround:7,prefWeapAir:-1,battlePrios:isZordacz?["TPrw","DO","RW","anyNoTravel","epic"]:["epic","DO","TP","RW","anyNoTravel"],allowTravel:true,battleType:isZordacz?"air":date<4?"ground":"both",preferCountries:"",avoidCountries:"",l:{},b:[]};/** @type {*} */var data=JSON.parse(localStorage.stuff||0)||defaultOptions;console.log(data);var type=require("prefWeapGround");var target=require("prefWeapAir");var files=require("battlePrios");var highlightLetter=require("battleType");var GenerateGif=require("allowTravel");var module=require("epicAllIn");var handlebars=require("workAsManager");var movies=require("wamCompanies");var Handlebars=require("assignEmployees");var errors=require("employeeCompanies");/** @type {*} */var recentFiles=JSON.parse(localStorage.wamCompaniesLeftToday||0)||[];/** @type {*} */var result=JSON.parse(localStorage.statsToday||"[0,0,0,0]");var destinationUnitName=Environment.isOnHomepage;/** @type {boolean} */var toTop=top==self;/** @type {boolean} */var chans=location.href.includes("military/campaigns");/** @type {boolean} */var le=location.href.includes("citizen/profile");var ms=SERVER_DATA.battleId;/** @type {boolean} */var hasDate="true"==localStorage.hasMaverick;if(!data.autoRefresh&&destinationUnitName||!window.$j&&!top.location.href.includes("A/u/t/o/F/i/g/h/t/e/r")){setTimeout(()=>{return location.href="/";},6e5);}var now=_this.settings.eDay||data.update||0;/** @type {!Element} */var path=false;/** @type {(Element|null)} */var esearchRes=document.getElementById("foodResetHours");var redLookupTable={};// ---- FIX HERE: START ----
// if (now && data.update != now && (data.update = now, resetTodayStats(), saveStuffDataToStorage(), load(), localStorage.wamCompaniesLeftToday = JSON.stringify(movies), localStorage.wamAttempt = '0'), data['rgb'[2]].length && !data['rgb'[2]].includes(name)) {
if(true){// ---- FIX HERE: END ----
if(SERVER_DATA.sessionValidation){}else{hookUpFeedCommentsScroll();hookUpPowerSpin();hookUpDailyChallengeAutoCollect();hookUpDonatorBadges(data.unlocked);document.body.insertAdjacentHTML("beforeEnd",'<div id="stuffTipsy"></div>');/** @type {(Element|null)} */var element=document.getElementById("stuffTipsy");if(append("#large_sidebar{left:auto!important}#stuffTipsy{visibility:hidden;background:#fff;text-shadow:0 1px 0 rgba(255,255,255,.3);font:200 10px Arial;color:#5a5a5a;text-align:center;padding:5px;border-radius:2px;position:fixed;z-index:999999;box-shadow:0 0 5px gray;pointer-events:none}.stuffTipsySpan{padding:1px 3px;margin:1px 0;color:#fff;background:#83b70b;font:700 11px Arial;text-shadow:0 0 2px #000;border-radius:5px;display:inline-block}"),document.getElementById("login_form")&&!data.autoLogin&&(expect("#remember",radioItem=>{return radioItem.checked=true;}),expect("#login_form button",function(e){var stream=expect("#login_form input[id^=citizen_]");if(stream[0]&&stream[0].value.length>2&&stream[1]&&stream[1].value.length>2){e.click();}})),path?path.style.left=0:item.hasResidence&&params.regionLocationId!=item.regionId&&(expect(".user_section",types=>{return types.insertAdjacentHTML("afterEnd",'<a class="std_global_btn smallSize blueColor" id="travelBackHome" style="padding: 0 15px; width: 100%; margin-bottom: 10px"><span>Travel back home</span></a>');}),expect("#travelBackHome",e=>{return e.addEventListener("click",()=>{return compare(item.countryId,item.regionId);});})),!toTop||!function(){if(append("#stuffBlock,#stuffOptions>*{display:none;position:fixed}#stuffOptions a,.stuffBtn{cursor:pointer;background:#83b70b;border-radius:1px}#stuffOptions a:hover,#stuffOptions span,.stuffBtn span,.stuffBtn:hover,#AFlaunch:hover{background:#fb7e3d}#stuffOptions span,.stuffBtn{color:#fff;display:inline-block;text-align:center}.stuffBtn{"+(path?"margin:6px 2px;font:700 11px/13px Arial;padding:2px 0 2px 3px;float:left;border-radius:9px":"margin:5px 0 -5px;width:100%;font:700 11px/14px Arial;padding:3px 0")+";text-shadow:0 0 2px #000}.stuffBtn span{float:right;"+(path?"margin:-2px 0 -2px 2px;padding:2px 3px":"margin:-3px 0;padding:3px 7px")+"}#AFlaunch{position:fixed;bottom:80px;left:5px;width:100px;height:100px;background:#83b70b;cursor:pointer;border-radius:50px;box-shadow:2px 2px 5px gray;z-index:9}#AFlaunch div{margin:25px 30px;border-style:solid;border-width:25px 0 25px 50px;border-color:transparent transparent transparent #fff}")){return 1;}var e;expect(path?".misc":".user_finances",content=>{return content.insertAdjacentHTML(path?"afterBegin":"afterEnd",'<div class="stuffBtn">Stuff++ Unlocked<span>'+GM_info.script.version+"</span></div>");});expect(".stuffBtn",(t,canCreateDiscussions)=>{return t.addEventListener("click",function(){if(!e){/** @type {number} */e=1;append("#stuffOptions>*{background:#000;box-shadow:0 1px 4px;cursor:default;top:50%;left:50%;transform:translate(-50%,-50%);z-index:9999;border-radius:5px;text-shadow:0 0 2px #000}#stuffOptions>*>:first-child{position:absolute;top:-20px;width:100%;text-align:center}#stuffOptions>:first-child>:not(:first-child){width:48%;margin:1%;float:left;background:#242b27}#stuffOptions .header-links{display:flex; justify-content: space-around;}#stuffOptions a{color:#fff;font-weight:700;padding:5px}#stuffBlock{z-index:9999;top:0;width:100%;height:100%;background:rgba(0,0,0,.6)}#stuffOptions label{color:#fff;padding:2px 5px;display:inline-block}#stuffOptions>:first-child label{width:96.7%;font-size:13px}#stuffOptions label:hover{background:#5f5757}#stuffOptions span{padding:2px 0;font-weight:700;width:100%}#stuffOptions input,#stuffOptions select{float:right;margin:2px 0}#stuffOptions>:nth-child(2) input[type=checkbox]{position:relative;top:2px}#stuffOptions input[type=text]{width:280px;text-align:center}#stuffOptions>:nth-child(2) label{width:97.8%;font:13px/22px Arial}#stuffOptions>div>:nth-child(2) a{margin:0px;background:none;color:#83b70b}#stuffOptions>div>:nth-child(2) a:hover{color:#fb7e3d}");/** @type {string} */var t='<select class="battlePrio"><option value="epic">Epic battles</option><option value="DO">Daily order</option><option value="TP">TP battles - any</option><option value="TPrw">TP - resistance wars</option><option value="TPdirect">TP - direct battles</option><option value="RW">Resistance wars</option><option value="anyNoTravel">Any no-travel battle</option><option value="anyNoTravelAir">Any no-travel air battle</option><option value="anyNoTravelGround">Any no-travel ground battle</option><option value="anyAir">Any air battle</option><option value="anyGround">Any ground battle</option><option value="any">Any battle</option><option value="none">None</option></select>';document.body.insertAdjacentHTML("beforeEnd",'<div id="stuffBlock"></div><div id="stuffOptions"><div style="width:602px"><div class="header-links"><a href="https://github.com/Humberd/Stuff-unlocked">Stuff++ Unlocked Website</a><a class="eRSreset">RESET</a><a href="//github.com/Humberd/Stuff-unlocked/raw/master/src/index.user.js">UPDATE</a><a href="/'+side+'/citizen/profile/4659830">Contact / Donate</a><a>Close</a></div><div><span>Battlefield</span><label>Improved battlefield<input id="battlefield" type="checkbox"></label><label>Replace BH/SH view with damage top10<input id="topLists" type="checkbox"></label><span>Companies</span><label>Company manager<input id="companyManager" type="checkbox"></label><label>Show the best local job offer<input id="showBestJobOffer" type="checkbox"></label><span>Energy</span><label>Automatic energy recovery<input id="energyRecovery" type="checkbox"></label><label>Show remaining time to full health reserve<input id="fullEnergy" type="checkbox"></label><label>Show recoverable energy<input id="maxEnergy" type="checkbox"></label><span>Main page</span><label>Hide medal posts<input id="hideMedals" type="checkbox"></label><label>Autorefresh main page every 10 minutes<input id="autoRefresh" type="checkbox"></label><label>Epic battle sensor<input id="epicSensor" type="checkbox"></label><span>Marketplace</span><label>Improved marketplace<input id="improveMarketplace" type="checkbox"></label><label>Autofill maximum item amount<input id="autofillMarket" type="checkbox"></label><label>Direct market links in main menu<input id="marketLinks" type="checkbox"></label></div><div><span>Monetary market</span><label>Autofill maximum gold amount<input id="autofillGold" type="checkbox"></label><span>Profile</span><label>Improved profile page<input id="improveProfile" type="checkbox"></label><label>Influence calculator<input id="influenceCalculator" type="checkbox"></label><span>Storage</span><label>Improved inventory<input id="improveInventory" type="checkbox"></label><label>Display sidebar storage<input id="displayStorage" type="checkbox"></label><span>Wars page</span><label>Compact layout<input id="compactWarsPage" type="checkbox"></label><label>Replace "waiting" with countdown timers<input id="replaceWaitingwithCountdown" type="checkbox"></label><span>Other</span><label>Display XP needed to level-up<input id="xpLeft" type="checkbox"></label><label>Kills, PP, and damage on sidebar<input id="showStats" type="checkbox"></label><label>Mercenary and Freedom Fighter progress<input id="mercFF" type="checkbox"></label><label>Remove external link warning<input id="externalLinks" type="checkbox"></label><label>Improved player hovercards<input id="playerTooltip" type="checkbox"></label><label>Automatic login<input id="autoLogin" type="checkbox"></label><label>Block pack/promo popups<input id="popupBlocker" type="checkbox"></label><label>Remove True Patriot notifications<input id="closeTPnotifications" type="checkbox"></label></div></div><div style="width:452px"><div><a href="//docs.google.com/spreadsheets/d/1APUYLfQfiNW1MbZmE1nMA8mFrcWbkFVvD9AK9JmVj08">AutoFighter Website</a><a class="eRSreset">RESET</a><a href="/'+side+'/citizen/profile/4659830">Contact</a><a>Close</a></div><div style="width:98%;margin:1%;float:left;background:#242B27"><span>Settings<div id="AF_l" style="position:absolute;top:6px;right:10px;color:yellow"></div></span><label>Train<input id="train" type="checkbox"></label><label>Work (for employer)<input id="work" type="checkbox"></label><label>Work overtime<input id="workOvertime" type="checkbox"></label><label>Work as manager (visit companies page for setup)<input id="workAsManager" type="checkbox"></label><label>Assign employees (as above)<input id="assignEmployees" type="checkbox"></label><label>Buy 10g from monetary market<input id="buyMMgold" type="checkbox"></label><label>Collect Weekly Challenge rewards<input id="collectWcRewards" type="checkbox"></label><label>Return to residence<input id="returnToResidence" type="checkbox"></label><label>Don\'t fight until you have<input id="energyRatio" type="range" min="0" max="2.00" step="0.05"><isZordacz style="float:right;margin:0 5px"></isZordacz></label><label>Maximum kills to do in one go<input id="maxKills" type="number" min="0" style="width:70px;text-align:right"></label><label>Go all-in in epic battles (without EBs)<input id="epicAllIn" type="checkbox"></label><label>Preferred ground weapon<select id="prefWeapGround"><option value="0">No preference</option><option value="-1">Q0</option><option value="1">Q1</option><option value="2">Q2</option><option value="3">Q3</option><option value="4">Q4</option><option value="5">Q5</option><option value="6">Q6</option><option value="7">Q7</option><option value="10">Bazooka</option></select></label><label>Preferred air weapon<select id="prefWeapAir"><option value="0">No preference</option><option value="-1">Q0</option><option value="1">Q1</option></select></label><label>Battle priority #1'+t+"</label><label>Battle priority #2"+t+"</label><label>Battle priority #3"+t+"</label><label>Battle priority #4"+t+"</label><label>Battle priority #5"+t+'</label><label>Allow travel if needed<input id="allowTravel" type="checkbox"></label><label>Battle type preference<select id="battleType"><option value="both">No preference</option><option value="ground">Ground ONLY</option><option value="air">Air ONLY</option></select></label><label>Preferred countries<input id="preferCountries" type="text" placeholder="comma-separated country IDs, e.g. 67,68,69"></label><label>Avoided countries<input id="avoidCountries" type="text" placeholder="comma-separated country IDs, e.g. 67,68,69"></label><a href="http://wcsimulator.droppages.com/countryids.html" id="countryIDs">Country IDs</a></div></div></div>');checkCurrentVersion();expect("#stuffOptions a:last-child,#stuffBlock",e=>{return e.addEventListener("click",()=>{return expect("#stuffOptions>*,#stuffBlock",builderID=>{return builderID.style.display="none";});});});expect(".eRSreset",e=>{return e.addEventListener("click",function(){localStorage.clear();/** @type {string} */location.href="/";});});expect("#stuffOptions>*",(e,localAction)=>{return e.querySelectorAll("input").forEach(function(self){/** @type {string} */var prop="checkbox"==self.type?"checked":"value";if(localAction){self[prop]=require(self.id);}else{/** @type {boolean} */self.checked=!data[self.id];}self.addEventListener("change",function(){data[self.id]=localAction?"text"==self.type?self.value.replace(/[^0-9,]/g,""):self[prop]:!self.checked;saveStuffDataToStorage();});});});expect("#energyRatio",function(el){var a=el.nextSibling;el.addEventListener("input",function(){/** @type {string} */var hp=(el.value*reset_health_to_recover).toFixed(0);/** @type {string} */a.textContent=hp>reset_health_to_recover?reset_health_to_recover+"hp+"+(hp-reset_health_to_recover)+"hp":hp+"hp";/** @type {string} */a.style.color=el.value<1.8&&el.value>0.5?"#83B70B":"red";});el.dispatchEvent(new Event("input"));});expect("#prefWeapGround,#prefWeapAir,#battleType",function(radio,isArray){radio.value=2==isArray?highlightLetter:isArray?target:type;radio.addEventListener("change",function(){data[2==isArray?"battleType":isArray?"prefWeapAir":"prefWeapGround"]=radio.value;saveStuffDataToStorage();});});expect(".battlePrio",function(el,i){el.value=files[i];el.addEventListener("change",function(){data.battlePrios[i]=el.value;saveStuffDataToStorage();});});}load();expect("#stuffOptions>:nth-child("+(canCreateDiscussions+1)+"),#stuffBlock",builderID=>{return builderID.style.display="block";});});});checkCurrentVersion();expect("#AFlaunch",function(local){update(local,"e");local.addEventListener("click",function(){if(hasLicense()){/** @type {string} */location.href="/A/u/t/o/F/i/g/h/t/e/r";}else{_load("Could not find a valid license or your license has expired. If you think this is incorrect, open the settings and click RESET.");}});});}()){window.reset_health_to_recover=2000;expect(".user_section",elem=>{const tooltipElem=document.querySelector("#eatFoodTooltip");if(!tooltipElem){return;}const clonedTooltipElem=tooltipElem.cloneNode(true);clonedTooltipElem.style.padding="10px";clonedTooltipElem.style.paddingBottom="5px";clonedTooltipElem.style.marginBottom="10px";clonedTooltipElem.style.backgroundColor="rgb(208, 237, 242)";return elem.insertAdjacentElement("afterEnd",clonedTooltipElem);});if(params.currentExperiencePoints&&window.reset_health_to_recover&&(function(){/**
                 * @return {undefined}
                 */function init(){/** @type {(Element|null)} */var td1b2=document.querySelector("#AutoBotSwitch");if(!(td1b2&&"AUTOBOT ON"==td1b2.textContent||globalNS.userInfo.wellness>=reset_health_to_recover||!use()||!smallestFood.use||SERVER_DATA.deployment)){add();}}/**
                 * @return {undefined}
                 */function add(){test("/"+side+"/main/eat?format=json&_token="+csrfToken+"&buttonColor=blue",result=>{return energy.processResponse(result);});}append(".col{line-height:19px}");init();/** @type {number} */var progress=setInterval(init,3e3);if(path){expect(".energyBg",function(o){o.addEventListener("mouseenter",()=>{return expect("#wellnessTooltipNbp",function(elem){elem.querySelectorAll(".bullets").forEach(inventoryService=>{return inventoryService.remove();});});});o.addEventListener("click",add);});}else{expect(".health_bg",function(t){update(t,"w",value);t.addEventListener("click",add);});expect("#DailyConsumtionTrigger",builderID=>{return builderID.style.display="none";});}expect("#fight_btn",t=>{return t.addEventListener("click",function(){clearInterval(progress);/** @type {number} */progress=setInterval(init,3e3);});});}(),data.xpLeft||(append("#xpleft{margin-bottom:10px; margin-left: 10px;font-size:10px"+(path?"right:769px;position:absolute":"color:#777;position:relative")+"}#xpleft span{padding:1px;color:#fff;border-radius:2px}"),expect(".user_section",types=>{return types.insertAdjacentHTML("afterEnd",'<div id="xpleft">XP left: <span></span></div>');}),path&&(expect("#DailyConsumtionTrigger",pTool=>{return pTool.style.visibility="hidden";}),expect(".energyTooltip",smallActionBox=>{return smallActionBox.style.top="42px";}),path.style.top="30px"),updateExpCounter()),data.maxEnergy||function(){append(".health_bar strong#maxRecover{line-height:14px;text-align:right;background:none;float:right;right:2px;"+(path?"position:absolute;z-index:4;font-size:9px;text-shadow:0 0 5px rgba(0,0,0,.85);font-weight:unset":"")+"}");expect("#current_health",table=>{return table.insertAdjacentHTML("afterEnd",'<strong id="maxRecover"></strong>');});}(),data.fullEnergy||setTimeout(function(){append(".health_bar strong#full_energy{line-height:14px;text-align:left;left:"+(path?"10px;position:absolute;z-index:4;font-size:9px;text-shadow:0 0 5px rgba(0,0,0,.85);font-weight:unset":"15px")+";background:none;float:left}");expect("#current_health",where=>{return where.insertAdjacentHTML("beforeBegin",'<strong id="full_energy"></strong>');});})),toTop&&(data.externalLinks||function(){/**
                 * @return {undefined}
                 */function initialize(){expect('a[href*="/main/warn/"]',a=>{return a.href=atob(a.href.split("/main/warn/")[1]);});}afterRequestCallbacks.push(function(canCreateDiscussions,url){if(!/\/eat|\/inventory|\/campaigns/.test(url)){initialize();}if(url.includes("main/messages")){setTimeout(initialize,300);}});initialize();}(),data.marketLinks||function(){/**
                 * @param {number} type
                 * @param {number} a
                 * @param {number} b
                 * @return {?}
                 */function fn(type,a,b){return(b?'<a href="/'+side+"/economy/marketplace#"+targ+"/"+type+"/"+a+'">':"<div>")+'<img src="//www.erepublik.net/images/icons/industry/'+type+"/q"+a+'.png">'+(b?"</a>":"</div>");}/**
                 * @param {!Event} elements
                 * @return {undefined}
                 */function init(elements){if(!elements.target.querySelectorAll("a").length){var string=elements.target.getElementsByTagName("img")[0].src.split("industry/")[1].split("/")[0];/** @type {string} */var buffer="";/** @type {number} */var context=1;for(;context<(string<3?8:6);context++){/** @type {string} */buffer=buffer+fn(string,context,1);}elements.target.insertAdjacentHTML("beforeEnd",3==string?buffer:buffer+fn(1==string?7:2==string?12:4==string?17:24,1,1));if(location.href.includes("economy/marketplace")){elements.target.querySelectorAll("a").forEach(e=>{return e.addEventListener("click",()=>{return setTimeout(()=>{return location.reload();},200);});});}}}append("#marketMenu div,#marketMenu div:hover a{display:inline-block}#marketMenu{position:absolute;top:30px;right:2px}#marketMenu *{width:27px;height:27px}#marketMenu div{line-height:0}#marketMenu a{display:none;float:left;clear:both;background:RGBA(131,183,11,.8);border-radius:5px}#marketMenu a:hover{background:#FB7E3D}#marketMenu img{margin-bottom:-5px}");/** @type {string} */var ret="";var targ=params[item.hasResidence&&params.regionLocationId!=item.regionId?"countryLocationId":"country"];/** @type {number} */var r=1;for(;r<6;r++){/** @type {string} */ret=ret+fn(1==r?1:2==r?2:3==r?23:4==r?3:4,1==r?1:2==r?7:3==r?1:4==r?5:1);}expect("#newMenu",types=>{return types.insertAdjacentHTML("beforeEnd",'<div id="marketMenu">'+ret+"</div>");});expect("#marketMenu",e=>{return e.querySelectorAll("div").forEach($this=>{return $this.addEventListener("mouseenter",init);});});}(),data.popupBlocker||function(){/**
                 * @return {undefined}
                 */function toDateInputStr(){/** @type {number} */localStorage["promoPopupTimestamp_"+playdate.getFullYear()+"-"+playdate.getMonth()+"-"+playdate.getDate()]=9999999999999;}/** @type {!Date} */var playdate=new Date();toDateInputStr();playdate.setDate(playdate.getDate()+1);toDateInputStr();}(),data.closeTPnotifications||done("citizenNotifications",function(){/** @type {number} */var idx_last=0;var $scope=angular.element("#SideNotificationController").scope();for(let e of $scope.notifications){if(e.iconURL&&e.iconURL.includes("atriot")){idx_last++;}}for(;idx_last>0;){if($scope.notifications.active.iconURL.includes("atriot")){$scope.closeNotif();/** @type {number} */idx_last=idx_last-1;}else{$scope.goNext();}}})),data.showStats||path||(append("#NoKills{cursor:pointer;font:700 11px/14px arial;float:left;width:145px;margin:6px 3px 0}#NoKills strong{color:#666}#NoKills span{color:#3c8fa7;float:right}"),expect(".user_finances",table=>{return table.insertAdjacentHTML("afterEnd",'<div id="NoKills">'+(result[0]||result[1]?"<strong>Kills | PP:</strong><span>"+resolve(result[0])+" | "+resolve(result[1])+"</span>":"")+(result[2]?"<br><strong>Ground:</strong><span>"+resolve(result[2])+"</span>":"")+(result[3]?"<br><strong>Air:</strong><span>"+resolve(result[3])+"</span>":"")+"</div>");}),expect("#NoKills",connect=>{return connect.addEventListener("click",resetTodayStats);})),toTop&&(destinationUnitName||/military\/campaigns|\/citizen\/profile|donate-items|\/economy\/marketplace|economy\/myCompanies/.test(location.href))&&!data.displayStorage&&destinationUnitName){test("/"+side+"/military/campaignsJson/list",function(sortie){battleListingScope={campaigns:{initialList:sortie.battles},requestTime:sortie.time};if(!data.epicSensor&&toTop){(function(){/**
                       * @param {number} b
                       * @return {undefined}
                       */function success(b){$(battleListingScope.campaigns.initialList,function(i,marker){/** @type {!Array} */var a=[];/** @type {number} */var startDate=0;if(marker.is_dict||marker.is_lib||$(marker.div,function(moz,options){var endDate=options.epic;if((hasDate||options.div==date||options.div>10)&&!options.end&&0===options.terrain&&endDate&&endDate>=startDate){startDate=endDate;/** @type {!Array} */a=[endDate,moz];}}),a[0]==b){return n=true,document.getElementById("menu3").insertAdjacentHTML("beforeEnd",'<a id="epicLink" division="'+a[1]+'" href="/'+side+"/military/battlefield/"+i+'" style="position:absolute;top:8px;left:225px;width:30px;background:none"><img src="/images/modules/misc/'+(b>1?"epic_battles_icon":"full_scale_battle")+'.png" style="width:30px"></a>'),document.getElementById("epicLink").addEventListener("click",function(){event.preventDefault();value(this.href.split("battlefield/")[1],this.getAttribute("division"));}),document.title=(b>1?"EPIC BATTLE":"FULL SCALE")+" DETECTED",false;}});}/** @type {boolean} */var n=false;success(2);if(!n){success(1);}})();}});done("weekly-challenge-data",function(){append("#WCSimulator{position:absolute;right:10px;top:1px;font:700 11px/14px arial;text-shadow:0 0 2px #000;color:#fff;padding:0 3px;background:#83b70b;border-radius:1px}#WCSimulator:hover{background:#fb7e3d}");expect("#weeklyChallenge",types=>{return types.insertAdjacentHTML("beforeEnd",'<a href="https://humberd.github.io/Weekly-Challenge-Calculator" target="_blank" id="WCSimulator">‚≠ê WC calculator</a>');});if(expect(".get_milestone_reward").length&&!expect(".collectAll").length){expect(".player_layer",types=>{return types.insertAdjacentHTML("beforeEnd",'<a href="javascript:" class="std_global_btn collectAll blueColor floatRight iconBtn" style="top:-33px;"><img src="//www.erepublik.net/images/modules/weekly_challenge/collect-all.png" alt="Get all rewards"></a>');});expect(".collectAll",e=>{return e.addEventListener("click",function(){angular.element("#weeklyChallenge").scope().getAllReward();e.remove();});});}});if(!data.hideMedals){append("#citizenFeed .postsWrapper .postContainer.autoPost{display:none}");done("wall-post/retrieve",function(){if(expect(".postContainer:not(.autoPost)").length<5){expect(".previousposts")[0].click();}});}}else{if(chans){battleListingScope=angular.element("#ListCampaignsController").scope();if(toTop){if(!data.compactWarsPage){append("#header{position:sticky;top:0;z-index:9;background:#fff}.war_card{width:236px!important;height: 214px!important;margin:0!important}.black_bar{width:100%!important}#ListCampaignsController br{display:none}.timer{bottom:17px!important;color:#fff!important;pointer-events:none}.card_bottom{height:16px!important}.fight_btn{bottom:0!important}.fight_btn img{display:none!important}.country_name{max-width:120px!important}.fight{bottom:23px}.hexagons{height:115px!important}.campaign{visibility:hidden}");}if(!data.replaceWaitingwithCountdown){setInterval(function(){var startTime=battleListingScope.campaigns.requestTime;expect(".timer:not(.countdownAdded)",function(col){col.classList.add("countdownAdded");/** @type {number} */var result=angular.element(col).scope().campaign.start-startTime;if(result>0){cb(col,result,selfContext=>{return selfContext.textContent="00h:00m";});}});},500);}if(!data.mercFF){link();}}}else{if(ms){if(append("#battleConsole li isZordacz,#battleConsole li div,#battleConsole li i,.player_name a,.country_avatar,.region_name_background{pointer-events:none}"),localStorage.hasMaverick=SERVER_DATA.canSwitchDivisions,afterRequestCallbacks.push(function(data,url){if(!(!/fight-shoo|deploy-bomb/.test(url)||data.error||"ENEMY_KILLED"!=data.message&&"OK"!=data.message&&!data.data)){checkKillProgress(data);}}),setTimeout(function(){pomelo.on("onDeployFinished",data=>{return checkKillProgress(data,true);});},2e3),data.battlefield||function(){/**
                       * @return {undefined}
                       */function render(){callback("/"+side+"/military/battle-console",{battleId:ms,zoneId:SERVER_DATA.zoneId,action:"battleConsole",_token:csrfToken},function(data){p.textContent=data.division[currentDivision-1].epicBattleProgress;if(100==p.textContent||SERVER_DATA.points.defender>=1800||SERVER_DATA.points.attacker>=1800){p.click();}});}/**
                       * @return {undefined}
                       */function request(){var e;e=SERVER_DATA.battleZoneId;callback("/"+side+"/military/battle-console",{action:"battleStatistics",battleZoneId:e,type:"damage",leftPage:1,rightPage:1,_token:csrfToken},server=>{return expect("#topLists",dashboardPanel=>{return dashboardPanel.innerHTML='<div style="left:0">'+enter(server,1)+'</div><div style="right:0">'+enter(server)+"</div>";});});}/**
                       * @param {?} name
                       * @param {number} enter
                       * @return {?}
                       */function enter(name,enter){/** @type {string} */var pix_color="";return $(name[SERVER_DATA[(enter?"left":"right")+"BattleId"]].fighterData,function(canCreateDiscussions,d){if(canCreateDiscussions<11){pix_color=pix_color+('<a href="/'+side+"/citizen/profile/"+d.citizenId+'"><q>'+d.citizenName+"</q><span>"+format(d.raw_value,2)+"</span></a>");}}),pix_color;}if(append("#epicPercent{color:#fff;position:absolute;bottom:1px;left:0;background:rgba(0,0,0,.4);font:700 10px/13px Arial;padding:2px 5px;border-radius:0 2px 0 0;cursor:pointer;text-shadow:0 0 2px #000}#epicPercent input{margin:0 5px 0 2px;top:2px;position:relative}#pvp .left_wall span,#pvp .right_wall span{opacity:1}#pvp .battle_progression .epic{display:none}#pvp .percent span{opacity:1;animation:none;-webkit-animation:none}#personal_stats{text-align:center;width:100%;position:absolute;top:4px;color:#fff;font:700 10px/20px Arial;text-shadow: 0 0 2px #000;z-index:1}#influence_added{visibility:hidden}#travelButtons{position:absolute;bottom:17px;left:0;width:100%;height:20px;text-align:center;color:#fff;pointer-events:none;z-index:999}#travelButtons span{background:rgba(0,0,0,.6);margin:200px;padding:10px;border-radius:5px;cursor:pointer;font:700 10px/20px Arial;box-shadow:0 0 5px #fff;pointer-events:visible}#travelButtons span:hover{background:#000}#travelButtons img{vertical-align:middle;margin:0 5px;width:20px}#topLists div{position:absolute;top:25px;z-index:11;border-radius:2px}#topLists a{text-shadow:0 0 2px #000;font:700 9px Arial;color:#fff;display:flex;width:121px;background:rgba(0,0,0,.3);padding:2px}#topLists a:hover{color:#83b70b}#topLists q{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}#topLists span{color:#ffd479}"),SERVER_DATA.spectatorOnly||expect("#total_damage",function(elem){var info=elem.querySelector("strong");/** @type {string} */info.style.visibility="hidden";/** @type {string} */var includes=document.cookie.split(SERVER_DATA.battleZoneId+"-"+SERVER_DATA.leftBattleId+"=")[1];/** @type {!Array<string>} */savedStats=(includes?includes.split(";")[0]:"0|0").split("|");savedStats[2]=info.textContent.replace(/,/g,"");elem.insertAdjacentHTML("beforeEnd",'<div id="personal_stats"><q>'+resolve(savedStats[0])+"</q> | <q>"+resolve(savedStats[1])+"</q> | <q>"+resolve(savedStats[2])+"</q></div>");personal_stats=expect("#personal_stats q");}),expect("#total_damage .resistance",inventoryService=>{return inventoryService.remove();}),toTop){clearInterval(globalSleepInterval);expect("#pvp",types=>{return types.insertAdjacentHTML("beforeEnd",(SERVER_DATA.onAirforceBattlefield?"":'<label id="epicPercent"><input type="checkbox">Epic progress <span></span>%</label>')+(data.topLists?"":'<div id="topLists"></div>')+(SERVER_DATA.isCivilWar?"":'<div id="travelButtons"><span><img src="//www.erepublik.net/images/flags_png/L/'+_this.info.countries[SERVER_DATA.leftBattleId].permalink+'.png">Join</span><span>Join <img src="//www.erepublik.net/images/flags_png/L/'+_this.info.countries[SERVER_DATA.rightBattleId].permalink+'.png"></span></div>'));});expect("#region_name_link",selfContext=>{return selfContext.textContent+=(SERVER_DATA.isResistance?" RW":"")+" R"+SERVER_DATA.zoneId;});var renderInterval;/** @type {(Element|null)} */var p=document.querySelector("#epicPercent span");expect("#epicPercent input",e=>{return e.addEventListener("change",function(){if(this.checked){render();/** @type {number} */renderInterval=setInterval(render,65e3);}else{clearInterval(renderInterval);}});});if(!SERVER_DATA.isCivilWar){expect("#travelButtons span",function(e,canCreateDiscussions){e.addEventListener("click",()=>{return value(ms,SERVER_DATA.battleZoneId,canCreateDiscussions?SERVER_DATA.rightBattleId:SERVER_DATA.leftBattleId);});if(!(SERVER_DATA.spectatorOnly||canCreateDiscussions)){/** @type {string} */e.style.visibility="hidden";}});expect("#trigger_campaignMap",e=>{return e.addEventListener("click",()=>{return document.getElementById("travelButtons").style.zIndex="99";});});}var refreshBtn=angular.element("#battleFooterbattleSetup").scope();var wasRefreshHidden=refreshBtn.openPopup;/**
                         * @return {undefined}
                         */refreshBtn.openPopup=()=>{};setTimeout(()=>{return refreshBtn.openPopup=wasRefreshHidden;},2e3);if(!data.topLists){expect(".battle_heroes",builderID=>{return builderID.style.display="none";});request();setInterval(function(){if(SERVER_DATA.points.attacker<1800&&SERVER_DATA.points.defender<1800){request();}},3e4);}afterRequestCallbacks.push(function(canCreateDiscussions,url){if(url.includes("battle-stats")){var n=canCreateDiscussions.battle_zone_situation[SERVER_DATA.battleZoneId];if(n){/** @type {string} */document.title=(n>1?"EPIC BATTLE":"FULL SCALE")+" DETECTED";}}});}}(),data.mercFF||SERVER_DATA.isCivilWar||!toTop||link(),isZordacz&&SERVER_DATA.webDeployEnabled){/** @type {number} */var chat_retry=setInterval(function(){if(SERVER_DATA.sessionValidation){clearInterval(chat_retry);}},1e3);}}else{if(/donate-|accounts|citizen-friends/.test(location.href)&&!data.improveProfile){renderProfilePageSidepanelImprovements();}else{if(le){done("/citizen-profile-json-personal/",function(){if(!window.hasRunProfileStuff){/** @type {number} */window.hasRunProfileStuff=1;if(!data.improveProfile){renderProfilePageSidepanelImprovements();}if(!data.influenceCalculator){(function(){/**
                             * @return {undefined}
                             */function init(){expectation.forEach(function(dom,militaryType){dom.querySelectorAll("span").forEach(inventoryService=>{return inventoryService.remove();});var militaryData=bd.military.militaryData[militaryType?"aircraft":"ground"];/** @type {number} */var delta_length_z=+dom.getElementsByTagName("select")[0].value;var naturalEnemy=document.getElementById("InfCalc_NE").checked;const appliedStrength=militaryData.temporaryStrength||0;const appliedRank=militaryData.rankNumber;const damageNoHit=calculateNoHitDamage(appliedStrength,appliedRank);/** @type {number} */var volume=damageNoHit*(1+delta_length_z/5)*(militaryType?1:1+parseInt(document.getElementById("InfCalc_legend").value)/100)*(1+parseInt(document.getElementById("InfCalc_booster").value)/100);/** @type {number} */var force_z=1e6/volume;dom.insertAdjacentHTML("beforeEnd","<span>Influence</span><span>"+format(parseInt(volume*document.getElementById("InfCalc_hits").value*(naturalEnemy?1.1:1)),1)+"</span><span>Hits to next rank</span><span>"+(militaryData.nextRankAt-militaryData.points>0?format(Math.ceil(10*(militaryData.nextRankAt-militaryData.points)/volume/(document.getElementById("InfCalc_WarStash").checked?1.1:1)),1):"\u221e")+'</span><span>Cost cc/M</span><span title="Includes food">'+format(((delta_length_z?data.infCalc[militaryType?23:2][Math.min(delta_length_z,7)]/delta_length_z*force_z:0)+force_z*data.infCalc.cheapestFood*10)/(naturalEnemy?1.1:1),2)+"</span>");});}append("#infCalc{font-size:11px;color:#666;margin:0 0 5px;width:577px;text-align:center}#InfCalc_hits,#InfCalc_legend,#InfCalc_booster{padding:4px;text-align:center;width:35px;font-size:11px;margin:0 5px}#infCalc label{margin:0 5px}#InfCalc_NE,#InfCalc_WarStash{margin-left:5px;position:relative;top:2px;text-align:center}.infCalcResults{line-height:0}.infCalcResults span{width:100%;text-align:center;display:block;font:700 12px/15px Arial;color:#595959}.infCalcResults span:nth-child(even){font:400 11px/14px Arial;color:#81827f}.infCalcResults select{margin:2px;font-size:11px;padding:2px 4px;text-align:center;height:23px}.citizen_military_box_wide{width:293px;margin:0 1px 2px}.citizen_military_box_wide .rank_box{right:0}.citizen_military_box_wide .rank_icon{left:7px}.citizen_military_box_wide .regular_rank_img{margin-left:7px}.citizen_military_box_wide .rank_name_holder{width:230px;left:88px}.citizen_military_box .military_box_info{width:85px}.citizen_military_box_wide .top_area{padding:0 15px 0 77px}");var bd=angular.element("#str_progress").scope().data;const{rankNumber}=bd.military.militaryData;let legendBonus=0;if(rankNumber>70){legendBonus=rankNumber-70+1;}expect(".citizen_military_box_wide",table=>{return table.insertAdjacentHTML("afterEnd",'<div class="citizen_military_box infCalcResults"><select></select></div>');})[1].nextSibling.insertAdjacentHTML("afterEnd",'<div id="infCalc" class="citizen_military"><label>Hits <input type="text" id="InfCalc_hits" value="1"></label><label>Natural Enemy <input type="checkbox" id="InfCalc_NE"></label><label title="+10% rank points">War Stash <input type="checkbox" id="InfCalc_WarStash" '+(bd.activePacks.war_stash?"checked":"")+'></label><label>Damage Booster<input type="text" id="InfCalc_booster" value="0%"></label><label>Legend Bonus<input type="text" id="InfCalc_legend" value="'+legendBonus*10+'%"></label></div>');expect(".citizen_military_box",year_selector_service=>{return year_selector_service.style="margin:0 1px 2px 1px;width:85px";});data.infCalc=data.infCalc||{1:{},2:{},23:{},cheapestFood:0,selWep:{0:7},noData:1};var expectation=expect(".infCalcResults",(t,dim)=>{return t.querySelectorAll("select").forEach(function(b){/** @type {string} */var name="";/** @type {number} */var i=0;for(;i<8;i++){/** @type {string} */name=name+(!i||data.infCalc.noData||data.infCalc[dim?23:2][Math.min(i,7)]?'<option value="'+(i<7?i:10)+'" '+(data.infCalc.selWep[dim]==i?"selected":"")+">Q"+i+"</option>":"");}/** @type {string} */b.innerHTML=name;b.addEventListener("change",function(){/** @type {number} */data.infCalc.selWep[dim]=Math.min(this.value,7);saveStuffDataToStorage();init();});});});init();expect("#InfCalc_hits,#InfCalc_legend,#InfCalc_booster",p=>{return p.addEventListener("keyup",init);});expect("#InfCalc_NE,#InfCalc_WarStash",sound=>{return sound.addEventListener("change",init);});if(data.infCalc.date!=now){u(35,function(){/** @type {number} */var removeClass=1;for(;removeClass<4;removeClass++){/** @type {number} */var i=1;for(;i<8;i++){/** @type {number} */data.infCalc[removeClass<3?removeClass:23][i]=((redLookupTable[35][restart(removeClass<3?removeClass:23)]["q"+i]||[])[1]||{}).gross/(1==removeClass?2*(i<7?i:10):1);}}/** @type {number} */data.infCalc.cheapestFood=Math.min(999,...Object.values(data.infCalc[1]));data.infCalc.date=now;/** @type {number} */data.infCalc.noData=0;saveStuffDataToStorage();init();});}})();}}});}else{if(location.href.includes("economy/marketplace")){if(location.href.includes("/offer")){if(!data.improveMarketplace){init();}if(!data.autofillMarket){run();}}else{done("economy/marketplace",function(){if(!data.improveMarketplace){init();}if(!data.autofillMarket){run();}});}}else{if(location.href.includes("economy/exchange-market")){console.log("EXCHANGE MARKET");if(!data.autofillGold){(function(){/**
                             * @return {undefined}
                             */function run(){expect("button[data-currency=GOLD]",function(target){var input=target.previousElementSibling.previousElementSibling;/** @type {number} */input.value=Math.min(target.dataset.max,10,Math.floor(100*params.currencyAmount/target.dataset.price)/100);input.dispatchEvent(new Event("input"));});}append(".exchange_offers td.ex_citizen{width:200px}.exchange_offers td.ex_buy button{max-width:unset}");done("exchange/retrieve",run);run();})();}insertContent(".e_cash","monetary-market/gold/statistics");}else{if(location.href.includes("economy/myCompanies")){if(!data.companyManager){(function(){append("#CompanyManager{float:right;display:none}#CompanyManager strong{position:relative;bottom:8px;right:5px;font-size:12px}#CompanyManager span{cursor:pointer;border-radius:3px}#CompanyManager span:hover{opacity:.5}#CompanyManager img{height:30px}#companies_bottom{position:sticky;bottom:0}");expect(".area h4",types=>{return types.insertAdjacentHTML("beforeEnd",'<div id="CompanyManager"><strong>Work as Manager</strong></div>');});/** @type {(Element|null)} */var container=document.getElementById("CompanyManager");var expectation=expect(".listing.companies:not(.disabled):not(.cannotWorkAsManager):not(.cannotWorkAsManager-location)",function(fieldsetLabel){var n=fieldsetLabel.querySelector(".area_pic > img");var srcAngle=n.getAttribute("src");if(!container.querySelector('img[src="'+srcAngle+'"]')){container.insertAdjacentHTML("beforeEnd",'<span><img src="'+srcAngle+'" title="'+n.title+'"></span>');}});if(container.querySelector("span")){/** @type {string} */container.style.display="block";expect("#help_manage",inventoryService=>{return inventoryService.remove();});}expect("#CompanyManager span",e=>{return e.addEventListener("click",function(mutation){window.pageDetails.recoverable_health.value=food_remaining;var i=expect(".owner_work.active").length;expectation.forEach(function(pxPhysicalNode){if(pxPhysicalNode.querySelector('.area_pic > img[src="'+mutation.target.getAttribute("src")+'"]')&&i<Math.floor(globalNS.userInfo.wellness/10)){pxPhysicalNode.querySelectorAll(".owner_work").forEach(function(divChatButton){if(!divChatButton.classList.contains("active")){i++;divChatButton.classList.add("active");}});}});expectation.forEach(e=>{return calculateProduction(e,true);});checkHealth();checkTax();calculateTotals();warnForCritical();});});expect(".list_group",$button=>{return $button.style.boxShadow="none";});})();}if(!data.showBestJobOffer){test("/"+side+"/economy/job-market-json/"+params.countryLocationId+"/1/desc",function(options){if(options.jobs&&options.jobs[0]){options.jobs.sort((_pointM,_pointB)=>{return _pointB.netSalary-_pointM.netSalary;});expect(".employer.fill h4",types=>{return types.insertAdjacentHTML("beforeEnd",'<a href="/'+side+"/economy/job-market/"+params.countryLocationId+'" style="position:absolute;right:21px;">Highest local offer: net '+options.jobs[0].netSalary+"cc ("+(options.jobs[0].salaryLimit>0?"max  "+resolve(options.jobs[0].salaryLimit)+"cc/day":"no overtime limit")+")</a>");});}});}if(hasLicense()&&(handlebars||Handlebars)){(function(){/**
                               * @param {string} name
                               * @return {undefined}
                               */function fixRepoAlerts(name){if(Object.keys(readyPorts).length+1==stream.length||name){/** @type {!Array} */var queue=[];/** @type {number} */var cursorAt=0;/** @type {number} */var outerStepNumber=0;stream.forEach(function(t){/** @type {number} */var port=+t.id.split("_")[1];/** @type {!Array} */var arg=[];t.querySelectorAll(".WaMsetupInput").forEach(function(child){var c=name?+child.value:child.checked;if(c){/** @type {number} */var elem=+child.parentElement.id.split("_")[1];if(name){queue.push([elem,c]);outerStepNumber=outerStepNumber+c;}else{arg.push(elem);}cursorAt++;}});if(!name&&arg.length){queue.push([readyPorts[port],arg]);}});expect("#WaMsetup span",result=>{return result.textContent=name?"Assigned "+outerStepNumber+" employees to "+cursorAt+" companies":"Selected "+cursorAt+" companies in "+queue.length+" holding(s)";});expect("#WaMsetup a",selfContext=>{return selfContext.textContent=cursorAt==value.length?"Deselect all":"Select all";});if(name){/** @type {!Array} */data.employeeCompanies=queue;}else{/** @type {string} */localStorage.wamCompaniesLeftToday=JSON.stringify(data.wamCompanies=queue);}saveStuffDataToStorage();}}append("#WaMsetup{margin:0 0 -20px;font:200 11px/14px Arial}#WaMsetup span{margin:9px;display:inline-block}input.WaMsetupInput{position:absolute;margin:25px 0}#WaMsetup a{margin:0 5px;padding:5px}");expect(".area h4",table=>{return table.insertAdjacentHTML("afterEnd",'<div id="WaMsetup"><span></span><a class="std_global_btn">AutoFighter WaM Setup</a><a class="std_global_btn">AutoFighter Employee Setup</a></div>');});var value;var stream=expect(".companies_group");var readyPorts={};var expectation=expect("#WaMsetup a",(table,isMobile)=>{return table.addEventListener("click",function(){if(!isMobile){stream.forEach(function(callingModule){/** @type {number} */var port=+callingModule.id.split("_")[1];if(port){callback("/"+side+"/main/travelData",{_token:csrfToken,holdingId:port},function(server){readyPorts[port]=server.preselectRegionId;fixRepoAlerts(isMobile);});}});}table.insertAdjacentHTML("afterEnd",'<a class="std_global_btn">Select all</a>');table.nextSibling.addEventListener("click",function(){/** @type {boolean} */var c="Select all"==this.textContent;/** @type {string} */this.textContent=c?"Deselect all":"Select all";if(isMobile){value.forEach(el=>{return el.value=c?el.max:0;});}else{value.forEach(node1=>{return node1.checked=c;});}fixRepoAlerts(isMobile);});expect(isMobile?".employees_selector":".owner_work",function(type){/** @type {number} */var t=+type.parentElement.parentElement.querySelector(".employees_selector").dataset.employee_limit;type.parentElement.parentElement.insertAdjacentHTML("beforeEnd",'<input class="WaMsetupInput" style="-moz-appearance:'+(isMobile?"initial;width:30px;left:-35px;text-align:center":"checkbox;left:-30px")+'" type="'+(isMobile?"number":"checkbox")+'" '+(isMobile?'value="0" min="0" max="'+t+'"':"")+">");});value=expect(".WaMsetupInput");expect(".WaMsetupInput",xhr=>{return xhr.addEventListener(isMobile?"input":"click",()=>{return fixRepoAlerts(isMobile);});});expectation.forEach(inventoryService=>{return inventoryService.remove();});/** @type {!Array} */var list=[];if(isMobile){for(let e of errors){list.push(e);}}else{for(let moduleToTraverse of movies){list.push(...moduleToTraverse[1]);}}value.forEach(function(ctx){/** @type {number} */var value=+ctx.parentElement.id.split("_")[1];if(isMobile){for(let item of list){if(item[0]==value){ctx.value=item[1];}}}else{/** @type {boolean} */ctx.checked=list.includes(value);}});fixRepoAlerts(isMobile);});});})();}}else{if((location.href.includes("economy/inventory")||location.href.includes("main/inventory"))&&!data.improveInventory){(()=>{/**
                               * @return {undefined}
                               */function render(){$scope.inputs.quantity=stream[0].value;var e=$scope.settings.countries[$scope.inputs.selectedCountry].taxes[$scope.inputs.selectedIndustry];/** @type {number} */var price=$scope.inputs.pricePerUnit/((100+(e.valueAddedTax+($scope.inputs.selectedCountry!=params.country?e.importTax:0)))/100);/** @type {number} */var baseNumber=price*$scope.inputs.quantity;expect("#TaxPerUnit",dashboardPanel=>{return dashboardPanel.innerHTML=($scope.inputs.pricePerUnit-price).toFixed(4);});expect("#Net_unit",dashboardPanel=>{return dashboardPanel.innerHTML=price.toFixed(4);});expect("#Total_net",dashboardPanel=>{return dashboardPanel.innerHTML='<strong style="top:39px;left:478px">Total Net</strong>';});}append("#Total_net {width: 100px}#Total_netF,.Total_net,.offer_price{text-align:right}#Total_netF span,.Total_net span,.offer_price span{margin-right:1px;font-size:11px}#Total_net *{position:absolute}tfoot tr{background:#f7fcff}#totalFoodHP{float:right;margin:5px 30px 0;color:#656565}#inventory_overview #sell_offers table td:last-child{padding-left:0}#inventory_overview #sell_offers table .delete_offer{opacity:1}");data.goldPrice=data.goldPrice||{};if(data.goldPrice.date!=now){callback("/"+side+"/economy/exchange/retrieve/",{_token:csrfToken,page:1,currencyId:62},function(stickerInfo){/** @type {string} */data.goldPrice.price=JSON.stringify(stickerInfo).split("data-price='")[1].split("'")[0];data.goldPrice.date=now;saveStuffDataToStorage();});}var $scope=angular.element("#sell_offers").scope();var stream=expect(".offers_quantity input",inputElem=>{return inputElem.setAttribute("maxlength",9);});/** @type {!Array} */var path=[0,0];expect(".area.storage h4:first-child strong",function(where){where.insertAdjacentHTML("beforeEnd",' <q id="freeSpace"></q>');where.insertAdjacentHTML("afterEnd",'<span id="totalFoodHP"></span>');});afterRequestCallbacks.push(function(value,url){if(url.includes("myMarketOffers")&&(expect("#sell_offers th",function(e,topLeft){/** @type {string} */e.style.width=(topLeft?1==topLeft?80:2==topLeft?140:3==topLeft?60:132:70)+"px";if(4==topLeft){e.querySelectorAll("a").forEach(year_selector_service=>{return year_selector_service.style="left:10px;margin-right:20px;padding:0 10px";});}}),expect(".relative",function(elem,canCreateDiscussions){if(!canCreateDiscussions){elem.querySelectorAll("span.ng-binding").forEach(builderID=>{return builderID.style.display="none";});/** @type {string} */elem.style.left="35px";elem.querySelectorAll("small").forEach(function(elem){/** @type {string} */elem.style="text-align:right;top:30px;left:-50px";elem.insertAdjacentHTML("beforeEnd",'<br><span>Tax / unit: </span><span id="TaxPerUnit"></span><br><span>Net / unit: </span><span id="Net_unit"></span><br>');});}}),expect("#sell_offers table",types=>{return types.insertAdjacentHTML("beforeEnd",'<tfoot><tr><td colspan="3"><td id="Total_netF"></td><td colspan="2"></td></tr></tfoot>');}),expect(".offers_price",table=>{return table.insertAdjacentHTML("afterEnd",'<th id="Total_net"></th>');}),render()),/marketplaceActions|myMarketOffers/.test(url)){expect(".Total_net,.offer_price span",inventoryService=>{return inventoryService.remove();});/** @type {number} */var total=0;/** @type {number} */path[1]=0;expect("#marketOffers tr",function(result){var t=$scope.settings.countries[result.dataset.country_id].taxes[result.dataset.industry_id];/** @type {number} */var value=result.querySelector(".offer_price strong").textContent/((100+(t.valueAddedTax+(result.dataset.country_id!=params.country?t.importTax:0)))/100);/** @type {number} */var w=value*result.dataset.amount;total=total+w;result.querySelectorAll(".offer_price").forEach(function(where){where.insertAdjacentHTML("beforeEnd","<span><br>Net: "+value.toFixed(4)+" "+params.currency+"</span>");where.insertAdjacentHTML("afterEnd",'<td class="Total_net"><strong>'+resolve(w.toFixed(2))+"</strong> "+params.currency+"<br><span>"+resolve((w/data.goldPrice.price).toFixed(2))+" g</span></td>");});if(1==result.dataset.industry_id){path[1]+=result.dataset.amount*(result.dataset.quality<7?2*result.dataset.quality:20);}});/** @type {string} */document.getElementById("Total_netF").innerHTML="<strong>"+resolve(total.toFixed(2))+"</strong> "+params.currency+"<br><span>"+resolve((total/data.goldPrice.price).toFixed(2))+" g</span>";}});})();}else{if(location.href.includes("/article/")&&location.hash.includes("comment")){/** @type {boolean} */be=false;afterRequestCallbacks.push(function(canCreateDiscussions,url){if(url.includes("articleComments")&&!be){if(document.getElementById(location.hash.split("#")[1])){/** @type {string} */location.hash=location.hash;setTimeout(function(){/** @type {string} */location.hash=location.hash;},500);/** @type {boolean} */be=true;}else{expect(".load-more-comments",e=>{return e.click();});}}});}else{if(location.href.includes("economy/job-market")){done("job-market-json",function(){if(!document.getElementById("erepDE")){append("#erepDE{color:#83b70b;float:right;margin:0 70px 0 10px}#erepDE:hover{color:#fb7e3d}#erepDE span{color:#42a5f5}.netSalary{font-size:11px}.bestNet{color:#83b70b!important}.travelToMarket{position:absolute;top:10px;right:220px}");expect("#job_market h1",types=>{return types.insertAdjacentHTML("beforeEnd",'<a id="erepDE" href="//erepublik.tools/en/marketplace/jobs/0/offers">eRepublik<span>.tools</span></a>');});}expect(".netSalary,.travelToMarket",inventoryService=>{return inventoryService.remove();});expect(".bestNet",focusedObj=>{return focusedObj.classList.remove("bestNet");});/** @type {!Array} */var MINSPANS=[0];expect(".salary_sorted tr",function(elem){var self=angular.element(elem).scope().job;elem.getElementsByClassName("jm_salary")[0].insertAdjacentHTML("beforeEnd",'<span class="stprice netSalary"><br>'+(self.salaryLimit>0?"Max  "+resolve(self.salaryLimit)+"cc/day":"No overtime limit")+"</span>");if(self.netSalary>MINSPANS[0]){/** @type {!Array} */MINSPANS=[self.netSalary,elem];}});if(MINSPANS[1]){MINSPANS[1].querySelector(".jm_net_salary").classList.add("bestNet");}var dataBackup=angular.element("#job_market").scope();if(!dataBackup.data.isFromThisCountry){_("#job_market h1",dataBackup.settings.currentCountryId);}});}else{if(location.href.includes("tokens-market")){insertContent("#marketplace","game-token/statistics/price");if(!data.autofillMarket){done("economy/gameTokensMarketAjax",function(){expect(".quantity_button.maximum",e=>{return e.click();});});}}}}}}}}}}}}}var be;if(!(chans||data.playerTooltip)){(function(){/**
               * @param {string} name
               * @param {number} bool
               * @return {?}
               */function require(name,bool){return'<span style="background:'+(bool?"#83B70B":"red")+';padding:0 2px;border-radius:1px;font-weight:700;margin:0 1px">'+name+"</span>";}/**
               * @param {!Object} scope
               * @param {string} version
               * @return {?}
               */function locationInfo(scope,version){var prev=scope.location;var p=prev[version?"residenceCountry":"citizenshipCountry"];/** @type {string} */var micropost=p.name+(version?", "+prev.residenceRegion.name:"");return'<br><img src="//www.erepublik.net/images/flags_png/S/'+p.permalink+'.png">'+(version&&micropost.length>44?micropost.substring(0,42)+"\u2026":micropost)+(version?'<span style="font-family:Icons;color:'+(scope.city.residenceCityId?scope.city.residenceCity.region_id==prev.residenceRegion.id?"#83B70B":"#FB7E3D":"#009cff")+'">&nbsp;&nbsp;\ue811</span>':"");}/**
               * @param {string} str
               * @return {?}
               */function toArray(str){return'<div style="background:#83B70B;padding:0 2px;border-radius:1px;color:#fff;margin:0 0 2px;font-weight:700;width:19px">'+str+"</div>";}/**
               * @param {!Object} citizenProfile
               * @param {!Object} citizenHovercard
               * @param {number} index
               * @return {?}
               */function hovercardMilitaryInfo(citizenProfile,citizenHovercard,index){var entry=citizenProfile.military.militaryData[index?"ground":"aircraft"];var fighterInfo=citizenHovercard.fighterInfo;return'<div><img src="'+entry.icon+'"><div><isZordacz style="width:83%;background:linear-gradient(to right,#009cff 0%,#009cff '+entry.progress+"%,#000 "+(entry.progress+0.1)+'%,#000 100%);display:block;margin:0 0 -15px 30px">'+(index&&entry.rankNumber>69?"Legend"+entry.name.split("Battalion")[1]:entry.name)+'<span style=""></span></isZordacz><br><brown>'+(citizenProfile.citizen.is_organization?"":index?"Q7 hit: "+resolve(fighterInfo.military.damagePerHit||"")+(fighterInfo.military.damagePerHitLegend>0?" (TP "+resolve(fighterInfo.military.damagePerHitLegend||"")+")":""):"Q0 hit: "+resolve(fighterInfo.aviation.damagePerHitNoWeapon||""))+"</brown></div></div>";}/**
               * @param {!Object} item
               * @param {?} name
               * @param {number} val
               * @return {?}
               */function process(item,name,val){var state=val?item.partyData:item.military.militaryUnit;return"<div>"+(state?'<img src="'+state.avatar+'" style="background:#fff">':"")+"<div><isZordacz>"+(val?item.isPresident?"Country President":item.title.country?item.title.country:item.isCongressman?"Congressman":item.isPartyPresident?"Party President":state?"Member":"No political activity":state&&state.leader_id==name?"Commander":!state||state.second_commander_1!=name&&state.second_commander_2!=name?state&&JSON.stringify(state.leaders).includes(name)?"Captain":state?"Soldier":"":"Second Commander")+"</isZordacz><br><brown>"+(state?state.name:"No "+(val?"political party":"military unit"))+"</brown></div></div>";}/**
               * @param {!Object} citizenData
               * @param {?} playerId
               * @param {!Object} eventData
               * @param {?} callback
               * @return {undefined}
               */function updateTooltip(citizenData,playerId,eventData,callback){const{citizenProfile:self,citizenHovercard}=citizenData;console.log({playerId,self,citizenHovercard});/** @type {string} */var uriToAdd="";$(self.achievements,function(canCreateDiscussions,that){uriToAdd=uriToAdd+(/hardworker|supersoldier/.test(that.img)?"":'<div style="width:23px;display:inline-block;text-shadow:none"><img src="//www.erepublik.net/images/achievements/icon_'+that.img+(that.count?"_on":"_off")+'.gif" style="width:25px;margin:0 0 -5px 0"><span style="float:left;width:25px">'+(that.count>9999?Math.floor(that.count/1e3)+"k":that.count)+"</span></div>");});var opts=self.citizen;var micropost=opts.name.toString();var settings=self.activePacks;/** @type {number} */var g=self.citizenAttributes.experience_points%5e3/5e3*100;/** @type {string} */var m=opts.level>69&&opts.nextLevelXp-self.citizenAttributes.experience_points<500?"#FB7E3D":"#83B70B";/** @type {string} */element.innerHTML=eventData.orgTitle="\n                  <div id=\"eRStooltip\">\n                      <div style=\"background:rgb(30,30,30);height:84px\">\n                          <div style=\"float:left;width:84px;height:84px;position:relative\">\n                             <img src=\"".concat(opts.avatar,"\" style=\"width: 100%; height: 100%; margin:0 2px 0 0;background:#fff;border-radius:5px 0 0 0\">\n                             ").concat(window.isDonator(playerId)&&window.createBorderElementBasedOnDonatorLevel(playerId).outerHTML||"","\n                          </div>\n                         \n                          <isZordacz style=\"background:linear-gradient(to right,").concat(m," 0%,").concat(m," ").concat(g,"%,rgb(80,80,80) ").concat(g+0.1,"%,rgb(80,80,80) 100%)\">").concat(citizenHovercard.level,"</isZordacz>\n                          <isZordacz").concat(self.isDictator?' style="background:rgb(204,60,0)"':"",">\n                              ").concat(micropost.length<22?micropost:micropost.substring(0,20)+"\u2026","\n                          </isZordacz>\n                          ").concat(opts.onlineStatus?'<span style="background:#83B70B;border-radius:10px;height:12px;width:12px;display:inline-block;margin:0 5px -1px;border:1px solid;box-shadow:0 0 3px"></span>':"","\n                          <br>").concat(opts.is_organization?require("Organization",1):"","\n                          ").concat(isFriend(citizenHovercard)?require("Friend",1):"","\n                          ").concat(opts.is_alive?"":require("Dead"),"\n                          ").concat("Permanently"==opts.banStatus.type?require("Permaban"):opts.banStatus.type?require("Tempban"):"","\n                          ").concat(data.contributors&&data.contributors.includes(+playerId)?require("Stuff++ contributor",1):"","\n                          ").concat(self.isModerator?require("Mod"):"","\n                          <br><brown>").concat(opts.is_organization?"Created at: "+opts.created_at:"eR birthday: "+citizenHovercard.bornOn,"</brown>\n                          ").concat(locationInfo(self)).concat(locationInfo(self,1),"\n                          ").concat(hovercardStrength(self,citizenHovercard,resolve),"\n                          ").concat(hovercardDivision(self,citizenHovercard),"\n                      </div>\n                      <div style=\"position:absolute;top:2px;right:5px;text-align:center;width:20px\">\n                          ").concat(settings.power_pack?toArray("PP"):"","\n                          ").concat(settings.infantry_kit?toArray("IK"):"","\n                          ").concat(settings.division_switch_pack?toArray("MP"):"","\n                          ").concat(isZordacz&&data.l[opts.id]?toArray("AF"):"","\n                      </div>\n                      <div style=\"background:rgb(50,50,50);padding:0 5px;height:63px\">\n                          <div>\n                              ").concat(hovercardMilitaryInfo(self,citizenHovercard,1),"\n                              ").concat(hovercardMilitaryInfo(self,citizenHovercard),"\n                          </div>\n                          <div>\n                              ").concat(process(self,playerId,1),"\n                              ").concat(process(self,playerId),"\n                          </div>\n                      </div>\n                      <div style=\"height:47px;background:#fff;color:#5a5a5a;border-radius:0 0 5px 5px;text-align:center;font:9px/14px Arial\">").concat(uriToAdd,"</div>\n                  </div>");callback();}/**
               * @return {undefined}
               */function cb(){expect('#content a[href*="zen/pro"]:not(.eRStooltipAdded)',function(item){item.classList.add("eRStooltipAdded");update(item,"ns",function(prop){var _takingTooLongTimeout;var key=item.href.split("profile/")[1];return _this[key]?updateTooltip(_this[key],key,item,prop):_takingTooLongTimeout=setTimeout(()=>{return test("/"+side+"/main/citizen-profile-json/"+key,function(citizenProfile){test("/".concat(side,"/main/citizen-hovercard/").concat(key),citizenHovercard=>{_this[key]={citizenProfile,citizenHovercard};updateTooltip(_this[key],key,item,prop);});});},300),item.addEventListener("mouseleave",()=>{return clearTimeout(_takingTooLongTimeout);}),item.orgTitle||"Loading data...";});});}append(".citizen_activity a,.pic.tipsyElement a,.user-cmnt-avatar a{display:block}#eRStooltip{color:#fff;width:400px;font:11px/15px Arial;text-shadow:0 0 2px #000;text-align:left;margin:-7px;border:2px solid #000;border-radius:6px;box-shadow:0 0 5px #000}#eRStooltip>div>isZordacz{font:700 17px/20px Tahoma;border-radius:1px;padding:1px 2px;margin:0 1px 2px;display:inline-block}#eRStooltip>div>img:not(:first-child){margin:0 2px -4px 1px;width:14px}#eRStooltip>div:not(:last-child)>div{width:50%;float:left}#eRStooltip>div>div>div{height:30px;width:100%;float:left;margin:1px 0;overflow:hidden}#eRStooltip>div>div>div>img{width:30px;height:30px;float:left;margin:0 5px 0 0}#eRStooltip brown{color:#c3bb8c}");/** @type {string} */angular.element("body").injector().get("hovercardDirective")[0].restrict="E";expect("[hovercard]",rowElement=>{return angular.element(rowElement).scope().getCitizenData=()=>{};});expect("hovercard-details",inventoryService=>{return inventoryService.remove();});var _this={};cb();if(destinationUnitName||ms||location.href.includes("/article/")){setInterval(cb,1e3);}else{afterRequestCallbacks.push(()=>{return setTimeout(cb,500);});}})();}expect('#menu5 li a[href*="elections"]',function(sourceDest){/** @type {number} */var t=+document.querySelector(".date").textContent.split(" ")[1];/** @type {string} */sourceDest.href="/"+side+"/main/"+(t>4&&t<15?"presidential":t>14&&t<25?"party":"congress")+"-elections";});}}}};}();function delay(ms){return new Promise(resolve=>setTimeout(resolve,ms));}function isFriend(citizenHovercard){for(let entry of citizenHovercard.interactionButtons){if(entry.type==="removeFriend"){return true;}}}function hovercardStrength(self,citizenHovercard,numberFormatter){const img="<img style=\"height: 10px; width: 10px;\" src=\"//www.erepublik.net/images/modules/citizenprofile/strength_ico.png\"/>";const strength=citizenHovercard.fighterInfo.military.strength.toFixed(2);return"<div id=\"strength-tooltip\" style='margin-top: -15px; margin-left: 190px; display: flex;justify-content: flex-end;align-items: center;gap: 3px;'>\n".concat(img,"\n").concat(numberFormatter(strength),"\n</div>");}function hovercardDivision(self,citizenHovercard){const divisionNumber=citizenHovercard.fighterInfo.military.division;return"<div id=\"strength-tooltip\" style='margin-top: -30px; margin-left: 190px; display: flex;justify-content: flex-end;align-items: center;gap: 3px;'>\nDiv: \n".concat(divisionNumber,"\n</div>");}function hookUpFeedCommentsScroll(){const style=document.createElement("style");// language=CSS
style.textContent="\n      .postContent .commentsWrapper {\n          max-height: 400px;\n          overflow-y: auto;\n          overflow-x: hidden;\n      }\n    ";document.head.appendChild(style);}function hookUpPowerSpin(){const STORAGE_KEYS={MAX_MONEY:"as-max-money-per-spin",STOP_AT_GOLD_JACKPOT:"as-stop-at-gold",SPIN_ANIMATION_IN_SECONDS:"as-spin-animation-in-seconds"};const powerSpinButtonElement=document.getElementById("launch_wof");if(!powerSpinButtonElement){return;}let stoppingTheWheel=false;let currentJackpotCount=0;powerSpinButtonElement.addEventListener("click",function(){try{createForm();hookUpEvents();createPrizeLog();overrideShowMultiprize();overrideTimelineMax();overrideSpinFunction();overrideMultiSpinFunction();}catch(e){console.warn(e);}});function overrideShowMultiprize(){erepublik.wheel_of_fortune.showMultiPrize=function(){};}function overrideTimelineMax(){let originalFunction=TimelineMax.prototype.to;const spinAnimationInSecondsElement=document.getElementById("as-spin-animation-in-seconds");TimelineMax.prototype.to=function(context,delay,config){if(config.ease===Expo.easeOut){delay=spinAnimationInSecondsElement.value||1;}return originalFunction.apply(this,[context,delay,config]);};}function overrideMultiSpinFunction(){const old=erepublik.wheel_of_fortune.multispin;erepublik.wheel_of_fortune.multispin=function(numPrizes,always3,spinHttpResponse,multiSpin){if(!spinHttpResponse.alreadyHandled){spinHttpResponse.alreadyHandled=true;currentJackpotCount=spinHttpResponse.jackpot;spinHttpResponse.prizes.forEach((reward,index)=>{const{tooltip,icon}=findRewardById(reward.index);const cost=spinHttpResponse.cost+100*index;logPrize(cost,tooltip,icon);});}old.apply(erepublik.wheel_of_fortune,arguments);};function findRewardById(id){return window.global_wof_build_data.prizes.prizes[id];}}function overrideSpinFunction(){const old=erepublik.wheel_of_fortune.spin;erepublik.wheel_of_fortune.spin=function(numPrizes,always3,spinHttpResponse,multiSpin){// For now do nothing.
// The game started calling both multispin and spin functions for a single spin.
// We are now handling logic in a multispin function.
old.apply(erepublik.wheel_of_fortune,arguments);};}function createForm(){const wheelOfFortuneRoot=document.getElementById("wheelOfFortune");if(!wheelOfFortuneRoot){throw Error("No wheel of fortune");}const formElementId="as-form-container";if(document.getElementById(formElementId)){throw Error("Form already exists");}// --------------------
const form="\n      <style>\n        #as-form-container {\n          position: absolute;\n          top: 280px;\n          right: -130px;\n          background-color: #fff;\n          padding: 8px;\n        }\n        \n        label.as-label {\n           display: flex;\n           flex-direction: column;\n           align-items: flex-end;\n           margin-bottom: 8px;\n        }\n        \n        label.as-label.jackpot {\n          flex-direction: row;\n        }\n        \n        label.as-label.jackpot input {\n          margin-left: 10px;\n        }\n        \n        .as-input {\n          max-width: 80px;\n          text-align: right;\n        }\n        \n        .as-buttons {\n          display: flex;\n          justify-content: flex-end;\n        }\n        \n        button.as-hidden {\n          display: none;\n        }\n        \n        #as-spin {\n          background: #94aaff;\n          cursor: pointer;\n        }\n        \n        #as-spin:hover {\n          background: #768ef8;\n        }\n        \n      </style>\n      <div>\n          <label class=\"as-label\">\n              Max Money Per Spin\n              <input id=\"as-max-money\" class=\"as-input\" type=\"text\" placeholder=\"e.g. 2500\">\n          </label>\n          <label class=\"as-label jackpot\">\n              Stop at gold jackpot\n              <input id=\"as-stop-at-gold\" type=\"checkbox\" checked>\n          </label>\n           <label class=\"as-label\">\n              Spin animation\n              <input id=\"as-spin-animation-in-seconds\" class=\"as-input\" type=\"text\" placeholder=\"in seconds\">\n          </label>\n          \n          <div class=\"as-buttons\">\n            <button id=\"as-spin\">\n                Spin\n            </button>\n            <button id=\"as-cancel\" class=\"as-hidden\">\n                Cancel\n            </button>\n          </div>\n      </div>\n    ";const containerElement=document.createElement("div");containerElement.id=formElementId;containerElement.innerHTML=form;wheelOfFortuneRoot.appendChild(containerElement);const maxMoneyInputElement=document.getElementById("as-max-money");const stopAtGoldCheckboxElement=document.getElementById("as-stop-at-gold");const spinAnimationInSecondsElement=document.getElementById("as-spin-animation-in-seconds");const storedMaxMoney=localStorage.getItem(STORAGE_KEYS.MAX_MONEY);if(storedMaxMoney){maxMoneyInputElement.value=storedMaxMoney;}const storedStopAtGold=localStorage.getItem(STORAGE_KEYS.STOP_AT_GOLD_JACKPOT);if(!storedStopAtGold){stopAtGoldCheckboxElement.checked=true;}else{stopAtGoldCheckboxElement.checked=storedStopAtGold==="true";}const spinAnimationInSeconds=localStorage.getItem(STORAGE_KEYS.SPIN_ANIMATION_IN_SECONDS);spinAnimationInSecondsElement.value=spinAnimationInSeconds||1;}function hookUpEvents(){const maxMoneyInputElement=document.getElementById("as-max-money");const stopAtGoldCheckboxElement=document.getElementById("as-stop-at-gold");const spinAnimationInSecondsElement=document.getElementById("as-spin-animation-in-seconds");const spinButtonElement=document.getElementById("as-spin");const cancelButtonElement=document.getElementById("as-cancel");const triggerWof1xButtonElement=document.querySelector(".wof_btn.left_btn");if(!(maxMoneyInputElement||stopAtGoldCheckboxElement||spinButtonElement||cancelButtonElement||triggerWof1xButtonElement)){console.warn("One element is not here",{maxMoneyInputElement,stopAtGoldCheckboxElement,spinButtonElement,cancelButtonElement,triggerWof1xButtonElement});throw Error("One element is not here");}maxMoneyInputElement.addEventListener("change",event=>{localStorage.setItem(STORAGE_KEYS.MAX_MONEY,event.target.value);});stopAtGoldCheckboxElement.addEventListener("change",event=>{localStorage.setItem(STORAGE_KEYS.STOP_AT_GOLD_JACKPOT,event.target.checked);});spinAnimationInSecondsElement.addEventListener("change",event=>{console.log("change",event.target.value);localStorage.setItem(STORAGE_KEYS.SPIN_ANIMATION_IN_SECONDS,event.target.value);});spinButtonElement.addEventListener("click",()=>{const maxMoneyPerSpin=Math.floor(Number(maxMoneyInputElement.value));if(Number.isNaN(maxMoneyPerSpin)||maxMoneyPerSpin<=500){console.warn("maxMoneyPerSpin must be at least 500");return;}const shouldStopAtGoldJackpot=stopAtGoldCheckboxElement.checked;console.log("maxMoneyPerSpin = ".concat(maxMoneyPerSpin,", shouldStopAtGoldJackpot = ").concat(shouldStopAtGoldJackpot));spinTheWheel(maxMoneyPerSpin,shouldStopAtGoldJackpot,Number(spinAnimationInSecondsElement.value));});cancelButtonElement.addEventListener("click",()=>{console.log("Flagging to stop the wheel");stoppingTheWheel=true;});function spinTheWheel(maxCost,shouldStopAtGoldJackpot,baseDelayInSeconds){console.log("Starting the wheel");spinButtonElement.classList.add("as-hidden");cancelButtonElement.classList.remove("as-hidden");const currentCost=window.global_wof_build_data.cost;if(maxCost<=currentCost){console.log("Not spinning, because we've already reached the limit.");stopTheWheel();return;}if(baseDelayInSeconds<=0){console.log("Stopping the wheel, because spin animation must be more than 0s, but is: ",baseDelayInSeconds);stopTheWheel();return;}let previousJackpotCount=currentJackpotCount;function timeHandler(){const currentCost=window.global_wof_build_data.cost;let spinsRequiredCount=(maxCost-currentCost)/100;console.log({spinsRequiredCount,previousJackpotCount,currentJackpotCount});if(stoppingTheWheel){stopTheWheel();return;}if(shouldStopAtGoldJackpot&&currentJackpotCount===3&&previousJackpotCount<3){stopTheWheel();return;}previousJackpotCount=currentJackpotCount;const safetyMarginInSeconds=0.2;if(spinsRequiredCount){triggerWof1xButtonElement.click();setTimeout(timeHandler,baseDelayInSeconds*1000+safetyMarginInSeconds*1000);}else{stopTheWheel();}}timeHandler();}function stopTheWheel(){cancelButtonElement.classList.add("as-hidden");spinButtonElement.classList.remove("as-hidden");console.log("Stopping the wheel");stoppingTheWheel=false;}}function createPrizeLog(){const wheelOfFortuneRoot=document.getElementById("wheelOfFortune");if(!wheelOfFortuneRoot){throw Error("No wheel of fortune");}const containerElementId="as-power-log";if(document.getElementById(containerElementId)){throw Error("Power log already exists");}// --------------------
const innerHTML="\n      <style>\n        #as-power-log {\n          position: absolute;\n          top: 0;\n          right: -306px;\n          background-color: #fff;\n          padding: 8px;\n          width: 300px;\n          height: 260px;\n          z-index: -1;\n          display: flex;\n          flex-direction: column;\n          justify-content: space-between;\n        }\n        \n        #as-power-log-header {\n            font-weight: 600;\n            border-bottom: 1px solid black;\n            padding-bottom: 5px;\n        }\n        \n        #as-power-log-container {\n            overflow: auto;\n        }\n        .as-power-log-item {\n          display: flex;\n          align-items: center;\n        }\n        \n        .as-power-log-icon {\n          height: 24px;\n          margin: 0 4px;\n        }\n      </style>\n      <div id=\"as-power-log-header\">\n          Power Spin Log\n      </div>\n      <div id=\"as-power-log-container\">\n          \n      </div>\n    ";const containerElement=document.createElement("div");containerElement.id=containerElementId;containerElement.innerHTML=innerHTML;wheelOfFortuneRoot.appendChild(containerElement);}function logPrize(price,name,iconUrl){console.log("Logging prize: price = ".concat(price,", name = ").concat(name));const powerLogContainer=document.getElementById("as-power-log-container");if(!powerLogContainer){throw Error("Power log container not available");}const rewardElement=document.createElement("div");rewardElement.classList.add("as-power-log-item");const priceElement=document.createElement("span");priceElement.textContent="".concat(price,": ");rewardElement.appendChild(priceElement);const iconElement=document.createElement("img");iconElement.classList.add("as-power-log-icon");iconElement.src=iconUrl;rewardElement.appendChild(iconElement);const nameElement=document.createElement("span");nameElement.textContent=name;rewardElement.appendChild(nameElement);const shouldScrollBottom=powerLogContainer.scrollTop>=scrollTopMax();powerLogContainer.appendChild(rewardElement);if(shouldScrollBottom){powerLogContainer.scrollTop=powerLogContainer.scrollHeight;}function scrollTopMax(){const tolerance=1;// you can adjust this value to account for small inaccuracies
return powerLogContainer.scrollHeight-powerLogContainer.clientHeight-tolerance;}}}function hookUpDailyChallengeAutoCollect(){const dcButtonElement=document.getElementById("dailyMissionsPopupTrigger");if(!dcButtonElement){return;}dcButtonElement.addEventListener("click",function(){setTimeout(()=>{try{createButton();}catch(e){console.warn(e);}},300);});function createButton(){const BUTTON_ID="claimAllButton";const titleRootElement=document.querySelector("#dailyMissionsPopup > h2");if(!titleRootElement){throw Error("No title root element");}if(document.getElementById(BUTTON_ID)){console.log("Button is already created");return;}const claimAllButtonElement=document.createElement("a");claimAllButtonElement.id=BUTTON_ID;claimAllButtonElement.classList.add("std_global_btn","greenColor","smallSize");claimAllButtonElement.style.float="right";claimAllButtonElement.style.marginRight="16px";claimAllButtonElement.textContent="Claim All & Close";claimAllButtonElement.addEventListener("click",evt=>{evt.target.classList.add("disabled","loading");claimAllButtonClickHandler(1000);});titleRootElement.appendChild(claimAllButtonElement);function claimAllButtonClickHandler(timeToWaitInMs){var _claimButtonElements$;const claimButtonElements=document.querySelectorAll(".missionWrapper:not(.alreadyClaimed) a:not(.disabled).claimButton, .rewardWrapper:not(.claimed) .claimButton");if(!claimButtonElements.length){claimAllButtonElement.classList.remove("disabled","loading");console.log("No more challenges to claim. Closing challenges window.");const closeButtonElement=document.querySelector('#dailyMissionsPopup > a.close.closeButton[title="Close"]');closeButtonElement===null||closeButtonElement===void 0?void 0:closeButtonElement.click();return;}console.log("Challenges to claim: ".concat(claimButtonElements.length));(_claimButtonElements$=claimButtonElements[0])===null||_claimButtonElements$===void 0?void 0:_claimButtonElements$.click();console.log('Going to wait for: '+timeToWaitInMs+' ms.');setTimeout(()=>{claimAllButtonClickHandler(Math.floor(300+Math.random()*(400-300+1)));},timeToWaitInMs);}}}async function hookUpDonatorBadges(stuffUnlockedData){if(!stuffUnlockedData){return;}function parseStuffUnlockedData(){const donatorLevels=Object.values(stuffUnlockedData.donatorLevels).sort((a,b)=>a.minimalDonation-b.minimalDonation);for(const donatorId of Object.keys(stuffUnlockedData.donators)){const donatorInfo=stuffUnlockedData.donators[donatorId];const totalDonations=donatorInfo.donations.reduce((a,b)=>a+b,0);donatorInfo.totalDonations=totalDonations;if(donatorInfo.customBorderUrl){donatorInfo.borderUrl=donatorInfo.customBorderUrl;continue;}for(const donatorLevel of donatorLevels){if(totalDonations>=donatorLevel.minimalDonation){donatorInfo.borderUrl=donatorLevel.borderUrl;}else{break;}}}}const CLASS_NAMES={AVATAR_APPLIED:"su-avatar-applied",ACTION_APPLIED:"su-action-applied",DONATOR_BORDER:"su-donator-border",DONATOR_BORDER_NO_Z_INDEX:"su-no-z-index",PROFILE_PAGE_AVATAR_CONTAINER:"su-avatar-container",BATTLE_FIELD_NAME_ANIMATION:"su-battlefield-name-animation",BATTLE_FIELD_NAME:"su-battlefield-name"};function createGlobalStylesheet(){const style=document.createElement("style");// language=CSS
style.textContent="\n        img.".concat(CLASS_NAMES.DONATOR_BORDER," {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            top: 0;\n            transform: scale(1.2);\n            z-index: 11;\n            pointer-events: none;\n        }\n        img.").concat(CLASS_NAMES.DONATOR_BORDER,".").concat(CLASS_NAMES.DONATOR_BORDER_NO_Z_INDEX," {\n            z-index: unset;\n        }\n        .").concat(CLASS_NAMES.PROFILE_PAGE_AVATAR_CONTAINER," {\n            position: relative;\n            height: 158px;\n            width: 158px;\n            display: block;\n            margin-left: 10px;\n        }\n        .").concat(CLASS_NAMES.BATTLE_FIELD_NAME," {\n            color: #fff !important;\n            text-shadow: -1px -1px 0 #000,\n            1px -1px 0 #000,\n            -1px 1px 0 #000,\n            1px 1px 0 #000;\n        }\n        .").concat(CLASS_NAMES.BATTLE_FIELD_NAME_ANIMATION," {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            top: 0;\n            z-index: -1;\n            opacity: 0.5;\n        }\n        .").concat(CLASS_NAMES.BATTLE_FIELD_NAME_ANIMATION,"::before {\n            content: '';\n            position: absolute;\n            inset: 0;\n            background: linear-gradient(90deg, #fb0094, #0000ff, #00ff00, #ffff00, #fb0094, #0000ff, #00ff00, #ffff00, #fb0094);\n            animation: su-name-animation 20s linear infinite;\n            background-size: 500%\n        }\n        .").concat(CLASS_NAMES.BATTLE_FIELD_NAME_ANIMATION,"::after {\n            content: '';\n            position: absolute;\n            inset: 0;\n            background: linear-gradient(90deg, #fb0094, #0000ff, #00ff00, #ffff00, #fb0094, #0000ff, #00ff00, #ffff00, #fb0094);\n            animation: su-name-animation 20s linear infinite;\n            background-size: 500%;\n            filter: blur(20px);\n        }\n        @keyframes su-name-animation {\n            0% {\n                background-position: 0 0;\n            }\n            100% {\n                background-position: 500% 0;\n            }\n        }\n    ");document.head.appendChild(style);}parseStuffUnlockedData();createGlobalStylesheet();hookUpEventListeners();applyAllBadges();async function hookUpEventListeners(){await delay(300);// on Main Page
const olderPostsButton=document.querySelector("button.previousposts:not(.".concat(CLASS_NAMES.ACTION_APPLIED,")"));if(olderPostsButton){console.log("Older Posts button found. Listening for a click");olderPostsButton.classList.add(CLASS_NAMES.ACTION_APPLIED);olderPostsButton.addEventListener("click",()=>{applyAllBadges();hookUpEventListeners();});}// on Main Page
const expandCommentsButton=document.querySelectorAll(".postContent .commentCounter:not(.".concat(CLASS_NAMES.ACTION_APPLIED,")"));console.log("Found ".concat(expandCommentsButton.length," comment expand buttons. Listening for a click"));for(const commentsButton of expandCommentsButton){commentsButton.classList.add(CLASS_NAMES.ACTION_APPLIED);commentsButton.addEventListener("click",()=>applyAllBadges());}// on Main Page
const feedTabs=document.querySelectorAll("#citizenFeed .tabsWrapper .tab:not(.".concat(CLASS_NAMES.ACTION_APPLIED,")"));console.log("Found ".concat(feedTabs.length," feed tabs. Listening for a click"));for(const feedTab of feedTabs){feedTab.classList.add(CLASS_NAMES.ACTION_APPLIED);feedTab.addEventListener("click",()=>{removeFromPostsAndCommentsAvatars();applyAllBadges();hookUpEventListeners();});}// on Article Page
const loadMoreCommentsButton=document.querySelector("a.load-more-comments:not(.".concat(CLASS_NAMES.ACTION_APPLIED,")"));if(loadMoreCommentsButton){console.log("Load more comments button found. Listening for a click");loadMoreCommentsButton.classList.add(CLASS_NAMES.ACTION_APPLIED);loadMoreCommentsButton.addEventListener("click",()=>applyAllBadges());}}async function applyAllBadges(){applyPostsAndCommentsAvatars();applyArticleCommentsAvatars();applyBattlefieldAvatars();applyProfilePageAvatars();}async function applyProfilePageAvatars(){await delay(500);const avatarContainerElement=document.querySelector(".citizen_profile_header:not(.".concat(CLASS_NAMES.AVATAR_APPLIED,") > a"));if(!avatarContainerElement){return;}const playerId=window.location.href.split("/").at(-1);if(isDonator(playerId)){avatarContainerElement.classList.add(CLASS_NAMES.AVATAR_APPLIED,CLASS_NAMES.PROFILE_PAGE_AVATAR_CONTAINER);const avatarElement=avatarContainerElement.querySelector(".citizen_avatar");avatarElement&&(avatarElement.style.left="0");avatarContainerElement.appendChild(createBorderElementBasedOnDonatorLevel(playerId));}}async function applyBattlefieldAvatars(){if(!document.querySelector("#pvp")){return;}const maxPoolTime=2000;let currentPoolTime=300;while(true){const entities=document.querySelectorAll("#console_left > li:not(.".concat(CLASS_NAMES.AVATAR_APPLIED,"), #console_right > li:not(.").concat(CLASS_NAMES.AVATAR_APPLIED,")"));for(const entity of entities){var _containerElement$que;const containerElement=entity.querySelector("q");if(!containerElement){continue;}const playerId=(((_containerElement$que=containerElement.querySelector("a"))===null||_containerElement$que===void 0?void 0:_containerElement$que.href)||"").split("/").at(-1);entity.classList.add(CLASS_NAMES.AVATAR_APPLIED);if(isDonator(playerId)){var _playerNameElement$qu,_playerNameElement$qu2;containerElement.appendChild(createBorderElementBasedOnDonatorLevel(playerId,[CLASS_NAMES.DONATOR_BORDER_NO_Z_INDEX]));const playerNameElement=entity.querySelector(".player_name");if(!playerNameElement){continue;}(_playerNameElement$qu=playerNameElement.querySelector("a"))===null||_playerNameElement$qu===void 0?void 0:(_playerNameElement$qu2=_playerNameElement$qu.classList)===null||_playerNameElement$qu2===void 0?void 0:_playerNameElement$qu2.add(CLASS_NAMES.BATTLE_FIELD_NAME);const animationElement=document.createElement("div");animationElement.classList.add(CLASS_NAMES.BATTLE_FIELD_NAME_ANIMATION);playerNameElement.appendChild(animationElement);}}currentPoolTime=Math.min(currentPoolTime+200,maxPoolTime);await delay(currentPoolTime);}}async function applyArticleCommentsAvatars(){await delay(200);const avatars=document.querySelectorAll("a.citizenAvatar:not(.".concat(CLASS_NAMES.AVATAR_APPLIED,")"));for(const avatar of avatars){avatar.classList.add(CLASS_NAMES.AVATAR_APPLIED);const playerId=(avatar.href||"").split("/").at(-1);if(isDonator(playerId)){avatar.appendChild(createBorderElementBasedOnDonatorLevel(playerId));}}}async function applyPostsAndCommentsAvatars(){await delay(300);const avatars=document.querySelectorAll("a.userAvatar:not(.".concat(CLASS_NAMES.AVATAR_APPLIED,")"));for(const avatar of avatars){avatar.classList.add(CLASS_NAMES.AVATAR_APPLIED);const playerId=(avatar.href||"").split("/").at(-1);if(isDonator(playerId)){avatar.appendChild(createBorderElementBasedOnDonatorLevel(playerId));}}}async function removeFromPostsAndCommentsAvatars(){const avatars=document.querySelectorAll("a.userAvatar.".concat(CLASS_NAMES.AVATAR_APPLIED));for(const avatar of avatars){var _avatar$querySelector;avatar.classList.remove(CLASS_NAMES.AVATAR_APPLIED);(_avatar$querySelector=avatar.querySelector(".".concat(CLASS_NAMES.DONATOR_BORDER)))===null||_avatar$querySelector===void 0?void 0:_avatar$querySelector.remove();}}function isDonator(playerId){var _stuffUnlockedData$do;return!!((_stuffUnlockedData$do=stuffUnlockedData.donators[playerId])!==null&&_stuffUnlockedData$do!==void 0&&_stuffUnlockedData$do.borderUrl);}function createBorderElementBasedOnDonatorLevel(playerId,classNames){var _stuffUnlockedData$do2;const url=(_stuffUnlockedData$do2=stuffUnlockedData.donators[playerId])===null||_stuffUnlockedData$do2===void 0?void 0:_stuffUnlockedData$do2.borderUrl;return createBorderElement(url,classNames);}window.createBorderElementBasedOnDonatorLevel=createBorderElementBasedOnDonatorLevel;window.isDonator=isDonator;function createBorderElement(url){let classNames=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];const imageElement=document.createElement("img");imageElement.src=url;imageElement.classList.add(CLASS_NAMES.DONATOR_BORDER,...classNames);return imageElement;}}function calculateNoHitDamage(strength,rank){return 10*(1+strength/400)*(1+rank/5);}// ********** OLD INDEX END **********

/***/ }),

/***/ 981:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 135:
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 4:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var Scheduler = __webpack_require__(853),
  React = __webpack_require__(43),
  ReactDOM = __webpack_require__(950);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function isValidContainer(node) {
  return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
}
var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.tracing_marker");
var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (null == type) return null;
  if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
  if ("string" === typeof type) return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PORTAL_TYPE:
      return "Portal";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
  }
  if ("object" === typeof type) switch (type.$$typeof) {
    case REACT_CONTEXT_TYPE:
      return (type.displayName || "Context") + ".Provider";
    case REACT_CONSUMER_TYPE:
      return (type._context.displayName || "Context") + ".Consumer";
    case REACT_FORWARD_REF_TYPE:
      var innerType = type.render;
      type = type.displayName;
      type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
      return type;
    case REACT_MEMO_TYPE:
      return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
    case REACT_LAZY_TYPE:
      innerType = type._payload;
      type = type._init;
      try {
        return getComponentNameFromType(type(innerType));
      } catch (x) {}
  }
  return null;
}
var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  assign = Object.assign,
  prefix,
  suffix;
function describeBuiltInComponentFrame(name) {
  if (void 0 === prefix) try {
    throw Error();
  } catch (x) {
    var match = x.stack.trim().match(/\n( *(at )?)/);
    prefix = match && match[1] || "";
    suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
  }
  return "\n" + prefix + name + suffix;
}
var reentry = !1;
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) return "";
  reentry = !0;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function () {
        try {
          if (construct) {
            var Fake = function () {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function () {
                throw Error();
              }
            });
            if ("object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$0) {
                control = x$0;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$1) {
              control = x$1;
            }
            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
          }
        } catch (sample) {
          if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
    namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
      value: "DetermineComponentFrameRoot"
    });
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
      sampleStack = _RunInRootFrame$Deter[0],
      controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split("\n"),
        controlLines = controlStack.split("\n");
      for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");) RunInRootFrame++;
      for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
      if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];) namePropDescriptor--;
      for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
        if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
          do if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
            var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
            fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
            return frame;
          } while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
        }
        break;
      }
    }
  } finally {
    reentry = !1, Error.prepareStackTrace = previousPrepareStackTrace;
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
}
function describeFiber(fiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;
    case 11:
      return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;
    case 1:
      return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = "";
    do info += describeFiber(workInProgress), workInProgress = workInProgress.return; while (workInProgress);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}
function getNearestMountedFiber(fiber) {
  var node = fiber,
    nearestMounted = fiber;
  if (fiber.alternate) for (; node.return;) node = node.return;else {
    fiber = node;
    do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return; while (fiber);
  }
  return 3 === node.tag ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (13 === fiber.tag) {
    var suspenseState = fiber.memoizedState;
    null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
    if (null !== suspenseState) return suspenseState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber) throw Error(formatProdErrorMessage(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (null === alternate) throw Error(formatProdErrorMessage(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate;;) {
    var parentA = a.return;
    if (null === parentA) break;
    var parentB = parentA.alternate;
    if (null === parentB) {
      b = parentA.return;
      if (null !== b) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child; parentB;) {
        if (parentB === a) return assertIsMounted(parentA), fiber;
        if (parentB === b) return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage(188));
    }
    if (a.return !== b.return) a = parentA, b = parentB;else {
      for (var didFindChild = !1, child$2 = parentA.child; child$2;) {
        if (child$2 === a) {
          didFindChild = !0;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$2 === b) {
          didFindChild = !0;
          b = parentA;
          a = parentB;
          break;
        }
        child$2 = child$2.sibling;
      }
      if (!didFindChild) {
        for (child$2 = parentB.child; child$2;) {
          if (child$2 === a) {
            didFindChild = !0;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$2 === b) {
            didFindChild = !0;
            b = parentB;
            a = parentA;
            break;
          }
          child$2 = child$2.sibling;
        }
        if (!didFindChild) throw Error(formatProdErrorMessage(189));
      }
    }
    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
  }
  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
  for (node = node.child; null !== node;) {
    tag = findCurrentHostFiberImpl(node);
    if (null !== tag) return tag;
    node = node.sibling;
  }
  return null;
}
var isArrayImpl = Array.isArray,
  ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  sharedNotPendingObject = {
    pending: !1,
    data: null,
    method: null,
    action: null
  },
  valueStack = [],
  index = -1;
function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}
function pop(cursor) {
  0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
}
function push(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
var contextStackCursor = createCursor(null),
  contextFiberStackCursor = createCursor(null),
  rootInstanceStackCursor = createCursor(null),
  hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(fiber, nextRootInstance) {
  push(rootInstanceStackCursor, nextRootInstance);
  push(contextFiberStackCursor, fiber);
  push(contextStackCursor, null);
  fiber = nextRootInstance.nodeType;
  switch (fiber) {
    case 9:
    case 11:
      nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : 0 : 0;
      break;
    default:
      if (fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance, nextRootInstance = fiber.tagName, fiber = fiber.namespaceURI) fiber = getOwnHostContext(fiber), nextRootInstance = getChildHostContextProd(fiber, nextRootInstance);else switch (nextRootInstance) {
        case "svg":
          nextRootInstance = 1;
          break;
        case "math":
          nextRootInstance = 2;
          break;
        default:
          nextRootInstance = 0;
      }
  }
  pop(contextStackCursor);
  push(contextStackCursor, nextRootInstance);
}
function popHostContainer() {
  pop(contextStackCursor);
  pop(contextFiberStackCursor);
  pop(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
}
var hasOwnProperty = Object.prototype.hasOwnProperty,
  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
  cancelCallback$1 = Scheduler.unstable_cancelCallback,
  shouldYield = Scheduler.unstable_shouldYield,
  requestPaint = Scheduler.unstable_requestPaint,
  now = Scheduler.unstable_now,
  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
  NormalPriority$1 = Scheduler.unstable_NormalPriority,
  LowPriority = Scheduler.unstable_LowPriority,
  IdlePriority = Scheduler.unstable_IdlePriority,
  log$1 = Scheduler.log,
  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
  rendererID = null,
  injectedHook = null;
function onCommitRoot(root) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
    injectedHook.onCommitFiberRoot(rendererID, root, void 0, 128 === (root.current.flags & 128));
  } catch (err) {}
}
function setIsStrictModeForDevtools(newIsStrictMode) {
  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
  if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
    injectedHook.setStrictMode(rendererID, newIsStrictMode);
  } catch (err) {}
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
  log = Math.log,
  LN2 = Math.LN2;
function clz32Fallback(x) {
  x >>>= 0;
  return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
}
var nextTransitionLane = 128,
  nextRetryLane = 4194304;
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (0 !== pendingSyncLanes) return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 4194176;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root, wipLanes) {
  var pendingLanes = root.pendingLanes;
  if (0 === pendingLanes) return 0;
  var nextLanes = 0,
    suspendedLanes = root.suspendedLanes,
    pingedLanes = root.pingedLanes,
    warmLanes = root.warmLanes;
  root = 0 !== root.finishedLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));
  return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;
}
function checkIfRootIsPrerendering(root, renderLanes) {
  return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
      return currentTime + 250;
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextTransitionLane() {
  var lane = nextTransitionLane;
  nextTransitionLane <<= 1;
  0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
  return lane;
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root, updateLane) {
  root.pendingLanes |= updateLane;
  268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
}
function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
  var previouslyPendingLanes = root.pendingLanes;
  root.pendingLanes = remainingLanes;
  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.warmLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  root.errorRecoveryDisabledLanes &= remainingLanes;
  root.shellSuspendCounter = 0;
  var entanglements = root.entanglements,
    expirationTimes = root.expirationTimes,
    hiddenUpdates = root.hiddenUpdates;
  for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
    var index$7 = 31 - clz32(remainingLanes),
      lane = 1 << index$7;
    entanglements[index$7] = 0;
    expirationTimes[index$7] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$7];
    if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
      var update = hiddenUpdatesForLane[index$7];
      null !== update && (update.lane &= -536870913);
    }
    remainingLanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
  0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
  root.pendingLanes |= spawnedLane;
  root.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root.entangledLanes |= spawnedLane;
  root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;
}
function markRootEntangled(root, entangledLanes) {
  var rootEntangledLanes = root.entangledLanes |= entangledLanes;
  for (root = root.entanglements; rootEntangledLanes;) {
    var index$8 = 31 - clz32(rootEntangledLanes),
      lane = 1 << index$8;
    lane & entangledLanes | root[index$8] & entangledLanes && (root[index$8] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (0 !== updatePriority) return updatePriority;
  updatePriority = window.event;
  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return ReactDOMSharedInternals.p = priority, fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
var randomKey = Math.random().toString(36).slice(2),
  internalInstanceKey = "__reactFiber$" + randomKey,
  internalPropsKey = "__reactProps$" + randomKey,
  internalContainerInstanceKey = "__reactContainer$" + randomKey,
  internalEventHandlersKey = "__reactEvents$" + randomKey,
  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
  internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst) return targetInst;
  for (var parentNode = targetNode.parentNode; parentNode;) {
    if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
      parentNode = targetInst.alternate;
      if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;) {
        if (parentNode = targetNode[internalInstanceKey]) return parentNode;
        targetNode = getParentSuspenseInstance(targetNode);
      }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
    var tag = node.tag;
    if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
  throw Error(formatProdErrorMessage(33));
}
function getResourcesFromRoot(root) {
  var resources = root[internalRootNodeResourcesKey];
  resources || (resources = root[internalRootNodeResourcesKey] = {
    hoistableStyles: new Map(),
    hoistableScripts: new Map()
  });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = !0;
}
var allNativeEvents = new Set(),
  registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (registrationName = 0; registrationName < dependencies.length; registrationName++) allNativeEvents.add(dependencies[registrationName]);
}
var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
  VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
  illegalAttributeNameCache = {},
  validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;
  illegalAttributeNameCache[attributeName] = !0;
  return !1;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
        node.removeAttribute(name);
        return;
      case "boolean":
        var prefix$10 = name.toLowerCase().slice(0, 5);
        if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
          node.removeAttribute(name);
          return;
        }
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForKnownAttribute(node, name, value) {
  if (null === value) node.removeAttribute(name);else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (null === value) node.removeAttribute(name);else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
}
function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? "checked" : "value",
    descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField),
    currentValue = "" + node[valueField];
  if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
    var get = descriptor.get,
      set = descriptor.set;
    Object.defineProperty(node, valueField, {
      configurable: !0,
      get: function () {
        return get.call(this);
      },
      set: function (value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = "" + value;
      },
      stopTracking: function () {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
}
function updateValueIfChanged(node) {
  if (!node) return !1;
  var tracker = node._valueTracker;
  if (!tracker) return !0;
  var lastValue = tracker.getValue();
  var value = "";
  node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
}
function getActiveElement(doc) {
  doc = doc || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof doc) return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function (ch) {
    return "\\" + ch.charCodeAt(0).toString(16) + " ";
  });
}
function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
  element.name = "";
  null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
  if (null != value) {
    if ("number" === type) {
      if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
    } else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
  } else "submit" !== type && "reset" !== type || element.removeAttribute("value");
  null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
  null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
  null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
  null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
}
function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
  null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
  if (null != value || null != defaultValue) {
    if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) return;
    defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    value = null != value ? "" + getToStringValue(value) : defaultValue;
    isHydrating || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = null != checked ? checked : defaultChecked;
  checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
  element.checked = isHydrating ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
}
function setDefaultValue(node, type, value) {
  "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0; i < propValue.length; i++) multiple["$" + propValue[i]] = !0;
    for (propValue = 0; propValue < node.length; propValue++) i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = !0);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0; i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = !0;
        setDefaultSelected && (node[i].defaultSelected = !0);
        return;
      }
      null !== multiple || node[i].disabled || (multiple = node[i]);
    }
    null !== multiple && (multiple.selected = !0);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (null == value) {
    if (null != children) {
      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
      if (isArrayImpl(children)) {
        if (1 < children.length) throw Error(formatProdErrorMessage(93));
        children = children[0];
      }
      defaultValue = children;
    }
    null == defaultValue && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue && "" !== children && null !== children && (element.value = children);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
function setValueForStyle(style, styleName, value) {
  var isCustomProperty = 0 === styleName.indexOf("--");
  null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style.cssFloat = value : style[styleName] = ("" + value).trim() : style[styleName] = value + "px";
}
function setValueForStyles(node, styles, prevStyles) {
  if (null != styles && "object" !== typeof styles) throw Error(formatProdErrorMessage(62));
  node = node.style;
  if (null != prevStyles) {
    for (var styleName in prevStyles) !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
    for (var styleName$16 in styles) styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
  } else for (var styleName$17 in styles) styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (-1 === tagName.indexOf("-")) return !1;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var aliases = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]),
  isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
}
var currentReplayingEvent = null;
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
}
var restoreTarget = null,
  restoreQueue = null;
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a: switch (target = internalInstance.stateNode, internalInstance.type) {
      case "input":
        updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
        internalInstance = props.name;
        if ("radio" === props.type && null != internalInstance) {
          for (props = target; props.parentNode;) props = props.parentNode;
          props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
          for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
            var otherNode = props[internalInstance];
            if (otherNode !== target && otherNode.form === target.form) {
              var otherProps = otherNode[internalPropsKey] || null;
              if (!otherProps) throw Error(formatProdErrorMessage(90));
              updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
            }
          }
          for (internalInstance = 0; internalInstance < props.length; internalInstance++) otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
        }
        break a;
      case "textarea":
        updateTextarea(target, props.value, props.defaultValue);
        break a;
      case "select":
        internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, !1);
    }
  }
}
var isInsideEventHandler = !1;
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler) return fn(a, b);
  isInsideEventHandler = !0;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (isInsideEventHandler = !1, null !== restoreTarget || null !== restoreQueue) if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (null === stateNode) return null;
  var props = stateNode[internalPropsKey] || null;
  if (null === props) return null;
  stateNode = props[registrationName];
  a: switch (registrationName) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
      inst = !props;
      break a;
    default:
      inst = !1;
  }
  if (inst) return null;
  if (stateNode && "function" !== typeof stateNode) throw Error(formatProdErrorMessage(231, registrationName, typeof stateNode));
  return stateNode;
}
var passiveBrowserEventsSupported = !1;
if (canUseDOM) try {
  var options = {};
  Object.defineProperty(options, "passive", {
    get: function () {
      passiveBrowserEventsSupported = !0;
    }
  });
  window.addEventListener("test", options, options);
  window.removeEventListener("test", options, options);
} catch (e) {
  passiveBrowserEventsSupported = !1;
}
var root = null,
  startText = null,
  fallbackText = null;
function getData() {
  if (fallbackText) return fallbackText;
  var start,
    startValue = startText,
    startLength = startValue.length,
    end,
    endValue = "value" in root ? root.value : root.textContent,
    endLength = endValue.length;
  for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
  var minEnd = startLength - start;
  for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
  return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
  10 === nativeEvent && (nativeEvent = 13);
  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return !0;
}
function functionThatReturnsFalse() {
  return !1;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface) Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
    },
    stopPropagation: function () {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
    },
    persist: function () {},
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  SyntheticEvent = createSyntheticEvent(EventInterface),
  UIEventInterface = assign({}, EventInterface, {
    view: 0,
    detail: 0
  }),
  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
  lastMovementX,
  lastMovementY,
  lastMouseEvent,
  MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function (event) {
      return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
    },
    movementX: function (event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
      return lastMovementX;
    },
    movementY: function (event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }),
  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
  DragEventInterface = assign({}, MouseEventInterface, {
    dataTransfer: 0
  }),
  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
  FocusEventInterface = assign({}, UIEventInterface, {
    relatedTarget: 0
  }),
  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
  AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
  ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function (event) {
      return "clipboardData" in event ? event.clipboardData : window.clipboardData;
    }
  }),
  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
  CompositionEventInterface = assign({}, EventInterface, {
    data: 0
  }),
  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
  normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : !1;
}
function getEventModifierState() {
  return modifierStateGetter;
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function (nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function (event) {
      return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    },
    which: function (event) {
      return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    }
  }),
  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
  PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
  TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }),
  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
  TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
  WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function (event) {
      return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function (event) {
      return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
  ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }),
  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
  END_KEYCODES = [9, 13, 27, 32],
  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
  documentMode = null;
canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
  useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode),
  SPACEBAR_CHAR = String.fromCharCode(32),
  hasSpaceKeypress = !1;
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
    case "keydown":
      return 229 !== nativeEvent.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
}
var isComposing = !1;
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (32 !== nativeEvent.which) return null;
      hasSpaceKeypress = !0;
      return SPACEBAR_CHAR;
    case "textInput":
      return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = !1, domEventName) : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
        if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
    default:
      return null;
  }
}
var supportedInputTypes = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? !0 : !1;
}
function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
    event: nativeEvent,
    listeners: inst
  }));
}
var activeElement$1 = null,
  activeElementInst$1 = null;
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if ("change" === domEventName) return targetInst;
}
var isInputEventSupported = !1;
if (canUseDOM) {
  var JSCompiler_inline_result$jscomp$283;
  if (canUseDOM) {
    var isSupported$jscomp$inline_418 = "oninput" in document;
    if (!isSupported$jscomp$inline_418) {
      var element$jscomp$inline_419 = document.createElement("div");
      element$jscomp$inline_419.setAttribute("oninput", "return;");
      isSupported$jscomp$inline_418 = "function" === typeof element$jscomp$inline_419.oninput;
    }
    JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418;
  } else JSCompiler_inline_result$jscomp$283 = !1;
  isInputEventSupported = JSCompiler_inline_result$jscomp$283 && (!document.documentMode || 9 < document.documentMode);
}
function stopWatchingForValueChange() {
  activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
}
function handlePropertyChange(nativeEvent) {
  if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
}
var objectIs = "function" === typeof Object.is ? Object.is : is;
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) return !0;
  if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
  var keysA = Object.keys(objA),
    keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return !1;
  for (keysB = 0; keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;
  }
  return !0;
}
function getLeafNode(node) {
  for (; node && node.firstChild;) node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  root = 0;
  for (var nodeEnd; node;) {
    if (3 === node.nodeType) {
      nodeEnd = root + node.textContent.length;
      if (root <= offset && nodeEnd >= offset) return {
        node: node,
        offset: offset - root
      };
      root = nodeEnd;
    }
    a: {
      for (; node;) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = void 0;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode ? outerNode === innerNode ? !0 : outerNode && 3 === outerNode.nodeType ? !1 : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1 : !1;
}
function getActiveElementDeep(containerInfo) {
  containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
  for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;) {
    try {
      var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
    } catch (err) {
      JSCompiler_inline_result = !1;
    }
    if (JSCompiler_inline_result) containerInfo = element.contentWindow;else break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
}
function restoreSelection(priorSelectionInformation, containerInfo) {
  var curFocusedElem = getActiveElementDeep(containerInfo);
  containerInfo = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== containerInfo && containerInfo && containerInfo.ownerDocument && containsNode(containerInfo.ownerDocument.documentElement, containerInfo)) {
    if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo)) if (priorSelectionInformation = priorSelectionRange.start, curFocusedElem = priorSelectionRange.end, void 0 === curFocusedElem && (curFocusedElem = priorSelectionInformation), "selectionStart" in containerInfo) containerInfo.selectionStart = priorSelectionInformation, containerInfo.selectionEnd = Math.min(curFocusedElem, containerInfo.value.length);else if (curFocusedElem = (priorSelectionInformation = containerInfo.ownerDocument || document) && priorSelectionInformation.defaultView || window, curFocusedElem.getSelection) {
      curFocusedElem = curFocusedElem.getSelection();
      var length = containerInfo.textContent.length,
        start = Math.min(priorSelectionRange.start, length);
      priorSelectionRange = void 0 === priorSelectionRange.end ? start : Math.min(priorSelectionRange.end, length);
      !curFocusedElem.extend && start > priorSelectionRange && (length = priorSelectionRange, priorSelectionRange = start, start = length);
      length = getNodeForCharacterOffset(containerInfo, start);
      var endMarker = getNodeForCharacterOffset(containerInfo, priorSelectionRange);
      length && endMarker && (1 !== curFocusedElem.rangeCount || curFocusedElem.anchorNode !== length.node || curFocusedElem.anchorOffset !== length.offset || curFocusedElem.focusNode !== endMarker.node || curFocusedElem.focusOffset !== endMarker.offset) && (priorSelectionInformation = priorSelectionInformation.createRange(), priorSelectionInformation.setStart(length.node, length.offset), curFocusedElem.removeAllRanges(), start > priorSelectionRange ? (curFocusedElem.addRange(priorSelectionInformation), curFocusedElem.extend(endMarker.node, endMarker.offset)) : (priorSelectionInformation.setEnd(endMarker.node, endMarker.offset), curFocusedElem.addRange(priorSelectionInformation)));
    }
    priorSelectionInformation = [];
    for (curFocusedElem = containerInfo; curFocusedElem = curFocusedElem.parentNode;) 1 === curFocusedElem.nodeType && priorSelectionInformation.push({
      element: curFocusedElem,
      left: curFocusedElem.scrollLeft,
      top: curFocusedElem.scrollTop
    });
    "function" === typeof containerInfo.focus && containerInfo.focus();
    for (containerInfo = 0; containerInfo < priorSelectionInformation.length; containerInfo++) curFocusedElem = priorSelectionInformation[containerInfo], curFocusedElem.element.scrollLeft = curFocusedElem.left, curFocusedElem.element.scrollTop = curFocusedElem.top;
  }
}
var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode,
  activeElement = null,
  activeElementInst = null,
  lastSelection = null,
  mouseDown = !1;
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
  mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
    start: doc.selectionStart,
    end: doc.selectionEnd
  } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
    anchorNode: doc.anchorNode,
    anchorOffset: doc.anchorOffset,
    focusNode: doc.focusNode,
    focusOffset: doc.focusOffset
  }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
    event: nativeEvent,
    listeners: doc
  }), nativeEvent.target = activeElement)));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  },
  prefixedEventNames = {},
  style = {};
canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName]) return eventName;
  var prefixMap = vendorPrefixes[eventName],
    styleProp;
  for (styleProp in prefixMap) if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
  return eventName;
}
var ANIMATION_END = getVendorPrefixedEventName("animationend"),
  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
  topLevelEventsToReactNames = new Map(),
  simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" ");
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
var concurrentQueues = [],
  concurrentQueuesIndex = 0,
  concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
  for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (null !== queue && null !== update) {
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  null !== fiber && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  null !== alternate && (alternate.lanes |= lane);
  for (var isHidden = !1, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;
  isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [update] : sourceFiber.push(update), update.lane = lane | 536870912);
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
  for (var parent = sourceFiber.return; null !== parent;) sourceFiber = parent, parent = sourceFiber.return;
  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
}
var emptyContextObject = {},
  CapturedStacks = new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if ("object" === typeof value && null !== value) {
    var existing = CapturedStacks.get(value);
    if (void 0 !== existing) return existing;
    source = {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
var forkStack = [],
  forkStackIndex = 0,
  treeForkProvider = null,
  treeForkCount = 0,
  idStack = [],
  idStackIndex = 0,
  treeContextProvider = null,
  treeContextId = 1,
  treeContextOverflow = "";
function pushTreeFork(workInProgress, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress, totalChildren, index) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - baseLength % 5;
    length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress;
  } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
}
function pushMaterializedTreeId(workInProgress) {
  null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
}
function popTreeContext(workInProgress) {
  for (; workInProgress === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
  for (; workInProgress === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
}
var hydrationParentFiber = null,
  nextHydratableInstance = null,
  isHydrating = !1,
  hydrationErrors = null,
  rootOrSingletonContext = !1,
  HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(fiber) {
  var error = Error(formatProdErrorMessage(418, ""));
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var instance = fiber.stateNode,
    type = fiber.type,
    props = fiber.memoizedProps;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0; type < mediaEventTypes.length; type++) listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(instance, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, !0);
      track(instance);
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
  }
  type = props.children;
  "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || !0 === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = !0) : instance = !1;
  instance || throwOnHydrationMismatch(fiber);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
    case 3:
    case 27:
      rootOrSingletonContext = !0;
      return;
    case 5:
    case 13:
      rootOrSingletonContext = !1;
      return;
    default:
      hydrationParentFiber = hydrationParentFiber.return;
  }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber) return !1;
  if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
  var shouldClear = !1,
    JSCompiler_temp;
  if (JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag) {
    if (JSCompiler_temp = 5 === fiber.tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && (shouldClear = !0);
  shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (13 === fiber.tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    a: {
      fiber = fiber.nextSibling;
      for (shouldClear = 0; fiber;) {
        if (8 === fiber.nodeType) if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
          if (0 === shouldClear) {
            nextHydratableInstance = getNextHydratable(fiber.nextSibling);
            break a;
          }
          shouldClear--;
        } else "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || shouldClear++;
        fiber = fiber.nextSibling;
      }
      nextHydratableInstance = null;
    }
  } else nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
  return !0;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = !1;
}
function queueHydrationError(error) {
  null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
}
var SuspenseException = Error(formatProdErrorMessage(460)),
  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
  noopSuspenseyCommitThenable = {
    then: function () {}
  };
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return "fulfilled" === thenable || "rejected" === thenable;
}
function noop$3() {}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  void 0 === index ? thenableState.push(thenable) : index !== thenable && (thenable.then(noop$3, noop$3), thenable = index);
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      thenableState = thenable.reason;
      if (thenableState === SuspenseException) throw Error(formatProdErrorMessage(483));
      throw thenableState;
    default:
      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);else {
        thenableState = workInProgressRoot;
        if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(formatProdErrorMessage(482));
        thenableState = thenable;
        thenableState.status = "pending";
        thenableState.then(function (fulfilledValue) {
          if ("pending" === thenable.status) {
            var fulfilledThenable = thenable;
            fulfilledThenable.status = "fulfilled";
            fulfilledThenable.value = fulfilledValue;
          }
        }, function (error) {
          if ("pending" === thenable.status) {
            var rejectedThenable = thenable;
            rejectedThenable.status = "rejected";
            rejectedThenable.reason = error;
          }
        });
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          thenableState = thenable.reason;
          if (thenableState === SuspenseException) throw Error(formatProdErrorMessage(483));
          throw thenableState;
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
var thenableState$1 = null,
  thenableIndexCounter$1 = 0;
function unwrapThenable(thenable) {
  var index = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  null === thenableState$1 && (thenableState$1 = []);
  return trackUsedThenable(thenableState$1, thenable, index);
}
function coerceRef(workInProgress, element) {
  element = element.props.ref;
  workInProgress.ref = void 0 !== element ? element : null;
}
function throwOnInvalidObjectType(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error(formatProdErrorMessage(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(formatProdErrorMessage(31, "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber));
}
function resolveLazy(lazyType) {
  var init = lazyType._init;
  return init(lazyType._payload);
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) return null;
    for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;
    newFiber.flags |= 33554434;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
    if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
    current = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
        case REACT_PORTAL_TYPE:
          return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return createChild(returnFiber, newChild, lanes);
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
      if ("function" === typeof newChild.then) return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = null !== oldFiber ? oldFiber.key : null;
    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
        case REACT_PORTAL_TYPE:
          return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
        case REACT_LAZY_TYPE:
          return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if ("function" === typeof newChild.then) return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
        case REACT_PORTAL_TYPE:
          return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
      if ("function" === typeof newChild.then) return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
    if (null === oldFiber) {
      for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
    shouldTrackSideEffects && oldFiber.forEach(function (child) {
      return deleteChild(returnFiber, child);
    });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
    if (null == newChildren) throw Error(formatProdErrorMessage(151));
    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
    if (null === oldFiber) {
      for (; !step.done; newIdx++, step = newChildren.next()) step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
    shouldTrackSideEffects && oldFiber.forEach(function (child) {
      return deleteChild(returnFiber, child);
    });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
    "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            for (var key = newChild.key; null !== currentFirstChild;) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE) {
                  if (7 === currentFirstChild.tag) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    lanes = useFiber(currentFirstChild, newChild.props.children);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE:
          a: {
            for (key = newChild.key; null !== currentFirstChild;) {
              if (currentFirstChild.key === key) {
                if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE:
          return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
      }
      if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
      if (getIteratorFn(newChild)) {
        key = getIteratorFn(newChild);
        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
      }
      if ("function" === typeof newChild.then) return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function (returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter$1 = 0;
      var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
      thenableState$1 = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException) throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {}
  };
}
var reconcileChildFibers = createChildReconciler(!0),
  mountChildFibers = createChildReconciler(!1),
  currentTreeHiddenStackCursor = createCursor(null),
  prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push(prevEntangledRenderLanesCursor, fiber);
  push(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop(currentTreeHiddenStackCursor);
  pop(prevEntangledRenderLanesCursor);
}
var suspenseHandlerStackCursor = createCursor(null),
  shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push(suspenseStackCursor, suspenseStackCursor.current & 1);
  push(suspenseHandlerStackCursor, handler);
  null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
}
function pushOffscreenSuspenseHandler(fiber) {
  if (22 === fiber.tag) {
    if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
      var current = fiber.alternate;
      null !== current && null !== current.memoizedState && (shellBoundary = fiber);
    }
  } else reuseSuspenseHandlerOnStack(fiber);
}
function reuseSuspenseHandlerOnStack() {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop(suspenseStackCursor);
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(row) {
  for (var node = row; null !== node;) {
    if (13 === node.tag) {
      var state = node.memoizedState;
      if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || "$!" === state.data)) return node;
    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
      if (0 !== (node.flags & 128)) return node;
    } else if (null !== node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) break;
    for (; null === node.sibling;) {
      if (null === node.return || node.return === row) return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function () {
    var listeners = [],
      signal = this.signal = {
        aborted: !1,
        addEventListener: function (type, listener) {
          listeners.push(listener);
        }
      };
    this.abort = function () {
      signal.aborted = !0;
      listeners.forEach(function (listener) {
        return listener();
      });
    };
  },
  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
  NormalPriority = Scheduler.unstable_NormalPriority,
  CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  0 === cache.refCount && scheduleCallback$2(NormalPriority, function () {
    cache.controller.abort();
  });
}
var currentEntangledListeners = null,
  currentEntangledPendingCount = 0,
  currentEntangledLane = 0,
  currentEntangledActionThenable = null;
function entangleAsyncAction(transition, thenable) {
  if (null === currentEntangledListeners) {
    var entangledListeners = currentEntangledListeners = [];
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: void 0,
      then: function (resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
    null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [],
    thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function (resolve) {
        listeners.push(resolve);
      }
    };
  thenable.then(function () {
    thenableWithOverride.status = "fulfilled";
    thenableWithOverride.value = result;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
  }, function (error) {
    thenableWithOverride.status = "rejected";
    thenableWithOverride.reason = error;
    for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
  });
  return thenableWithOverride;
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function (transition, returnValue) {
  "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
  null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
};
var resumedCache = createCursor(null);
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return null === cacheFromPool ? null : {
    parent: CacheContext._currentValue,
    pool: cacheFromPool
  };
}
var renderLanes = 0,
  currentlyRenderingFiber$1 = null,
  currentHook = null,
  workInProgressHook = null,
  didScheduleRenderPhaseUpdate = !1,
  didScheduleRenderPhaseUpdateDuringThisPass = !1,
  shouldDoubleInvokeUserFnsInHooksDEV = !1,
  localIdCounter = 0,
  thenableIndexCounter = 0,
  thenableState = null,
  globalClientIdCounter = 0;
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (null === prevDeps) return !1;
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
  return !0;
}
function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber$1 = workInProgress;
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = 0;
  ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  nextRenderLanes = Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(workInProgress, Component, props, secondArg));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
  didScheduleRenderPhaseUpdate = !1;
  thenableIndexCounter = 0;
  thenableState = null;
  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
  null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
}
function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
  currentlyRenderingFiber$1 = workInProgress;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
    thenableIndexCounter = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = !1;
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (null != workInProgress.updateQueue) {
      var children = workInProgress.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      null != children.memoCache && (children.memoCache.index = 0);
    }
    ReactSharedInternals.H = HooksDispatcherOnRerender;
    children = Component(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals.H,
    maybeThenable = dispatcher.useState()[0];
  maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = 0 !== localIdCounter;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress) {
  if (didScheduleRenderPhaseUpdate) {
    for (workInProgress = workInProgress.memoizedState; null !== workInProgress;) {
      var queue = workInProgress.queue;
      null !== queue && (queue.pending = null);
      workInProgress = workInProgress.next;
    }
    didScheduleRenderPhaseUpdate = !1;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
  didScheduleRenderPhaseUpdateDuringThisPass = !1;
  thenableIndexCounter = localIdCounter = 0;
  thenableState = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (null === currentHook) {
    var nextCurrentHook = currentlyRenderingFiber$1.alternate;
    nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
  } else nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
  if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;else {
    if (null === nextCurrentHook) {
      if (null === currentlyRenderingFiber$1.alternate) throw Error(formatProdErrorMessage(467));
      throw Error(formatProdErrorMessage(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
  }
  return workInProgressHook;
}
var createFunctionComponentUpdateQueue;
createFunctionComponentUpdateQueue = function () {
  return {
    lastEffect: null,
    events: null,
    stores: null,
    memoCache: null
  };
};
function useThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  null === thenableState && (thenableState = []);
  thenable = trackUsedThenable(thenableState, thenable, index);
  index = currentlyRenderingFiber$1;
  null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null === index || null === index.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
  return thenable;
}
function use(usable) {
  if (null !== usable && "object" === typeof usable) {
    if ("function" === typeof usable.then) return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
  }
  throw Error(formatProdErrorMessage(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null,
    updateQueue = currentlyRenderingFiber$1.updateQueue;
  null !== updateQueue && (memoCache = updateQueue.memoCache);
  if (null == memoCache) {
    var current = currentlyRenderingFiber$1.alternate;
    null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
      data: current.data.map(function (array) {
        return array.slice();
      }),
      index: 0
    })));
  }
  null == memoCache && (memoCache = {
    data: [],
    index: 0
  });
  null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (void 0 === updateQueue) for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return "function" === typeof action ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue,
    pendingQueue = queue.pending;
  if (null !== pendingQueue) {
    if (null !== baseQueue) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (null === baseQueue) hook.memoizedState = pendingQueue;else {
    current = baseQueue.next;
    var newBaseQueueFirst = baseFirst = null,
      newBaseQueueLast = null,
      update = current,
      didReadFromEntangledAsyncAction$54 = !1;
    do {
      var updateLane = update.lane & -536870913;
      if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
        var revertLane = update.revertLane;
        if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
          lane: 0,
          revertLane: 0,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$54 = !0);else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$54 = !0);
          continue;
        } else updateLane = {
          lane: 0,
          revertLane: update.revertLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
      } else revertLane = {
        lane: updateLane,
        revertLane: update.revertLane,
        action: update.action,
        hasEagerState: update.hasEagerState,
        eagerState: update.eagerState,
        next: null
      }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
      update = update.next;
    } while (null !== update && update !== current);
    null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
    if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction$54 && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  null === baseQueue && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(),
    queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var dispatch = queue.dispatch,
    lastRenderPhaseUpdate = queue.pending,
    newState = hook.memoizedState;
  if (null !== lastRenderPhaseUpdate) {
    queue.pending = null;
    var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    do newState = reducer(newState, update.action), update = update.next; while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
    hook.memoizedState = newState;
    null === hook.baseQueue && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber$1,
    hook = updateWorkInProgressHook(),
    isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
    getServerSnapshot = getServerSnapshot();
  } else getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
  snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0);
  hook = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [subscribe]);
  if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
    fiber.flags |= 2048;
    pushEffect(9, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {
      destroy: void 0
    }, null);
    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
    isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = {
    getSnapshot: getSnapshot,
    value: renderedSnapshot
  };
  getSnapshot = currentlyRenderingFiber$1.updateQueue;
  null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function () {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function forceStoreRerender(fiber) {
  var root = enqueueConcurrentRenderForLane(fiber, 2);
  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if ("function" === typeof initialState) {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
}
function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
  fiber = actionQueue.action;
  if (null !== fiber) {
    var actionNode = {
      payload: payload,
      action: fiber,
      next: null,
      isTransition: !0,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function (listener) {
        actionNode.listeners.push(listener);
      }
    };
    null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;
    setState(actionNode);
    setPendingState = actionQueue.pending;
    null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
  }
}
function runActionStateAction(actionQueue, node) {
  var action = node.action,
    payload = node.payload,
    prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = action(prevState, payload),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      ReactSharedInternals.T = prevTransition;
    }
  } else try {
    prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
  } catch (error$60) {
    onActionError(actionQueue, node, error$60);
  }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(function (nextState) {
    onActionSuccess(actionQueue, node, nextState);
  }, function (error) {
    return onActionError(actionQueue, node, error);
  }) : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (null !== last) {
    last = last.next;
    do actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next; while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (null !== ssrFormState) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber$1;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType;) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
                if (null === JSCompiler_inline_result$jscomp$0) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
              JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = !1;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, JSCompiler_inline_result);
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(!1);
  inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, JSCompiler_inline_result.queue);
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action: action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, JSCompiler_inline_result$jscomp$0, inRootOrSingleton, ssrFormState);
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, !1];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
  stateHook = updateReducer(basicStateReducer)[0];
  currentStateHook = "object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;
  var actionQueueHook = updateWorkInProgressHook(),
    actionQueue = actionQueueHook.queue,
    dispatch = actionQueue.dispatch;
  action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(9, actionStateActionEffect.bind(null, actionQueue, action), {
    destroy: void 0
  }, null));
  return [currentStateHook, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(),
    currentStateHook = currentHook;
  if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, !1];
}
function pushEffect(tag, create, inst, deps) {
  tag = {
    tag: tag,
    create: create,
    inst: inst,
    deps: deps,
    next: null
  };
  create = currentlyRenderingFiber$1.updateQueue;
  null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);
  inst = create.lastEffect;
  null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);
  return tag;
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(1 | hookFlags, create, {
    destroy: void 0
  }, void 0 === deps ? null : deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var inst = hook.memoizedState.inst;
  null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(1 | hookFlags, create, inst, deps));
}
function mountEffect(create, deps) {
  mountEffectImpl(8390656, 8, create, deps);
}
function updateEffect(create, deps) {
  updateEffectImpl(2048, 8, create, deps);
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if ("function" === typeof ref) {
    create = create();
    var refCleanup = ref(create);
    return function () {
      "function" === typeof refCleanup ? refCleanup() : ref(null);
    };
  }
  if (null !== ref && void 0 !== ref) return create = create(), ref.current = create, function () {
    ref.current = null;
  };
}
function updateImperativeHandle(ref, create, deps) {
  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(!0);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(!1);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber$1.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue)) return value;
  if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;
  if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;
  hook = requestDeferredLane();
  currentlyRenderingFiber$1.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
  try {
    var returnValue = callback(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
    if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
      var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
      dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
    } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
  } catch (error) {
    dispatchSetStateInternal(fiber, queue, {
      then: function () {},
      status: "rejected",
      reason: error
    }, requestUpdateLane());
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
  }
}
function noop$2() {}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(formFiber, queue, pendingState, sharedNotPendingObject, null === action ? noop$2 : function () {
    requestFormReset$1(formFiber);
    return action(formData);
  });
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (null !== existingStateHook) return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  null !== formFiber && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return; null !== provider;) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$63 = enqueueUpdate(provider, fiber, lane);
        null !== root$63 && (scheduleUpdateOnFiber(root$63, provider, lane), entangleTransitions(root$63, provider, lane));
        provider = {
          cache: createCache()
        };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane: lane,
    revertLane: 0,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane: lane,
    revertLane: 0,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);else {
    var alternate = fiber.alternate;
    if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) try {
      var currentState = queue.lastRenderedState,
        eagerState = alternate(currentState, action);
      update.hasEagerState = !0;
      update.eagerState = eagerState;
      if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;
    } catch (error) {} finally {}
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;
  }
  return !1;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
  } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
  var pending = queue.pending;
  null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
  queue.pending = update;
}
function entangleTransitionUpdate(root, queue, lane) {
  if (0 !== (lane & 4194176)) {
    var queueLanes = queue.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext: readContext,
  use: use,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError
};
ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
ContextOnlyDispatcher.useFormState = throwInvalidHookError;
ContextOnlyDispatcher.useActionState = throwInvalidHookError;
ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
var HooksDispatcherOnMount = {
  readContext: readContext,
  use: use,
  useCallback: function (callback, deps) {
    mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
    return callback;
  },
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: function (ref, create, deps) {
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create, ref), deps);
  },
  useLayoutEffect: function (create, deps) {
    return mountEffectImpl(4194308, 4, create, deps);
  },
  useInsertionEffect: function (create, deps) {
    mountEffectImpl(4, 2, create, deps);
  },
  useMemo: function (nextCreate, deps) {
    var hook = mountWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var nextValue = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    hook.memoizedState = [nextValue, deps];
    return nextValue;
  },
  useReducer: function (reducer, initialArg, init) {
    var hook = mountWorkInProgressHook();
    if (void 0 !== init) {
      var initialState = init(initialArg);
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          init(initialArg);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
    } else initialState = initialArg;
    hook.memoizedState = hook.baseState = initialState;
    reducer = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: reducer,
      lastRenderedState: initialState
    };
    hook.queue = reducer;
    reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);
    return [hook.memoizedState, reducer];
  },
  useRef: function (initialValue) {
    var hook = mountWorkInProgressHook();
    initialValue = {
      current: initialValue
    };
    return hook.memoizedState = initialValue;
  },
  useState: function (initialState) {
    initialState = mountStateImpl(initialState);
    var queue = initialState.queue,
      dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
    queue.dispatch = dispatch;
    return [initialState.memoizedState, dispatch];
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = mountWorkInProgressHook();
    return mountDeferredValueImpl(hook, value, initialValue);
  },
  useTransition: function () {
    var stateHook = mountStateImpl(!1);
    stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);
    mountWorkInProgressHook().memoizedState = stateHook;
    return [!1, stateHook];
  },
  useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber$1,
      hook = mountWorkInProgressHook();
    if (isHydrating) {
      if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else {
      getServerSnapshot = getSnapshot();
      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
      0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    hook.memoizedState = getServerSnapshot;
    var inst = {
      value: getServerSnapshot,
      getSnapshot: getSnapshot
    };
    hook.queue = inst;
    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
    fiber.flags |= 2048;
    pushEffect(9, updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot), {
      destroy: void 0
    }, null);
    return getServerSnapshot;
  },
  useId: function () {
    var hook = mountWorkInProgressHook(),
      identifierPrefix = workInProgressRoot.identifierPrefix;
    if (isHydrating) {
      var JSCompiler_inline_result = treeContextOverflow;
      var idWithLeadingBit = treeContextId;
      JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
      identifierPrefix = ":" + identifierPrefix + "R" + JSCompiler_inline_result;
      JSCompiler_inline_result = localIdCounter++;
      0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
      identifierPrefix += ":";
    } else JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = ":" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + ":";
    return hook.memoizedState = identifierPrefix;
  },
  useCacheRefresh: function () {
    return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);
  }
};
HooksDispatcherOnMount.useMemoCache = useMemoCache;
HooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnMount.useFormState = mountActionState;
HooksDispatcherOnMount.useActionState = mountActionState;
HooksDispatcherOnMount.useOptimistic = function (passthrough) {
  var hook = mountWorkInProgressHook();
  hook.memoizedState = hook.baseState = passthrough;
  var queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: null,
    lastRenderedState: null
  };
  hook.queue = queue;
  hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);
  queue.dispatch = hook;
  return [passthrough, hook];
};
var HooksDispatcherOnUpdate = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: function () {
    return updateReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
  },
  useTransition: function () {
    var booleanOrThenable = updateReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId
};
HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;
HooksDispatcherOnUpdate.useMemoCache = useMemoCache;
HooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnUpdate.useFormState = updateActionState;
HooksDispatcherOnUpdate.useActionState = updateActionState;
HooksDispatcherOnUpdate.useOptimistic = function (passthrough, reducer) {
  var hook = updateWorkInProgressHook();
  return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
};
var HooksDispatcherOnRerender = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: function () {
    return rerenderReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
  },
  useTransition: function () {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId
};
HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;
HooksDispatcherOnRerender.useMemoCache = useMemoCache;
HooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;
HooksDispatcherOnRerender.useFormState = rerenderActionState;
HooksDispatcherOnRerender.useActionState = rerenderActionState;
HooksDispatcherOnRerender.useOptimistic = function (passthrough, reducer) {
  var hook = updateWorkInProgressHook();
  if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
  hook.baseState = passthrough;
  return [passthrough, hook.queue.dispatch];
};
function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  ctor = workInProgress.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
  workInProgress.memoizedState = getDerivedStateFromProps;
  0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
}
var classComponentUpdater = {
  isMounted: function (component) {
    return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;
  },
  enqueueSetState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
  },
  enqueueReplaceState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 1;
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
  },
  enqueueForceUpdate: function (inst, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 2;
    void 0 !== callback && null !== callback && (update.callback = callback);
    callback = enqueueUpdate(inst, update, lane);
    null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
  }
};
function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
  workInProgress = workInProgress.stateNode;
  return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
}
function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
  workInProgress = instance.state;
  "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
  "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
  }
  if (Component = Component.defaultProps) {
    newProps === baseProps && (newProps = assign({}, newProps));
    for (var propName$67 in Component) void 0 === newProps[propName$67] && (newProps[propName$67] = Component[propName$67]);
  }
  return newProps;
}
var reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
  if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
    var event = new window.ErrorEvent("error", {
      bubbles: !0,
      cancelable: !0,
      message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
      error: error
    });
    if (!window.dispatchEvent(event)) return;
  } else if ("object" === typeof process && "function" === typeof process.emit) {
    process.emit("uncaughtException", error);
    return;
  }
  console.error(error);
};
function defaultOnUncaughtError(error) {
  reportGlobalError(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError(error);
}
function logUncaughtError(root, errorInfo) {
  try {
    var onUncaughtError = root.onUncaughtError;
    onUncaughtError(errorInfo.value, {
      componentStack: errorInfo.stack
    });
  } catch (e$68) {
    setTimeout(function () {
      throw e$68;
    });
  }
}
function logCaughtError(root, boundary, errorInfo) {
  try {
    var onCaughtError = root.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
    });
  } catch (e$69) {
    setTimeout(function () {
      throw e$69;
    });
  }
}
function createRootErrorUpdate(root, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = {
    element: null
  };
  lane.callback = function () {
    logUncaughtError(root, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if ("function" === typeof getDerivedStateFromError) {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromError(error);
    };
    update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function () {
    logCaughtError(root, fiber, errorInfo);
    "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
    var stack = errorInfo.stack;
    this.componentDidCatch(errorInfo.value, {
      componentStack: null !== stack ? stack : ""
    });
  });
}
function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
  sourceFiber.flags |= 32768;
  if (null !== value && "object" === typeof value && "function" === typeof value.then) {
    returnFiber = sourceFiber.alternate;
    null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
    sourceFiber = suspenseHandlerStackCursor.current;
    if (null !== sourceFiber) {
      switch (sourceFiber.tag) {
        case 13:
          return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;
        case 22:
          return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
            transitions: null,
            markerInstances: null,
            retryQueue: new Set([value])
          }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;
      }
      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
    }
    attachPingListener(root, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return !1;
  }
  if (isHydrating) return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root = Error(formatProdErrorMessage(422), {
    cause: value
  }), queueHydrationError(createCapturedValueAtFiber(root, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
    cause: value
  }), queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), !1;
  var wrapperError = Error(formatProdErrorMessage(520), {
    cause: value
  });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
  if (null === returnFiber) return !0;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;
      case 1:
        if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;
    }
    sourceFiber = sourceFiber.return;
  } while (null !== sourceFiber);
  return !1;
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
  didReceiveUpdate = !1;
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
}
function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
  Component = Component.render;
  var ref = workInProgress.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
  } else propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress);
  nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
  key = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  isHydrating && key && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
  if (null === current) {
    var type = Component.type;
    if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current, workInProgress, type, nextProps, renderLanes);
    current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return workInProgress.child = current;
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
    var prevProps = type.memoizedProps;
    Component = Component.compare;
    Component = null !== Component ? Component : shallowEqual;
    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  workInProgress.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress.ref;
  current.return = workInProgress;
  return workInProgress.child = current;
}
function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
  if (null !== current) {
    var prevProps = current.memoizedProps;
    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
}
function updateOffscreenComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    nextChildren = nextProps.children,
    nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
    prevState = null !== current ? current.memoizedState : null;
  markRef(current, workInProgress);
  if ("hidden" === nextProps.mode || nextIsDetached) {
    if (0 !== (workInProgress.flags & 128)) {
      nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
      if (null !== current) {
        nextChildren = workInProgress.child = current.child;
        for (nextIsDetached = 0; null !== nextChildren;) nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
        workInProgress.childLanes = nextIsDetached & ~nextProps;
      } else workInProgress.childLanes = 0, workInProgress.child = null;
      return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
    }
    if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {
      baseLanes: 0,
      cachePool: null
    }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress);else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);
  } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress));
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
    parent: CacheContext._currentValue,
    pool: JSCompiler_inline_result
  };
  workInProgress.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  null !== current && pushTransition(workInProgress, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress);
  null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);
  return null;
}
function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);else {
    if ("function" !== typeof ref && "object" !== typeof ref) throw Error(formatProdErrorMessage(284));
    if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;
  }
}
function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
  prepareToReadContext(workInProgress);
  Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);
  nextProps = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, Component, renderLanes);
  return workInProgress.child;
}
function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
  prepareToReadContext(workInProgress);
  workInProgress.updateQueue = null;
  nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
  finishRenderingHooks(current);
  Component = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  isHydrating && Component && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
  prepareToReadContext(workInProgress);
  if (null === workInProgress.stateNode) {
    var context = emptyContextObject,
      contextType = Component.contextType;
    "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
    context = new Component(nextProps, context);
    workInProgress.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress.stateNode = context;
    context._reactInternals = workInProgress;
    context = workInProgress.stateNode;
    context.props = nextProps;
    context.state = workInProgress.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress);
    contextType = Component.contextType;
    context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
    context.state = workInProgress.memoizedState;
    contextType = Component.getDerivedStateFromProps;
    "function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, Component, contextType, nextProps), context.state = workInProgress.memoizedState);
    "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress, nextProps, context, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress.memoizedState);
    "function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308);
    nextProps = !0;
  } else if (null === current) {
    context = workInProgress.stateNode;
    var unresolvedOldProps = workInProgress.memoizedProps,
      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context,
      contextType$jscomp$0 = Component.contextType;
    contextType = emptyContextObject;
    "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, context, nextProps, contextType);
    hasForceUpdate = !1;
    var oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), nextProps = !1);
  } else {
    context = workInProgress.stateNode;
    cloneUpdateQueue(current, workInProgress);
    contextType = workInProgress.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress.pendingProps;
    oldState = context.context;
    oldContext = Component.contextType;
    oldProps = emptyContextObject;
    "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
    unresolvedOldProps = Component.getDerivedStateFromProps;
    (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(workInProgress, context, nextProps, oldProps);
    hasForceUpdate = !1;
    oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress.memoizedState;
    contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, contextType$jscomp$0, nextProps, oldState, newState, oldProps) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)), "function" === typeof context.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), nextProps = !1);
  }
  context = nextProps;
  markRef(current, workInProgress);
  nextProps = 0 !== (workInProgress.flags & 128);
  context || nextProps ? (context = workInProgress.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress.flags |= 1, null !== current && nextProps ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current, workInProgress, Component, renderLanes), workInProgress.memoizedState = context.state, current = workInProgress.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  return current;
}
function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
  resetHydrationState();
  workInProgress.flags |= 256;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
var SUSPENDED_MARKER = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};
function mountSuspenseOffscreenState(renderLanes) {
  return {
    baseLanes: renderLanes,
    cachePool: getSuspendedCache()
  };
}
function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
  current = null !== current ? current.childLanes & ~renderLanes : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    showFallback = !1,
    didSuspend = 0 !== (workInProgress.flags & 128),
    JSCompiler_temp;
  (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & 2));
  JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);
  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
  workInProgress.flags &= -33;
  if (null === current) {
    if (isHydrating) {
      showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);
      if (isHydrating) {
        var nextInstance = nextHydratableInstance,
          JSCompiler_temp$jscomp$0;
        if (JSCompiler_temp$jscomp$0 = nextInstance) {
          c: {
            JSCompiler_temp$jscomp$0 = nextInstance;
            for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType;) {
              if (!nextInstance) {
                nextInstance = null;
                break c;
              }
              JSCompiler_temp$jscomp$0 = getNextHydratable(JSCompiler_temp$jscomp$0.nextSibling);
              if (null === JSCompiler_temp$jscomp$0) {
                nextInstance = null;
                break c;
              }
            }
            nextInstance = JSCompiler_temp$jscomp$0;
          }
          null !== nextInstance ? (workInProgress.memoizedState = {
            dehydrated: nextInstance,
            treeContext: null !== treeContextProvider ? {
              id: treeContextId,
              overflow: treeContextOverflow
            } : null,
            retryLane: 536870912
          }, JSCompiler_temp$jscomp$0 = createFiberImplClass(18, null, null, 0), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress, workInProgress.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1;
        }
        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
      }
      nextInstance = workInProgress.memoizedState;
      if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return "$!" === nextInstance.data ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;
      popSuspenseHandler(workInProgress);
    }
    nextInstance = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({
      mode: "hidden",
      children: nextInstance
    }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
    pushPrimaryTreeSuspenseHandler(workInProgress);
    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
  }
  JSCompiler_temp$jscomp$0 = current.memoizedState;
  if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
    if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({
      mode: "visible",
      children: nextProps.children
    }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);else if (pushPrimaryTreeSuspenseHandler(workInProgress), "$!" === nextInstance.data) {
      JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({
        value: nextProps,
        source: null,
        stack: null
      });
      workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
    } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
      JSCompiler_temp = workInProgressRoot;
      if (null !== JSCompiler_temp) {
        nextProps = renderLanes & -renderLanes;
        if (0 !== (nextProps & 42)) nextProps = 1;else switch (nextProps) {
          case 2:
            nextProps = 1;
            break;
          case 8:
            nextProps = 4;
            break;
          case 32:
            nextProps = 16;
            break;
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            nextProps = 64;
            break;
          case 268435456:
            nextProps = 134217728;
            break;
          default:
            nextProps = 0;
        }
        nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps;
        if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
      }
      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
      workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
    } else "$?" === nextInstance.data ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), nextInstance._reactRetry = workInProgress, workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(nextInstance.nextSibling), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !1, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);
    return workInProgress;
  }
  if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
    mode: "hidden",
    children: nextProps.children
  }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? {
    parent: digest,
    pool: digest
  } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
    baseLanes: nextInstance.baseLanes | renderLanes,
    cachePool: JSCompiler_temp$jscomp$0
  }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
  pushPrimaryTreeSuspenseHandler(workInProgress);
  renderLanes = current.child;
  current = renderLanes.sibling;
  renderLanes = createWorkInProgress(renderLanes, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes.return = workInProgress;
  renderLanes.sibling = null;
  null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : JSCompiler_temp.push(current));
  workInProgress.child = renderLanes;
  workInProgress.memoizedState = null;
  return renderLanes;
}
function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber({
    mode: "visible",
    children: primaryChildren
  }, workInProgress.mode);
  primaryChildren.return = workInProgress;
  return workInProgress.child = primaryChildren;
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  return createFiberFromOffscreen(offscreenProps, mode, 0, null);
}
function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
  current.flags |= 2;
  workInProgress.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
  fiber.lanes |= renderLanes;
  var alternate = fiber.alternate;
  null !== alternate && (alternate.lanes |= renderLanes);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
}
function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
  var renderState = workInProgress.memoizedState;
  null === renderState ? workInProgress.memoizedState = {
    isBackwards: isBackwards,
    rendering: null,
    renderingStartTime: 0,
    last: lastContentRow,
    tail: tail,
    tailMode: tailMode
  } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
}
function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    revealOrder = nextProps.revealOrder,
    tailMode = nextProps.tail;
  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
  nextProps = suspenseStackCursor.current;
  if (0 !== (nextProps & 2)) nextProps = nextProps & 1 | 2, workInProgress.flags |= 128;else {
    if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
      if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (null !== current.child) {
        current.child.return = current;
        current = current.child;
        continue;
      }
      if (current === workInProgress) break a;
      for (; null === current.sibling;) {
        if (null === current.return || current.return === workInProgress) break a;
        current = current.return;
      }
      current.sibling.return = current.return;
      current = current.sibling;
    }
    nextProps &= 1;
  }
  push(suspenseStackCursor, nextProps);
  switch (revealOrder) {
    case "forwards":
      renderLanes = workInProgress.child;
      for (revealOrder = null; null !== renderLanes;) current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
      renderLanes = revealOrder;
      null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
      initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);
      break;
    case "backwards":
      renderLanes = null;
      revealOrder = workInProgress.child;
      for (workInProgress.child = null; null !== revealOrder;) {
        current = revealOrder.alternate;
        if (null !== current && null === findFirstSuspended(current)) {
          workInProgress.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes;
        renderLanes = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);
      break;
    case "together":
      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
      break;
    default:
      workInProgress.memoizedState = null;
  }
  return workInProgress.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  null !== current && (workInProgress.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress.lanes;
  if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {
    if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;
  } else return null;
  if (null !== current && workInProgress.child !== current.child) throw Error(formatProdErrorMessage(153));
  if (null !== workInProgress.child) {
    current = workInProgress.child;
    renderLanes = createWorkInProgress(current, current.pendingProps);
    workInProgress.child = renderLanes;
    for (renderLanes.return = workInProgress; null !== current.sibling;) current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
    renderLanes.sibling = null;
  }
  return workInProgress.child;
}
function checkScheduledUpdateOrContext(current, renderLanes) {
  if (0 !== (current.lanes & renderLanes)) return !0;
  current = current.dependencies;
  return null !== current && checkIfContextChanged(current) ? !0 : !1;
}
function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
  switch (workInProgress.tag) {
    case 3:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress);
      break;
    case 4:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
      break;
    case 13:
      var state = workInProgress.memoizedState;
      if (null !== state) {
        if (null !== state.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
        if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
        pushPrimaryTreeSuspenseHandler(workInProgress);
        current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        return null !== current ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress);
      break;
    case 19:
      var didSuspendBefore = 0 !== (current.flags & 128);
      state = 0 !== (renderLanes & workInProgress.childLanes);
      state || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), state = 0 !== (renderLanes & workInProgress.childLanes));
      if (didSuspendBefore) {
        if (state) return updateSuspenseListComponent(current, workInProgress, renderLanes);
        workInProgress.flags |= 128;
      }
      didSuspendBefore = workInProgress.memoizedState;
      null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
      push(suspenseStackCursor, suspenseStackCursor.current);
      if (state) break;else return null;
    case 22:
    case 23:
      return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
    case 24:
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
function beginWork(current, workInProgress, renderLanes) {
  if (null !== current) {
    if (current.memoizedProps !== workInProgress.pendingProps) didReceiveUpdate = !0;else {
      if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
    }
  } else didReceiveUpdate = !1, isHydrating && 0 !== (workInProgress.flags & 1048576) && pushTreeId(workInProgress, treeForkCount, workInProgress.index);
  workInProgress.lanes = 0;
  switch (workInProgress.tag) {
    case 16:
      a: {
        current = workInProgress.pendingProps;
        var lazyComponent = workInProgress.elementType,
          init = lazyComponent._init;
        lazyComponent = init(lazyComponent._payload);
        workInProgress.type = lazyComponent;
        if ("function" === typeof lazyComponent) shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress.tag = 1, workInProgress = updateClassComponent(null, workInProgress, lazyComponent, current, renderLanes)) : (workInProgress.tag = 0, workInProgress = updateFunctionComponent(null, workInProgress, lazyComponent, current, renderLanes));else {
          if (void 0 !== lazyComponent && null !== lazyComponent) if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
            workInProgress.tag = 11;
            workInProgress = updateForwardRef(null, workInProgress, lazyComponent, current, renderLanes);
            break a;
          } else if (init === REACT_MEMO_TYPE) {
            workInProgress.tag = 14;
            workInProgress = updateMemoComponent(null, workInProgress, lazyComponent, current, renderLanes);
            break a;
          }
          workInProgress = getComponentNameFromType(lazyComponent) || lazyComponent;
          throw Error(formatProdErrorMessage(306, workInProgress, ""));
        }
      }
      return workInProgress;
    case 0:
      return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
    case 1:
      return lazyComponent = workInProgress.type, init = resolveClassComponentProps(lazyComponent, workInProgress.pendingProps), updateClassComponent(current, workInProgress, lazyComponent, init, renderLanes);
    case 3:
      a: {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        if (null === current) throw Error(formatProdErrorMessage(387));
        var nextProps = workInProgress.pendingProps;
        init = workInProgress.memoizedState;
        lazyComponent = init.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, nextProps, null, renderLanes);
        var nextState = workInProgress.memoizedState;
        nextProps = nextState.cache;
        pushProvider(workInProgress, CacheContext, nextProps);
        nextProps !== init.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0);
        suspendIfUpdateReadFromEntangledAsyncAction();
        nextProps = nextState.element;
        if (init.isDehydrated) {
          if (init = {
            element: nextProps,
            isDehydrated: !1,
            cache: nextState.cache
          }, workInProgress.updateQueue.baseState = init, workInProgress.memoizedState = init, workInProgress.flags & 256) {
            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
            break a;
          } else if (nextProps !== lazyComponent) {
            lazyComponent = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), workInProgress);
            queueHydrationError(lazyComponent);
            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
            break a;
          } else for (nextHydratableInstance = getNextHydratable(workInProgress.stateNode.containerInfo.firstChild), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !0, renderLanes = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = renderLanes; renderLanes;) renderLanes.flags = renderLanes.flags & -3 | 4096, renderLanes = renderLanes.sibling;
        } else {
          resetHydrationState();
          if (nextProps === lazyComponent) {
            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            break a;
          }
          reconcileChildren(current, workInProgress, nextProps, renderLanes);
        }
        workInProgress = workInProgress.child;
      }
      return workInProgress;
    case 26:
      return markRef(current, workInProgress), null === current ? (renderLanes = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = renderLanes : isHydrating || (renderLanes = workInProgress.type, current = workInProgress.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(renderLanes), lazyComponent[internalInstanceKey] = workInProgress, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes, current), markNodeAsHoistable(lazyComponent), workInProgress.stateNode = lazyComponent) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
    case 27:
      return pushHostContext(workInProgress), null === current && isHydrating && (lazyComponent = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, rootInstanceStackCursor.current), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getNextHydratable(lazyComponent.firstChild)), lazyComponent = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, lazyComponent, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, lazyComponent, renderLanes), markRef(current, workInProgress), workInProgress.child;
    case 5:
      if (null === current && isHydrating) {
        if (init = lazyComponent = nextHydratableInstance) lazyComponent = canHydrateInstance(lazyComponent, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== lazyComponent ? (workInProgress.stateNode = lazyComponent, hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(lazyComponent.firstChild), rootOrSingletonContext = !1, init = !0) : init = !1;
        init || throwOnHydrationMismatch(workInProgress);
      }
      pushHostContext(workInProgress);
      init = workInProgress.type;
      nextProps = workInProgress.pendingProps;
      nextState = null !== current ? current.memoizedProps : null;
      lazyComponent = nextProps.children;
      shouldSetTextContent(init, nextProps) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress.flags |= 32);
      null !== workInProgress.memoizedState && (init = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), HostTransitionContext._currentValue = init);
      markRef(current, workInProgress);
      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
      return workInProgress.child;
    case 6:
      if (null === current && isHydrating) {
        if (current = renderLanes = nextHydratableInstance) renderLanes = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== renderLanes ? (workInProgress.stateNode = renderLanes, hydrationParentFiber = workInProgress, nextHydratableInstance = null, current = !0) : current = !1;
        current || throwOnHydrationMismatch(workInProgress);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case 4:
      return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), lazyComponent = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, lazyComponent, renderLanes) : reconcileChildren(current, workInProgress, lazyComponent, renderLanes), workInProgress.child;
    case 11:
      return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
    case 7:
      return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;
    case 8:
      return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
    case 12:
      return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
    case 10:
      return lazyComponent = workInProgress.pendingProps, pushProvider(workInProgress, workInProgress.type, lazyComponent.value), reconcileChildren(current, workInProgress, lazyComponent.children, renderLanes), workInProgress.child;
    case 9:
      return init = workInProgress.type._context, lazyComponent = workInProgress.pendingProps.children, prepareToReadContext(workInProgress), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, lazyComponent, renderLanes), workInProgress.child;
    case 14:
      return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
    case 15:
      return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
    case 19:
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    case 22:
      return updateOffscreenComponent(current, workInProgress, renderLanes);
    case 24:
      return prepareToReadContext(workInProgress), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, nextProps = createCache(), init.pooledCache = nextProps, nextProps.refCount++, null !== nextProps && (init.pooledCacheLanes |= renderLanes), init = nextProps), workInProgress.memoizedState = {
        parent: lazyComponent,
        cache: init
      }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, init)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, nextProps = workInProgress.memoizedState, init.parent !== lazyComponent ? (init = {
        parent: lazyComponent,
        cache: lazyComponent
      }, workInProgress.memoizedState = init, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = init), pushProvider(workInProgress, CacheContext, lazyComponent)) : (lazyComponent = nextProps.cache, pushProvider(workInProgress, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
    case 29:
      throw workInProgress.pendingProps;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
var valueCursor = createCursor(null),
  currentlyRenderingFiber = null,
  lastContextDependency = null;
function pushProvider(providerFiber, context, nextValue) {
  push(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
  for (; null !== parent;) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
    if (parent === propagationRoot) break;
    parent = parent.return;
  }
}
function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
  var fiber = workInProgress.child;
  null !== fiber && (fiber.return = workInProgress);
  for (; null !== fiber;) {
    var list = fiber.dependencies;
    if (null !== list) {
      var nextFiber = fiber.child;
      list = list.firstContext;
      a: for (; null !== list;) {
        var dependency = list;
        list = fiber;
        for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
          list.lanes |= renderLanes;
          dependency = list.alternate;
          null !== dependency && (dependency.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
          forcePropagateEntireTree || (nextFiber = null);
          break a;
        }
        list = dependency.next;
      }
    } else if (18 === fiber.tag) {
      nextFiber = fiber.return;
      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
      nextFiber.lanes |= renderLanes;
      list = nextFiber.alternate;
      null !== list && (list.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
      nextFiber = null;
    } else nextFiber = fiber.child;
    if (null !== nextFiber) nextFiber.return = fiber;else for (nextFiber = fiber; null !== nextFiber;) {
      if (nextFiber === workInProgress) {
        nextFiber = null;
        break;
      }
      fiber = nextFiber.sibling;
      if (null !== fiber) {
        fiber.return = nextFiber.return;
        nextFiber = fiber;
        break;
      }
      nextFiber = nextFiber.return;
    }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
  current = null;
  for (var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;) {
    if (!isInsidePropagationBailout) if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;else if (0 !== (parent.flags & 262144)) break;
    if (10 === parent.tag) {
      var currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent = currentParent.memoizedProps;
      if (null !== currentParent) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
    }
    parent = parent.return;
  }
  null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
  workInProgress.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
    if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0;
    currentDependencies = currentDependencies.next;
  }
  return !1;
}
function prepareToReadContext(workInProgress) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  workInProgress = workInProgress.dependencies;
  null !== workInProgress && (workInProgress.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber, context);
}
function readContextDuringReconciliation(consumer, context) {
  null === currentlyRenderingFiber && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = {
    context: context,
    memoizedValue: value,
    next: null
  };
  if (null === lastContextDependency) {
    if (null === consumer) throw Error(formatProdErrorMessage(308));
    lastContextDependency = context;
    consumer.dependencies = {
      lanes: 0,
      firstContext: context
    };
    consumer.flags |= 524288;
  } else lastContextDependency = lastContextDependency.next = context;
  return value;
}
var hasForceUpdate = !1;
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      lanes: 0,
      hiddenCallbacks: null
    },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress) {
  current = current.updateQueue;
  workInProgress.updateQueue === current && (workInProgress.updateQueue = {
    baseState: current.baseState,
    firstBaseUpdate: current.firstBaseUpdate,
    lastBaseUpdate: current.lastBaseUpdate,
    shared: current.shared,
    callbacks: null
  });
}
function createUpdate(lane) {
  return {
    lane: lane,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (null === updateQueue) return null;
  updateQueue = updateQueue.shared;
  if (0 !== (executionContext & 2)) {
    var pending = updateQueue.pending;
    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root, fiber, lane) {
  fiber = fiber.updateQueue;
  if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {
    var queueLanes = fiber.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root, lane);
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  var queue = workInProgress.updateQueue,
    current = workInProgress.alternate;
  if (null !== current && (current = current.updateQueue, queue === current)) {
    var newFirst = null,
      newLast = null;
    queue = queue.firstBaseUpdate;
    if (null !== queue) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
        queue = queue.next;
      } while (null !== queue);
      null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
    } else newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress.updateQueue = queue;
    return;
  }
  workInProgress = queue.lastBaseUpdate;
  null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
  queue.lastBaseUpdate = capturedUpdate;
}
var didReadFromEntangledAsyncAction = !1;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (null !== entangledActionThenable) throw entangledActionThenable;
  }
}
function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes) {
  didReadFromEntangledAsyncAction = !1;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = !1;
  var firstBaseUpdate = queue.firstBaseUpdate,
    lastBaseUpdate = queue.lastBaseUpdate,
    pendingQueue = queue.shared.pending;
  if (null !== pendingQueue) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue,
      firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
  }
  if (null !== firstBaseUpdate) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913,
        isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
        0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
        null !== current && (current = current.next = {
          lane: 0,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: null,
          next: null
        });
        a: {
          var workInProgress = workInProgress$jscomp$0,
            update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress = update.payload;
              if ("function" === typeof workInProgress) {
                newState = workInProgress.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress;
              break a;
            case 3:
              workInProgress.flags = workInProgress.flags & -65537 | 128;
            case 0:
              workInProgress = update.payload;
              updateLane = "function" === typeof workInProgress ? workInProgress.call(instance, newState, updateLane) : workInProgress;
              if (null === updateLane || void 0 === updateLane) break a;
              newState = assign({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = !0;
          }
        }
        updateLane = pendingQueue.callback;
        null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
      } else isHiddenUpdate = {
        lane: updateLane,
        tag: pendingQueue.tag,
        payload: pendingQueue.payload,
        callback: pendingQueue.callback,
        next: null
      }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
      pendingQueue = pendingQueue.next;
      if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
    } while (1);
    null === current && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    null === firstBaseUpdate && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if ("function" !== typeof callback) throw Error(formatProdErrorMessage(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = void 0;
          var create = updateQueue.create,
            inst = updateQueue.inst;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst,
            destroy = inst.destroy;
          if (void 0 !== destroy) {
            inst.destroy = void 0;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (null !== updateQueue) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
  instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (null !== ref) {
      var instance = current.stateNode;
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = instance;
          break;
        default:
          instanceToUse = instance;
      }
      "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var ref = current.ref,
    refCleanup = current.refCleanup;
  if (null !== ref) if ("function" === typeof refCleanup) try {
    refCleanup();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  } finally {
    current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
  } else if ("function" === typeof ref) try {
    ref(null);
  } catch (error$112) {
    captureCommitPhaseError(current, nearestMountedAncestor, error$112);
  } else ref.current = null;
}
function commitHostMount(finishedWork) {
  var type = finishedWork.type,
    props = finishedWork.memoizedProps,
    instance = finishedWork.stateNode;
  try {
    a: switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        props.autoFocus && instance.focus();
        break a;
      case "img":
        props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag || 4 === fiber.tag;
}
function getHostSibling(fiber) {
  a: for (;;) {
    for (; null === fiber.sibling;) {
      if (null === fiber.return || isHostParent(fiber.return)) return null;
      fiber = fiber.return;
    }
    fiber.sibling.return = fiber.return;
    for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 27 !== fiber.tag && 18 !== fiber.tag;) {
      if (fiber.flags & 2) continue a;
      if (null === fiber.child || 4 === fiber.tag) continue a;else fiber.child.return = fiber, fiber = fiber.child;
    }
    if (!(fiber.flags & 2)) return fiber.stateNode;
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag) node = node.stateNode, before ? 8 === parent.nodeType ? parent.parentNode.insertBefore(node, before) : parent.insertBefore(node, before) : (8 === parent.nodeType ? (before = parent.parentNode, before.insertBefore(node, parent)) : (before = parent, before.appendChild(node)), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
}
var offscreenSubtreeIsHidden = !1,
  offscreenSubtreeWasHidden = !1,
  needsFormReset = !1,
  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
  nextEffect = null,
  shouldFireAfterActiveInstanceBlur = !1;
function commitBeforeMutationEffects(root, firstChild) {
  root = root.containerInfo;
  eventsEnabled = _enabled;
  root = getActiveElementDeep(root);
  if (hasSelectionCapabilities(root)) {
    if ("selectionStart" in root) var JSCompiler_temp = {
      start: root.selectionStart,
      end: root.selectionEnd
    };else a: {
      JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;
      var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
      if (selection && 0 !== selection.rangeCount) {
        JSCompiler_temp = selection.anchorNode;
        var anchorOffset = selection.anchorOffset,
          focusNode = selection.focusNode;
        selection = selection.focusOffset;
        try {
          JSCompiler_temp.nodeType, focusNode.nodeType;
        } catch (e$20) {
          JSCompiler_temp = null;
          break a;
        }
        var length = 0,
          start = -1,
          end = -1,
          indexWithinAnchor = 0,
          indexWithinFocus = 0,
          node = root,
          parentNode = null;
        b: for (;;) {
          for (var next;;) {
            node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
            node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
            3 === node.nodeType && (length += node.nodeValue.length);
            if (null === (next = node.firstChild)) break;
            parentNode = node;
            node = next;
          }
          for (;;) {
            if (node === root) break b;
            parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
            parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
            if (null !== (next = node.nextSibling)) break;
            node = parentNode;
            parentNode = node.parentNode;
          }
          node = next;
        }
        JSCompiler_temp = -1 === start || -1 === end ? null : {
          start: start,
          end: end
        };
      } else JSCompiler_temp = null;
    }
    JSCompiler_temp = JSCompiler_temp || {
      start: 0,
      end: 0
    };
  } else JSCompiler_temp = null;
  selectionInformation = {
    focusedElem: root,
    selectionRange: JSCompiler_temp
  };
  _enabled = !1;
  for (nextEffect = firstChild; null !== nextEffect;) if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root) root.return = firstChild, nextEffect = root;else for (; null !== nextEffect;) {
    firstChild = nextEffect;
    focusNode = firstChild.alternate;
    root = firstChild.flags;
    switch (firstChild.tag) {
      case 0:
        break;
      case 11:
      case 15:
        break;
      case 1:
        if (0 !== (root & 1024) && null !== focusNode) {
          root = void 0;
          JSCompiler_temp = firstChild;
          anchorOffset = focusNode.memoizedProps;
          focusNode = focusNode.memoizedState;
          selection = JSCompiler_temp.stateNode;
          try {
            var resolvedPrevProps = resolveClassComponentProps(JSCompiler_temp.type, anchorOffset, JSCompiler_temp.elementType === JSCompiler_temp.type);
            root = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode);
            selection.__reactInternalSnapshotBeforeUpdate = root;
          } catch (error) {
            captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error);
          }
        }
        break;
      case 3:
        if (0 !== (root & 1024)) if (root = firstChild.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);else if (1 === JSCompiler_temp) switch (root.nodeName) {
          case "HEAD":
          case "HTML":
          case "BODY":
            clearContainerSparingly(root);
            break;
          default:
            root.textContent = "";
        }
        break;
      case 5:
      case 26:
      case 27:
      case 6:
      case 4:
      case 17:
        break;
      default:
        if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
    }
    root = firstChild.sibling;
    if (null !== root) {
      root.return = firstChild.return;
      nextEffect = root;
      break;
    }
    nextEffect = firstChild.return;
  }
  resolvedPrevProps = shouldFireAfterActiveInstanceBlur;
  shouldFireAfterActiveInstanceBlur = !1;
  return resolvedPrevProps;
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) try {
        finishedRoot.componentDidMount();
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      } else {
        var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
        current = current.memoizedState;
        try {
          finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
        } catch (error$111) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error$111);
        }
      }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
        finishedRoot = null;
        if (null !== finishedWork.child) switch (finishedWork.child.tag) {
          case 27:
          case 5:
            finishedRoot = finishedWork.child.stateNode;
            break;
          case 1:
            finishedRoot = finishedWork.child.stateNode;
        }
        try {
          commitCallbacks(flags, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 26:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 27:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      null === current && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      break;
    case 22:
      prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
      if (!prevProps) {
        current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevProps;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      flags & 512 && ("manual" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null,
  hostParentIsContainer = !1;
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
    injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
  } catch (err) {}
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent,
        prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode;
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      deletedFiber = deletedFiber.stateNode;
      for (nearestMountedAncestor = deletedFiber.attributes; nearestMountedAncestor.length;) deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
      detachDeletedInstance(deletedFiber);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParentIsContainer = hostParent;
      var prevHostParentIsContainer$119 = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      hostParent = prevHostParentIsContainer;
      hostParentIsContainer = prevHostParentIsContainer$119;
      if (null !== hostParent) if (hostParentIsContainer) try {
        finishedRoot = hostParent, prevHostParent = deletedFiber.stateNode, 8 === finishedRoot.nodeType ? finishedRoot.parentNode.removeChild(prevHostParent) : finishedRoot.removeChild(prevHostParent);
      } catch (error) {
        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
      } else try {
        hostParent.removeChild(deletedFiber.stateNode);
      } catch (error) {
        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
      }
      break;
    case 18:
      null !== hostParent && (hostParentIsContainer ? (nearestMountedAncestor = hostParent, deletedFiber = deletedFiber.stateNode, 8 === nearestMountedAncestor.nodeType ? clearSuspenseBoundary(nearestMountedAncestor.parentNode, deletedFiber) : 1 === nearestMountedAncestor.nodeType && clearSuspenseBoundary(nearestMountedAncestor, deletedFiber), retryIfBlockedOn(nearestMountedAncestor)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = !0;
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      break;
    case 1:
      offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      break;
    case 21:
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      break;
    case 22:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
    retryIfBlockedOn(finishedRoot);
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      return retryCache;
    case 22:
      return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
    default:
      throw Error(formatProdErrorMessage(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function (wakeable) {
    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
    retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
    var childToDelete = deletions[i],
      root = root$jscomp$0,
      returnFiber = parentFiber,
      parent = returnFiber;
    a: for (; null !== parent;) {
      switch (parent.tag) {
        case 27:
        case 5:
          hostParent = parent.stateNode;
          hostParentIsContainer = !1;
          break a;
        case 3:
          hostParent = parent.stateNode.containerInfo;
          hostParentIsContainer = !0;
          break a;
        case 4:
          hostParent = parent.stateNode.containerInfo;
          hostParentIsContainer = !0;
          break a;
      }
      parent = parent.return;
    }
    if (null === hostParent) throw Error(formatProdErrorMessage(160));
    commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
    hostParent = null;
    hostParentIsContainer = !1;
    root = childToDelete.alternate;
    null !== root && (root.return = null);
    childToDelete.return = null;
  }
  if (parentFiber.subtreeFlags & 13878) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root) {
  var current = finishedWork.alternate,
    flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = null !== current ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (null === current) {
          if (null === flags) {
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    currentResource = hoistableRoot.getElementsByTagName("title")[0];
                    if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop")) currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(currentResource, hoistableRoot.querySelector("head > title"));
                    setInitialProperties(currentResource, flags, current);
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache("link", "href", hoistableRoot).get(flags + (current.href || ""));
                    if (maybeNodes) for (var i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                      maybeNodes.splice(i, 1);
                      break b;
                    }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  case "meta":
                    if (maybeNodes = getHydratableHoistableCache("meta", "content", hoistableRoot).get(flags + (current.content || ""))) for (i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                      maybeNodes.splice(i, 1);
                      break b;
                    }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  default:
                    throw Error(formatProdErrorMessage(468, flags));
                }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
          } else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
        } else currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
      }
      break;
    case 27:
      if (flags & 4 && null === finishedWork.alternate) {
        hoistableRoot = finishedWork.stateNode;
        currentResource = finishedWork.memoizedProps;
        try {
          for (var node = hoistableRoot.firstChild; node;) {
            var nextNode = node.nextSibling,
              nodeName = node.nodeName;
            node[internalHoistableMarker] || "HEAD" === nodeName || "BODY" === nodeName || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node.rel.toLowerCase() || hoistableRoot.removeChild(node);
            node = nextNode;
          }
          for (var type = finishedWork.type, attributes = hoistableRoot.attributes; attributes.length;) hoistableRoot.removeAttributeNode(attributes[0]);
          setInitialProperties(hoistableRoot, type, currentResource);
          hoistableRoot[internalInstanceKey] = finishedWork;
          hoistableRoot[internalPropsKey] = currentResource;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    case 5:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(finishedWork, hoistableRoot, null !== current ? current.memoizedProps : hoistableRoot));
      flags & 1024 && (needsFormReset = !0);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (null === finishedWork.stateNode) throw Error(formatProdErrorMessage(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root.containerInfo);
      recursivelyTraverseMutationEffects(root, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
        retryIfBlockedOn(root.containerInfo);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
      needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 13:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      node = null !== finishedWork.memoizedState;
      nextNode = null !== current && null !== current.memoizedState;
      nodeName = offscreenSubtreeIsHidden;
      type = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = nodeName || node;
      offscreenSubtreeWasHidden = type || nextNode;
      recursivelyTraverseMutationEffects(root, finishedWork);
      offscreenSubtreeWasHidden = type;
      offscreenSubtreeIsHidden = nodeName;
      commitReconciliationEffects(finishedWork);
      root = finishedWork.stateNode;
      root._current = finishedWork;
      root._visibility &= -3;
      root._visibility |= root._pendingVisibility & 2;
      if (flags & 8192 && (root._visibility = node ? root._visibility & -2 : root._visibility | 1, node && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || nextNode || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), null === finishedWork.memoizedProps || "manual" !== finishedWork.memoizedProps.mode)) a: for (current = null, root = finishedWork;;) {
        if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
          if (null === current) {
            nextNode = current = root;
            try {
              if (hoistableRoot = nextNode.stateNode, node) currentResource = hoistableRoot.style, "function" === typeof currentResource.setProperty ? currentResource.setProperty("display", "none", "important") : currentResource.display = "none";else {
                maybeNodes = nextNode.stateNode;
                i = nextNode.memoizedProps.style;
                var display = void 0 !== i && null !== i && i.hasOwnProperty("display") ? i.display : null;
                maybeNodes.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
              }
            } catch (error) {
              captureCommitPhaseError(nextNode, nextNode.return, error);
            }
          }
        } else if (6 === root.tag) {
          if (null === current) {
            nextNode = root;
            try {
              nextNode.stateNode.nodeValue = node ? "" : nextNode.memoizedProps;
            } catch (error) {
              captureCommitPhaseError(nextNode, nextNode.return, error);
            }
          }
        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
          root.child.return = root;
          root = root.child;
          continue;
        }
        if (root === finishedWork) break a;
        for (; null === root.sibling;) {
          if (null === root.return || root.return === finishedWork) break a;
          current === root && (current = null);
          root = root.return;
        }
        current === root && (current = null);
        root.sibling.return = root.return;
        root = root.sibling;
      }
      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      if (27 !== finishedWork.tag) {
        a: {
          for (var parent = finishedWork.return; null !== parent;) {
            if (isHostParent(parent)) {
              var JSCompiler_inline_result = parent;
              break a;
            }
            parent = parent.return;
          }
          throw Error(formatProdErrorMessage(160));
        }
        switch (JSCompiler_inline_result.tag) {
          case 27:
            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
              before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
            break;
          case 5:
            var parent$113 = JSCompiler_inline_result.stateNode;
            JSCompiler_inline_result.flags & 32 && (setTextContent(parent$113, ""), JSCompiler_inline_result.flags &= -33);
            var before$114 = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before$114, parent$113);
            break;
          case 3:
          case 4:
            var parent$115 = JSCompiler_inline_result.stateNode.containerInfo,
              before$116 = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, before$116, parent$115);
            break;
          default:
            throw Error(formatProdErrorMessage(161));
        }
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
    var fiber = parentFiber;
    recursivelyResetForms(fiber);
    5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child; null !== parentFiber;) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 26:
      case 27:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        safelyDetachRef(finishedWork, finishedWork.return);
        null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
  includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
  for (parentFiber = parentFiber.child; null !== parentFiber;) {
    var current = parentFiber.alternate,
      finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        current = finishedWork;
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentDidMount) try {
          finishedRoot.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(current, current.return, error);
        }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (null !== finishedRoot) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks) for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++) callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 26:
      case 27:
      case 5:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
  if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
            id = _finishedWork$memoize2.id,
            onPostCommit = _finishedWork$memoize2.onPostCommit;
          "function" === typeof onPostCommit && onPostCommit(id, null === finishedWork.alternate ? "mount" : "update", finishedRoot.passiveEffectDuration, -0);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (_finishedWork$memoize2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
      flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
  }
}
function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
  includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
  for (parentFiber = parentFiber.child; null !== parentFiber;) {
    var finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      committedLanes = committedLanes$jscomp$0,
      committedTransitions = committedTransitions$jscomp$0,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState ? instance._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (instance._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
        includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
  if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
    var finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 22:
        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
        flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
        break;
      case 24:
        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(parentFiber) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
}
function accumulateSuspenseyCommitOnFiber(fiber) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(fiber);
      fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(fiber);
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(fiber);
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(fiber);
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
    previousFiber.child = null;
    do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber; while (null !== parentFiber);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i];
      nextEffect = childToDelete;
      commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
    }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      null !== finishedWork.memoizedState && instance._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i];
      nextEffect = childToDelete;
      commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
    }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child; null !== parentFiber;) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 4 && (i._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
  for (; null !== nextEffect;) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
          var cache = fiber.memoizedState.cachePool.pool;
          null != cache && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (null !== cache) cache.return = fiber, nextEffect = cache;else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
      cache = nextEffect;
      var sibling = cache.sibling,
        returnFiber = cache.return;
      detachFiberAfterEffects(cache);
      if (cache === fiber) {
        nextEffect = null;
        break a;
      }
      if (null !== sibling) {
        sibling.return = returnFiber;
        nextEffect = sibling;
        break a;
      }
      nextEffect = returnFiber;
    }
  }
}
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component) {
  Component = Component.prototype;
  return !(!Component || !Component.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;
  null === workInProgress ? (workInProgress = createFiberImplClass(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null);
  workInProgress.flags = current.flags & 31457280;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress.dependencies = null === pendingProps ? null : {
    lanes: pendingProps.lanes,
    firstContext: pendingProps.firstContext
  };
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;
  return workInProgress;
}
function resetWorkInProgress(workInProgress, renderLanes) {
  workInProgress.flags &= 31457282;
  var current = workInProgress.alternate;
  null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {
    lanes: renderLanes.lanes,
    firstContext: renderLanes.firstContext
  });
  return workInProgress;
}
function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
  var fiberTag = 0;
  owner = type;
  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);else if ("string" === typeof type) fiberTag = isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;else a: switch (type) {
    case REACT_FRAGMENT_TYPE:
      return createFiberFromFragment(pendingProps.children, mode, lanes, key);
    case REACT_STRICT_MODE_TYPE:
      fiberTag = 8;
      mode |= 24;
      break;
    case REACT_PROFILER_TYPE:
      return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
    case REACT_SUSPENSE_TYPE:
      return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
    case REACT_SUSPENSE_LIST_TYPE:
      return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
    case REACT_OFFSCREEN_TYPE:
      return createFiberFromOffscreen(pendingProps, mode, lanes, key);
    default:
      if ("object" === typeof type && null !== type) switch (type.$$typeof) {
        case REACT_PROVIDER_TYPE:
        case REACT_CONTEXT_TYPE:
          fiberTag = 10;
          break a;
        case REACT_CONSUMER_TYPE:
          fiberTag = 9;
          break a;
        case REACT_FORWARD_REF_TYPE:
          fiberTag = 11;
          break a;
        case REACT_MEMO_TYPE:
          fiberTag = 14;
          break a;
        case REACT_LAZY_TYPE:
          fiberTag = 16;
          owner = null;
          break a;
      }
      fiberTag = 29;
      pendingProps = Error(formatProdErrorMessage(130, null === type ? "null" : typeof type, ""));
      owner = null;
  }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  pendingProps = createFiberImplClass(22, pendingProps, key, mode);
  pendingProps.elementType = REACT_OFFSCREEN_TYPE;
  pendingProps.lanes = lanes;
  var primaryChildInstance = {
    _visibility: 1,
    _pendingVisibility: 1,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null,
    _current: null,
    detach: function () {
      var fiber = primaryChildInstance._current;
      if (null === fiber) throw Error(formatProdErrorMessage(456));
      if (0 === (primaryChildInstance._pendingVisibility & 2)) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && (primaryChildInstance._pendingVisibility |= 2, scheduleUpdateOnFiber(root, fiber, 2));
      }
    },
    attach: function () {
      var fiber = primaryChildInstance._current;
      if (null === fiber) throw Error(formatProdErrorMessage(456));
      if (0 !== (primaryChildInstance._pendingVisibility & 2)) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && (primaryChildInstance._pendingVisibility &= -3, scheduleUpdateOnFiber(root, fiber, 2));
      }
    }
  };
  pendingProps.stateNode = primaryChildInstance;
  return pendingProps;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(4, null !== portal.children ? portal.children : [], portal.key, mode);
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
function markUpdate(workInProgress) {
  workInProgress.flags |= 4;
}
function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4)) workInProgress.flags &= -16777217;else if (workInProgress.flags |= 16777216, !preloadResource(resource)) {
    resource = suspenseHandlerStackCursor.current;
    if (null !== resource && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary)) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    workInProgress.flags |= 8192;
  }
}
function scheduleRetryEffect(workInProgress, retryQueue) {
  null !== retryQueue && (workInProgress.flags |= 4);
  workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating) switch (renderState.tailMode) {
    case "hidden":
      hasRenderedATailFallback = renderState.tail;
      for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
      null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
      break;
    case "collapsed":
      lastTailNode = renderState.tail;
      for (var lastTailNode$131 = null; null !== lastTailNode;) null !== lastTailNode.alternate && (lastTailNode$131 = lastTailNode), lastTailNode = lastTailNode.sibling;
      null === lastTailNode$131 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$131.sibling = null;
  }
}
function bubbleProperties(completedWork) {
  var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child,
    newChildLanes = 0,
    subtreeFlags = 0;
  if (didBailout) for (var child$132 = completedWork.child; null !== child$132;) newChildLanes |= child$132.lanes | child$132.childLanes, subtreeFlags |= child$132.subtreeFlags & 31457280, subtreeFlags |= child$132.flags & 31457280, child$132.return = completedWork, child$132 = child$132.sibling;else for (child$132 = completedWork.child; null !== child$132;) newChildLanes |= child$132.lanes | child$132.childLanes, subtreeFlags |= child$132.subtreeFlags, subtreeFlags |= child$132.flags, child$132.return = completedWork, child$132 = child$132.sibling;
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress), null;
    case 1:
      return bubbleProperties(workInProgress), null;
    case 3:
      renderLanes = workInProgress.stateNode;
      newProps = null;
      null !== current && (newProps = current.memoizedState.cache);
      workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);
      if (null === current || null === current.child) popHydrationState(workInProgress) ? markUpdate(workInProgress) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));
      bubbleProperties(workInProgress);
      return null;
    case 26:
      return renderLanes = workInProgress.memoizedState, null === current ? (markUpdate(workInProgress), null !== renderLanes ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217)) : renderLanes ? renderLanes !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), workInProgress.flags &= -16777217), null;
    case 27:
      popHostContext(workInProgress);
      renderLanes = rootInstanceStackCursor.current;
      var type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
        if (!newProps) {
          if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(type, newProps, renderLanes), workInProgress.stateNode = current, markUpdate(workInProgress));
      }
      bubbleProperties(workInProgress);
      return null;
    case 5:
      popHostContext(workInProgress);
      renderLanes = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
        if (!newProps) {
          if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, current);else {
          type = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);
          switch (current) {
            case 1:
              current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes);
              break;
            case 2:
              current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes);
              break;
            default:
              switch (renderLanes) {
                case "svg":
                  current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes);
                  break;
                case "math":
                  current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes);
                  break;
                case "script":
                  current = type.createElement("div");
                  current.innerHTML = "<script>\x3c/script>";
                  current = current.removeChild(current.firstChild);
                  break;
                case "select":
                  current = "string" === typeof newProps.is ? type.createElement("select", {
                    is: newProps.is
                  }) : type.createElement("select");
                  newProps.multiple ? current.multiple = !0 : newProps.size && (current.size = newProps.size);
                  break;
                default:
                  current = "string" === typeof newProps.is ? type.createElement(renderLanes, {
                    is: newProps.is
                  }) : type.createElement(renderLanes);
              }
          }
          current[internalInstanceKey] = workInProgress;
          current[internalPropsKey] = newProps;
          a: for (type = workInProgress.child; null !== type;) {
            if (5 === type.tag || 6 === type.tag) current.appendChild(type.stateNode);else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
              type.child.return = type;
              type = type.child;
              continue;
            }
            if (type === workInProgress) break a;
            for (; null === type.sibling;) {
              if (null === type.return || type.return === workInProgress) break a;
              type = type.return;
            }
            type.sibling.return = type.return;
            type = type.sibling;
          }
          workInProgress.stateNode = current;
          a: switch (setInitialProperties(current, renderLanes, newProps), renderLanes) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              current = !!newProps.autoFocus;
              break a;
            case "img":
              current = !0;
              break a;
            default:
              current = !1;
          }
          current && markUpdate(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      workInProgress.flags &= -16777217;
      return null;
    case 6:
      if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
        if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress)) {
          current = workInProgress.stateNode;
          renderLanes = workInProgress.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (null !== type) switch (type.tag) {
            case 27:
            case 5:
              newProps = type.memoizedProps;
          }
          current[internalInstanceKey] = workInProgress;
          current = current.nodeValue === renderLanes || null !== newProps && !0 === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes) ? !0 : !1;
          current || throwOnHydrationMismatch(workInProgress);
        } else current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
      }
      bubbleProperties(workInProgress);
      return null;
    case 13:
      newProps = workInProgress.memoizedState;
      if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
        type = popHydrationState(workInProgress);
        if (null !== newProps && null !== newProps.dehydrated) {
          if (null === current) {
            if (!type) throw Error(formatProdErrorMessage(318));
            type = workInProgress.memoizedState;
            type = null !== type ? type.dehydrated : null;
            if (!type) throw Error(formatProdErrorMessage(317));
            type[internalInstanceKey] = workInProgress;
          } else resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4;
          bubbleProperties(workInProgress);
          type = !1;
        } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), type = !0;
        if (!type) {
          if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
      }
      popSuspenseHandler(workInProgress);
      if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, workInProgress;
      renderLanes = null !== newProps;
      current = null !== current && null !== current.memoizedState;
      if (renderLanes) {
        newProps = workInProgress.child;
        type = null;
        null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
        var cache$144 = null;
        null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$144 = newProps.memoizedState.cachePool.pool);
        cache$144 !== type && (newProps.flags |= 2048);
      }
      renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);
      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
      bubbleProperties(workInProgress);
      return null;
    case 4:
      return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
    case 10:
      return popProvider(workInProgress.type), bubbleProperties(workInProgress), null;
    case 19:
      pop(suspenseStackCursor);
      type = workInProgress.memoizedState;
      if (null === type) return bubbleProperties(workInProgress), null;
      newProps = 0 !== (workInProgress.flags & 128);
      cache$144 = type.rendering;
      if (null === cache$144) {
        if (newProps) cutOffTailIfNeeded(type, !1);else {
          if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
            cache$144 = findFirstSuspended(current);
            if (null !== cache$144) {
              workInProgress.flags |= 128;
              cutOffTailIfNeeded(type, !1);
              current = cache$144.updateQueue;
              workInProgress.updateQueue = current;
              scheduleRetryEffect(workInProgress, current);
              workInProgress.subtreeFlags = 0;
              current = renderLanes;
              for (renderLanes = workInProgress.child; null !== renderLanes;) resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;
              push(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
              return workInProgress.child;
            }
            current = current.sibling;
          }
          null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(type, !1), workInProgress.lanes = 4194304);
        }
      } else {
        if (!newProps) if (current = findFirstSuspended(cache$144), null !== current) {
          if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(type, !0), null === type.tail && "hidden" === type.tailMode && !cache$144.alternate && !isHydrating) return bubbleProperties(workInProgress), null;
        } else 2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(type, !1), workInProgress.lanes = 4194304);
        type.isBackwards ? (cache$144.sibling = workInProgress.child, workInProgress.child = cache$144) : (current = type.last, null !== current ? current.sibling = cache$144 : workInProgress.child = cache$144, type.last = cache$144);
      }
      if (null !== type.tail) return workInProgress = type.tail, type.rendering = workInProgress, type.tail = workInProgress.sibling, type.renderingStartTime = now(), workInProgress.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress;
      bubbleProperties(workInProgress);
      return null;
    case 22:
    case 23:
      return popSuspenseHandler(workInProgress), popHiddenContext(), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache), null;
    case 24:
      return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress), null;
    case 25:
      return null;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function unwindWork(current, workInProgress) {
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 1:
      return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 3:
      return popProvider(CacheContext), popHostContainer(), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress), null;
    case 13:
      popSuspenseHandler(workInProgress);
      current = workInProgress.memoizedState;
      if (null !== current && null !== current.dehydrated) {
        if (null === workInProgress.alternate) throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 19:
      return pop(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress.type), null;
    case 22:
    case 23:
      return popSuspenseHandler(workInProgress), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      null !== current && pop(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
var DefaultAsyncDispatcher = {
    getCacheForType: function (resourceType) {
      var cache = readContext(CacheContext),
        cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
      return cacheForType;
    }
  },
  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
  executionContext = 0,
  workInProgressRoot = null,
  workInProgress = null,
  workInProgressRootRenderLanes = 0,
  workInProgressSuspendedReason = 0,
  workInProgressThrownValue = null,
  workInProgressRootDidSkipSuspendedSiblings = !1,
  workInProgressRootIsPrerendering = !1,
  workInProgressRootDidAttachPingListener = !1,
  entangledRenderLanes = 0,
  workInProgressRootExitStatus = 0,
  workInProgressRootSkippedLanes = 0,
  workInProgressRootInterleavedUpdatedLanes = 0,
  workInProgressRootPingedLanes = 0,
  workInProgressDeferredLane = 0,
  workInProgressSuspendedRetryLanes = 0,
  workInProgressRootConcurrentErrors = null,
  workInProgressRootRecoverableErrors = null,
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
  globalMostRecentFallbackTime = 0,
  workInProgressRootRenderTargetTime = Infinity,
  workInProgressTransitions = null,
  legacyErrorBoundariesThatAlreadyFailed = null,
  rootDoesHavePassiveEffects = !1,
  rootWithPendingPassiveEffects = null,
  pendingPassiveEffectsLanes = 0,
  pendingPassiveEffectsRemainingLanes = 0,
  pendingPassiveTransitions = null,
  nestedUpdateCount = 0,
  rootWithNestedUpdates = null;
function requestUpdateLane() {
  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
  if (null !== ReactSharedInternals.T) {
    var actionScopeLane = currentEntangledLane;
    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
  }
  return resolveUpdatePriority();
}
function requestDeferredLane() {
  0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
  var suspenseHandler = suspenseHandlerStackCursor.current;
  null !== suspenseHandler && (suspenseHandler.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root, fiber, lane) {
  if (root === workInProgressRoot && 2 === workInProgressSuspendedReason || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
  markRootUpdated$1(root, lane);
  if (0 === (executionContext & 2) || root !== workInProgressRoot) root === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes),
    exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, !0),
    renderWasConcurrent = shouldTimeSlice;
  do {
    if (0 === exitStatus) {
      workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, !1);
      break;
    } else if (6 === exitStatus) markRootSuspended(root$jscomp$0, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);else {
      forceSync = root$jscomp$0.current.alternate;
      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
        renderWasConcurrent = !1;
        continue;
      }
      if (2 === exitStatus) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent) var JSCompiler_inline_result = 0;else JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
        if (0 !== JSCompiler_inline_result) {
          lanes = JSCompiler_inline_result;
          a: {
            var root = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
            wasRootDehydrated && (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(root, JSCompiler_inline_result, !1);
            if (2 !== JSCompiler_inline_result) {
              if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              null !== renderWasConcurrent && queueRecoverableErrors(renderWasConcurrent);
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = !1;
          if (2 !== exitStatus) continue;
        }
      }
      if (1 === exitStatus) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, !0);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        switch (exitStatus) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage(345));
          case 4:
            if ((lanes & 4194176) === lanes) {
              markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
              break a;
            }
            break;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage(329));
        }
        shouldTimeSlice.finishedWork = forceSync;
        shouldTimeSlice.finishedLanes = lanes;
        if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + 300 - now(), 10 < renderWasConcurrent)) {
          markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
          if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, 2, -0, 0), renderWasConcurrent);
          break a;
        }
        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, 0, -0, 0);
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function queueRecoverableErrors(errors) {
  null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
}
function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
  var subtreeFlags = finishedWork.subtreeFlags;
  if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) if (suspendedState = {
    stylesheets: null,
    count: 0,
    unsuspend: noop
  }, accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {
    root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, 1, completedRenderStartTime, completedRenderEndTime));
    markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
    return;
  }
  commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork;;) {
    var tag = node.tag;
    if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
      var check = tag[i],
        getSnapshot = check.getSnapshot;
      check = check.value;
      try {
        if (!objectIs(getSnapshot(), check)) return !1;
      } catch (error) {
        return !1;
      }
    }
    tag = node.child;
    if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;else {
      if (node === finishedWork) break;
      for (; null === node.sibling;) {
        if (null === node.return || node.return === finishedWork) return !0;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return !0;
}
function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root.expirationTimes;
  for (var lanes = suspendedLanes; 0 < lanes;) {
    var index$6 = 31 - clz32(lanes),
      lane = 1 << index$6;
    didAttemptEntireTree[index$6] = -1;
    lanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
}
function resetWorkInProgressStack() {
  if (null !== workInProgress) {
    if (0 === workInProgressSuspendedReason) var interruptedWork = workInProgress.return;else interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
    for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
    workInProgress = null;
  }
}
function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = 0;
  var timeoutHandle = root.timeoutHandle;
  -1 !== timeoutHandle && (root.timeoutHandle = -1, cancelTimeout(timeoutHandle));
  timeoutHandle = root.cancelPendingCommit;
  null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
  resetWorkInProgressStack();
  workInProgressRoot = root;
  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = !1;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  workInProgressRootDidAttachPingListener = !1;
  workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
  0 !== (lanes & 8) && (lanes |= lanes & 32);
  var allEntangledLanes = root.entangledLanes;
  if (0 !== allEntangledLanes) for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
    var index$4 = 31 - clz32(allEntangledLanes),
      lane = 1 << index$4;
    lanes |= root[index$4];
    allEntangledLanes &= ~lane;
  }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root, thrownValue) {
  currentlyRenderingFiber$1 = null;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
  workInProgressThrownValue = thrownValue;
  null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current)));
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals.A;
  ReactSharedInternals.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);
  0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
}
function renderRootSync(root, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) workInProgressTransitions = null, prepareFreshStack(root, lanes);
  lanes = !1;
  var exitStatus = workInProgressRootExitStatus;
  a: do try {
    if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
      var unitOfWork = workInProgress,
        thrownValue = workInProgressThrownValue;
      switch (workInProgressSuspendedReason) {
        case 8:
          resetWorkInProgressStack();
          exitStatus = 6;
          break a;
        case 3:
        case 2:
        case 6:
          null === suspenseHandlerStackCursor.current && (lanes = !0);
          var reason = workInProgressSuspendedReason;
          workInProgressSuspendedReason = 0;
          workInProgressThrownValue = null;
          throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
          if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
            exitStatus = 0;
            break a;
          }
          break;
        default:
          reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
      }
    }
    workLoopSync();
    exitStatus = workInProgressRootExitStatus;
    break;
  } catch (thrownValue$164) {
    handleThrow(root, thrownValue$164);
  } while (1);
  lanes && root.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (; null !== workInProgress;) performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  a: do try {
    if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
      lanes = workInProgress;
      var thrownValue = workInProgressThrownValue;
      b: switch (workInProgressSuspendedReason) {
        case 1:
          workInProgressSuspendedReason = 0;
          workInProgressThrownValue = null;
          throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
          break;
        case 2:
          if (isThenableResolved(thrownValue)) {
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            replaySuspendedUnitOfWork(lanes);
            break;
          }
          lanes = function () {
            2 === workInProgressSuspendedReason && workInProgressRoot === root && (workInProgressSuspendedReason = 7);
            ensureRootIsScheduled(root);
          };
          thrownValue.then(lanes, lanes);
          break a;
        case 3:
          workInProgressSuspendedReason = 7;
          break a;
        case 4:
          workInProgressSuspendedReason = 5;
          break a;
        case 7:
          isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
          break;
        case 5:
          var resource = null;
          switch (workInProgress.tag) {
            case 26:
              resource = workInProgress.memoizedState;
            case 5:
            case 27:
              var hostFiber = workInProgress;
              if (resource ? preloadResource(resource) : 1) {
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                var sibling = hostFiber.sibling;
                if (null !== sibling) workInProgress = sibling;else {
                  var returnFiber = hostFiber.return;
                  null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                }
                break b;
              }
          }
          workInProgressSuspendedReason = 0;
          workInProgressThrownValue = null;
          throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
          break;
        case 6:
          workInProgressSuspendedReason = 0;
          workInProgressThrownValue = null;
          throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
          break;
        case 8:
          resetWorkInProgressStack();
          workInProgressRootExitStatus = 6;
          break a;
        default:
          throw Error(formatProdErrorMessage(462));
      }
    }
    workLoopConcurrent();
    break;
  } catch (thrownValue$166) {
    handleThrow(root, thrownValue$166);
  } while (1);
  lastContextDependency = currentlyRenderingFiber = null;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (null !== workInProgress) return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(current, next, next.pendingProps, next.type, void 0, workInProgressRootRenderLanes);
      break;
    case 11:
      next = replayFunctionComponent(current, next, next.pendingProps, next.type.render, next.ref, workInProgressRootRenderLanes);
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
}
function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
  lastContextDependency = currentlyRenderingFiber = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState$1 = null;
  thenableIndexCounter$1 = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (null !== returnFiber) throw workInProgress = returnFiber, error;
    workInProgressRootExitStatus = 1;
    logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || 1 === suspendedReason) root = !0;else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, 2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root);
  } else completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if (0 !== (completedWork.flags & 32768)) {
      unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
    if (null !== next) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (null !== completedWork) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (null !== completedWork);
  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (null !== next) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
    if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (null !== unitOfWork);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
  var prevTransition = ReactSharedInternals.T,
    previousUpdateLanePriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 2, ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
  } finally {
    ReactSharedInternals.T = prevTransition, ReactDOMSharedInternals.p = previousUpdateLanePriority;
  }
}
function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {
  do flushPassiveEffects(); while (null !== rootWithPendingPassiveEffects);
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var finishedWork = root.finishedWork;
  didIncludeRenderPhaseUpdate = root.finishedLanes;
  if (null === finishedWork) return null;
  root.finishedWork = null;
  root.finishedLanes = 0;
  if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
  root.callbackNode = null;
  root.callbackPriority = 0;
  root.cancelPendingCommit = null;
  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
  remainingLanes |= concurrentlyUpdatedLanes;
  markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);
  root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
  0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority$1, function () {
    flushPassiveEffects(!0);
    return null;
  }));
  transitions = 0 !== (finishedWork.flags & 15990);
  0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = 2, updatedLanes = executionContext, executionContext |= 4, commitBeforeMutationEffects(root, finishedWork), commitMutationEffectsOnFiber(finishedWork, root), restoreSelection(selectionInformation, root.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, root.current = finishedWork, commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork), requestPaint(), executionContext = updatedLanes, ReactDOMSharedInternals.p = spawnedLane, ReactSharedInternals.T = transitions) : root.current = finishedWork;
  rootDoesHavePassiveEffects ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : releaseRootPooledCache(root, remainingLanes);
  remainingLanes = root.pendingLanes;
  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
  ensureRootIsScheduled(root);
  if (null !== recoverableErrors) for (renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) remainingLanes = recoverableErrors[finishedWork], renderPriorityLevel(remainingLanes.value, {
    componentStack: remainingLanes.stack
  });
  0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
  remainingLanes = root.pendingLanes;
  0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root) : nestedUpdateCount = 0;
  flushSyncWorkAcrossRoots_impl(0, !1);
  return null;
}
function releaseRootPooledCache(root, remainingLanes) {
  0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
}
function flushPassiveEffects() {
  if (null !== rootWithPendingPassiveEffects) {
    var root$170 = rootWithPendingPassiveEffects,
      remainingLanes = pendingPassiveEffectsRemainingLanes;
    pendingPassiveEffectsRemainingLanes = 0;
    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
      prevTransition = ReactSharedInternals.T,
      previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
      ReactSharedInternals.T = null;
      if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;else {
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root = rootWithPendingPassiveEffects,
          lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = 0;
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root.current);
        commitPassiveMountOnFiber(root, root.current, lanes, renderPriority);
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, !1);
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
          injectedHook.onPostCommitFiberRoot(rendererID, root);
        } catch (err) {}
        JSCompiler_inline_result = !0;
      }
      return JSCompiler_inline_result;
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root$170, remainingLanes);
    }
  }
  return !1;
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);else for (; null !== nearestMountedAncestor;) {
    if (3 === nearestMountedAncestor.tag) {
      captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
      break;
    } else if (1 === nearestMountedAncestor.tag) {
      var instance = nearestMountedAncestor.stateNode;
      if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        error = createClassErrorUpdate(2);
        instance = enqueueUpdate(nearestMountedAncestor, error, 2);
        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
        break;
      }
    }
    nearestMountedAncestor = nearestMountedAncestor.return;
  }
}
function attachPingListener(root, wakeable, lanes) {
  var pingCache = root.pingCache;
  if (null === pingCache) {
    pingCache = root.pingCache = new PossiblyWeakMap();
    var threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), root = pingSuspendedRoot.bind(null, root, wakeable, lanes), wakeable.then(root, root));
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;
  null !== pingCache && pingCache.delete(wakeable);
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
  root.warmLanes &= ~pingedLanes;
  workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  0 === retryLane && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState,
    retryLane = 0;
  null !== suspenseState && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage(314));
  }
  null !== retryCache && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
var firstScheduledRoot = null,
  lastScheduledRoot = null,
  didScheduleMicrotask = !1,
  mightHavePendingSyncWork = !1,
  isFlushingWork = !1,
  currentEventTransitionLane = 0;
function ensureRootIsScheduled(root) {
  root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
  mightHavePendingSyncWork = !0;
  didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = !0;
    do {
      var didPerformSomeWork = !1;
      for (var root$172 = firstScheduledRoot; null !== root$172;) {
        if (!onlyLegacy) if (0 !== syncTransitionLanes) {
          var pendingLanes = root$172.pendingLanes;
          if (0 === pendingLanes) var JSCompiler_inline_result = 0;else {
            var suspendedLanes = root$172.suspendedLanes,
              pingedLanes = root$172.pingedLanes;
            JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
            JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
            JSCompiler_inline_result = JSCompiler_inline_result & 201326677 ? JSCompiler_inline_result & 201326677 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
          }
          0 !== JSCompiler_inline_result && (didPerformSomeWork = !0, performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
        } else JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(root$172, root$172 === workInProgressRoot ? JSCompiler_inline_result : 0), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$172, JSCompiler_inline_result) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
        root$172 = root$172.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = !1;
  }
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = !1;
  var syncTransitionLanes = 0;
  0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
  for (var currentTime = now(), prev = null, root = firstScheduledRoot; null !== root;) {
    var next = root.next,
      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
    if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;
    root = next;
  }
  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
}
function scheduleTaskForRootDuringMicrotask(root, currentTime) {
  for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;) {
    var index$5 = 31 - clz32(lanes),
      lane = 1 << index$5,
      expirationTime = expirationTimes[index$5];
    if (-1 === expirationTime) {
      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);
  pingedLanes = root.callbackNode;
  if (0 === suspendedLanes || root === currentTime && 2 === workInProgressSuspendedReason || null !== root.cancelPendingCommit) return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
  if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root.callbackPriority) return currentTime;
    null !== pingedLanes && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root.callbackPriority = currentTime;
    root.callbackNode = suspendedLanes;
    return currentTime;
  }
  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
  root.callbackPriority = 2;
  root.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root, didTimeout) {
  var originalCallbackNode = root.callbackNode;
  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);
  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root, now());
  return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
}
function performSyncWorkOnRoot(root, lanes) {
  if (flushPassiveEffects()) return null;
  performWorkOnRoot(root, lanes, !0);
}
function scheduleImmediateTask(cb) {
  scheduleMicrotask(function () {
    0 !== (executionContext & 6) ? scheduleCallback$3(ImmediatePriority, cb) : cb();
  });
}
function requestTransitionLane() {
  0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
  if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
    var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action),
      submitter = nativeEvent.submitter;
    submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
    var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: [{
        instance: null,
        listener: function () {
          if (nativeEvent.defaultPrevented) {
            if (0 !== currentEventTransitionLane) {
              var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
              startHostTransition(maybeTargetInst, {
                pending: !0,
                data: formData,
                method: nativeEventTarget.method,
                action: action
              }, null, formData);
            }
          } else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(maybeTargetInst, {
            pending: !0,
            data: formData,
            method: nativeEventTarget.method,
            action: action
          }, action, formData));
        },
        currentTarget: nativeEventTarget
      }]
    });
  }
}
for (var i$jscomp$inline_1439 = 0; i$jscomp$inline_1439 < simpleEventPluginEvents.length; i$jscomp$inline_1439++) {
  var eventName$jscomp$inline_1440 = simpleEventPluginEvents[i$jscomp$inline_1439],
    domEventName$jscomp$inline_1441 = eventName$jscomp$inline_1440.toLowerCase(),
    capitalizedEvent$jscomp$inline_1442 = eventName$jscomp$inline_1440[0].toUpperCase() + eventName$jscomp$inline_1440.slice(1);
  registerSimpleEvent(domEventName$jscomp$inline_1441, "on" + capitalizedEvent$jscomp$inline_1442);
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
  nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = 0 !== (eventSystemFlags & 4);
  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
      event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = void 0;
      if (eventSystemFlags) for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
        var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
          instance = _dispatchListeners$i.instance,
          currentTarget = _dispatchListeners$i.currentTarget;
        _dispatchListeners$i = _dispatchListeners$i.listener;
        if (instance !== previousInstance && event.isPropagationStopped()) break a;
        previousInstance = _dispatchListeners$i;
        event.currentTarget = currentTarget;
        try {
          previousInstance(event);
        } catch (error) {
          reportGlobalError(error);
        }
        event.currentTarget = null;
        previousInstance = instance;
      } else for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
        _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
        instance = _dispatchListeners$i.instance;
        currentTarget = _dispatchListeners$i.currentTarget;
        _dispatchListeners$i = _dispatchListeners$i.listener;
        if (instance !== previousInstance && event.isPropagationStopped()) break a;
        previousInstance = _dispatchListeners$i;
        event.currentTarget = currentTarget;
        try {
          previousInstance(event);
        } catch (error) {
          reportGlobalError(error);
        }
        event.currentTarget = null;
        previousInstance = instance;
      }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set());
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, !1), JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = !0;
    allNativeEvents.forEach(function (domEventName) {
      "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));
    });
    var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, ownerDocument));
  }
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
  listenerWrapper = void 0;
  !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = !0);
  isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
    capture: !0,
    passive: listenerWrapper
  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !0) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
    passive: listenerWrapper
  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
}
function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
  var ancestorInst = targetInst$jscomp$0;
  if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for (;;) {
    if (null === targetInst$jscomp$0) return;
    var nodeTag = targetInst$jscomp$0.tag;
    if (3 === nodeTag || 4 === nodeTag) {
      var container = targetInst$jscomp$0.stateNode.containerInfo;
      if (container === targetContainer || 8 === container.nodeType && container.parentNode === targetContainer) break;
      if (4 === nodeTag) for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag;) {
        var grandTag = nodeTag.tag;
        if (3 === grandTag || 4 === grandTag) if (grandTag = nodeTag.stateNode.containerInfo, grandTag === targetContainer || 8 === grandTag.nodeType && grandTag.parentNode === targetContainer) return;
        nodeTag = nodeTag.return;
      }
      for (; null !== container;) {
        nodeTag = getClosestInstanceFromNode(container);
        if (null === nodeTag) return;
        grandTag = nodeTag.tag;
        if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
          targetInst$jscomp$0 = ancestorInst = nodeTag;
          continue a;
        }
        container = container.parentNode;
      }
    }
    targetInst$jscomp$0 = targetInst$jscomp$0.return;
  }
  batchedUpdates$1(function () {
    var targetInst = ancestorInst,
      nativeEventTarget = getEventTarget(nativeEvent),
      dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (void 0 !== reactName) {
        var SyntheticEventCtor = SyntheticEvent,
          reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = 0 !== (eventSystemFlags & 4),
          accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName),
          reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
        inCapturePhase = [];
        for (var instance = targetInst, lastHostComponent; null !== instance;) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(createDispatchListener(instance, _instance, lastHostComponent)));
          if (accumulateTargetOnly) break;
          instance = instance.return;
        }
        0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
          event: reactName,
          listeners: inCapturePhase
        }));
      }
    }
    if (0 === (eventSystemFlags & 7)) {
      a: {
        reactName = "mouseover" === domEventName || "pointerover" === domEventName;
        SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
        if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
        if (SyntheticEventCtor || reactName) {
          reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
          if (SyntheticEventCtor) {
            if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
          } else SyntheticEventCtor = null, reactEventType = targetInst;
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
            accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(_instance, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType) b: {
              inCapturePhase = SyntheticEventCtor;
              reactEventName = reactEventType;
              instance = 0;
              for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent)) instance++;
              lastHostComponent = 0;
              for (_instance = reactEventName; _instance; _instance = getParent(_instance)) lastHostComponent++;
              for (; 0 < instance - lastHostComponent;) inCapturePhase = getParent(inCapturePhase), instance--;
              for (; 0 < lastHostComponent - instance;) reactEventName = getParent(reactEventName), lastHostComponent--;
              for (; instance--;) {
                if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate) break b;
                inCapturePhase = getParent(inCapturePhase);
                reactEventName = getParent(reactEventName);
              }
              inCapturePhase = null;
            } else inCapturePhase = null;
            null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);
            null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
        if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;else if (isTextInputElement(reactName)) {
          if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
        if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
          createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = !1;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent) break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent) b: {
        switch (domEventName) {
          case "compositionstart":
            var eventType = "onCompositionStart";
            break b;
          case "compositionend":
            eventType = "onCompositionEnd";
            break b;
          case "compositionupdate":
            eventType = "onCompositionUpdate";
            break b;
        }
        eventType = void 0;
      } else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
      eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = !0)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
        event: eventType,
        listeners: handleEventFunc
      }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
      if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
        event: handleEventFunc,
        listeners: eventType
      }), handleEventFunc.data = fallbackData);
      extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber;) {
    var _instance2 = targetFiber,
      stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(createDispatchListener(targetFiber, _instance2, stateNode)));
    targetFiber = targetFiber.return;
  }
  return listeners;
}
function getParent(inst) {
  if (null === inst) return null;
  do inst = inst.return; while (inst && 5 !== inst.tag && 27 !== inst.tag);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  for (var registrationName = event._reactName, listeners = []; null !== target && target !== common;) {
    var _instance3 = target,
      alternate = _instance3.alternate,
      stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (null !== alternate && alternate === common) break;
    5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
    target = target.return;
  }
  0 !== listeners.length && dispatchQueue.push({
    event: event,
    listeners: listeners
  });
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(markup) {
  return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
}
function noop$1() {}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if ("object" !== tag) {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if ("" === value && ("a" !== tag || "href" !== key)) {
        domElement.removeAttribute(key);
        break;
      }
      if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if ("function" === typeof value) {
        domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
        break;
      } else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
      if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "muted":
      domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", key);
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      !0 === value ? domElement.setAttribute(key, "") : !1 !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:actuate", value);
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:arcrole", value);
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:role", value);
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:show", value);
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:title", value);
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:type", value);
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:base", value);
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:lang", value);
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:space", value);
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1]) key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key)) a: {
        if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
          "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
          domElement.addEventListener(tag, value, props);
          break a;
        }
        key in domElement ? domElement[key] = value : !0 === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
      }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = !1,
        hasSrcSet = !1,
        propKey;
      for (propKey in props) if (props.hasOwnProperty(propKey)) {
        var propValue = props[propKey];
        if (null != propValue) switch (propKey) {
          case "src":
            hasSrc = !0;
            break;
          case "srcSet":
            hasSrcSet = !0;
            break;
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(formatProdErrorMessage(137, tag));
          default:
            setProp(domElement, tag, propKey, propValue, props, null);
        }
      }
      hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = propKey = propValue = hasSrcSet = null,
        checked = null,
        defaultChecked = null;
      for (hasSrc in props) if (props.hasOwnProperty(hasSrc)) {
        var propValue$186 = props[hasSrc];
        if (null != propValue$186) switch (hasSrc) {
          case "name":
            hasSrcSet = propValue$186;
            break;
          case "type":
            propValue = propValue$186;
            break;
          case "checked":
            checked = propValue$186;
            break;
          case "defaultChecked":
            defaultChecked = propValue$186;
            break;
          case "value":
            propKey = propValue$186;
            break;
          case "defaultValue":
            defaultValue = propValue$186;
            break;
          case "children":
          case "dangerouslySetInnerHTML":
            if (null != propValue$186) throw Error(formatProdErrorMessage(137, tag));
            break;
          default:
            setProp(domElement, tag, hasSrc, propValue$186, props, null);
        }
      }
      initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1);
      track(domElement);
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props) if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch (hasSrcSet) {
        case "value":
          propKey = defaultValue;
          break;
        case "defaultValue":
          propValue = defaultValue;
          break;
        case "multiple":
          hasSrc = defaultValue;
        default:
          setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
      }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      null != tag ? updateOptions(domElement, !!hasSrc, tag, !1) : null != props && updateOptions(domElement, !!hasSrc, props, !0);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props) if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch (propValue) {
        case "value":
          hasSrc = defaultValue;
          break;
        case "defaultValue":
          hasSrcSet = defaultValue;
          break;
        case "children":
          propKey = defaultValue;
          break;
        case "dangerouslySetInnerHTML":
          if (null != defaultValue) throw Error(formatProdErrorMessage(91));
          break;
        default:
          setProp(domElement, tag, propValue, defaultValue, props, null);
      }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      track(domElement);
      return;
    case "option":
      for (checked in props) if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch (checked) {
        case "selected":
          domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
          break;
        default:
          setProp(domElement, tag, checked, hasSrc, props, null);
      }
      return;
    case "dialog":
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props) if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch (defaultChecked) {
        case "children":
        case "dangerouslySetInnerHTML":
          throw Error(formatProdErrorMessage(137, tag));
        default:
          setProp(domElement, tag, defaultChecked, hasSrc, props, null);
      }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$186 in props) props.hasOwnProperty(propValue$186) && (hasSrc = props[propValue$186], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, propValue$186, hasSrc, props, void 0));
        return;
      }
  }
  for (defaultValue in props) props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null,
        type = null,
        value = null,
        defaultValue = null,
        lastDefaultValue = null,
        checked = null,
        defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch (propKey) {
          case "checked":
            break;
          case "value":
            break;
          case "defaultValue":
            lastDefaultValue = lastProp;
          default:
            nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
        }
      }
      for (var propKey$203 in nextProps) {
        var propKey = nextProps[propKey$203];
        lastProp = lastProps[propKey$203];
        if (nextProps.hasOwnProperty(propKey$203) && (null != propKey || null != lastProp)) switch (propKey$203) {
          case "type":
            type = propKey;
            break;
          case "name":
            name = propKey;
            break;
          case "checked":
            checked = propKey;
            break;
          case "defaultChecked":
            defaultChecked = propKey;
            break;
          case "value":
            value = propKey;
            break;
          case "defaultValue":
            defaultValue = propKey;
            break;
          case "children":
          case "dangerouslySetInnerHTML":
            if (null != propKey) throw Error(formatProdErrorMessage(137, tag));
            break;
          default:
            propKey !== lastProp && setProp(domElement, tag, propKey$203, propKey, nextProps, lastProp);
        }
      }
      updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
      return;
    case "select":
      propKey = value = defaultValue = propKey$203 = null;
      for (type in lastProps) if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch (type) {
        case "value":
          break;
        case "multiple":
          propKey = lastDefaultValue;
        default:
          nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
      }
      for (name in nextProps) if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch (name) {
        case "value":
          propKey$203 = type;
          break;
        case "defaultValue":
          defaultValue = type;
          break;
        case "multiple":
          value = type;
        default:
          type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
      }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      null != propKey$203 ? updateOptions(domElement, !!lastProps, propKey$203, !1) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, !0) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
      return;
    case "textarea":
      propKey = propKey$203 = null;
      for (defaultValue in lastProps) if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch (defaultValue) {
        case "value":
          break;
        case "children":
          break;
        default:
          setProp(domElement, tag, defaultValue, null, nextProps, name);
      }
      for (value in nextProps) if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch (value) {
        case "value":
          propKey$203 = name;
          break;
        case "defaultValue":
          propKey = name;
          break;
        case "children":
          break;
        case "dangerouslySetInnerHTML":
          if (null != name) throw Error(formatProdErrorMessage(91));
          break;
        default:
          name !== type && setProp(domElement, tag, value, name, nextProps, type);
      }
      updateTextarea(domElement, propKey$203, propKey);
      return;
    case "option":
      for (var propKey$219 in lastProps) if (propKey$203 = lastProps[propKey$219], lastProps.hasOwnProperty(propKey$219) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$219)) switch (propKey$219) {
        case "selected":
          domElement.selected = !1;
          break;
        default:
          setProp(domElement, tag, propKey$219, null, nextProps, propKey$203);
      }
      for (lastDefaultValue in nextProps) if (propKey$203 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$203 !== propKey && (null != propKey$203 || null != propKey)) switch (lastDefaultValue) {
        case "selected":
          domElement.selected = propKey$203 && "function" !== typeof propKey$203 && "symbol" !== typeof propKey$203;
          break;
        default:
          setProp(domElement, tag, lastDefaultValue, propKey$203, nextProps, propKey);
      }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$224 in lastProps) propKey$203 = lastProps[propKey$224], lastProps.hasOwnProperty(propKey$224) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$224) && setProp(domElement, tag, propKey$224, null, nextProps, propKey$203);
      for (checked in nextProps) if (propKey$203 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$203 !== propKey && (null != propKey$203 || null != propKey)) switch (checked) {
        case "children":
        case "dangerouslySetInnerHTML":
          if (null != propKey$203) throw Error(formatProdErrorMessage(137, tag));
          break;
        default:
          setProp(domElement, tag, checked, propKey$203, nextProps, propKey);
      }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$229 in lastProps) propKey$203 = lastProps[propKey$229], lastProps.hasOwnProperty(propKey$229) && void 0 !== propKey$203 && !nextProps.hasOwnProperty(propKey$229) && setPropOnCustomElement(domElement, tag, propKey$229, void 0, nextProps, propKey$203);
        for (defaultChecked in nextProps) propKey$203 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$203 === propKey || void 0 === propKey$203 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, propKey$203, nextProps, propKey);
        return;
      }
  }
  for (var propKey$234 in lastProps) propKey$203 = lastProps[propKey$234], lastProps.hasOwnProperty(propKey$234) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$234) && setProp(domElement, tag, propKey$234, null, nextProps, propKey$203);
  for (lastProp in nextProps) propKey$203 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$203 === propKey || null == propKey$203 && null == propKey || setProp(domElement, tag, lastProp, propKey$203, nextProps, propKey);
}
var eventsEnabled = null,
  selectionInformation = null;
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (0 === parentNamespace) switch (type) {
    case "svg":
      return 1;
    case "math":
      return 2;
    default:
      return 0;
  }
  return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && "popstate" === event.type) {
    if (event === currentPopstateTransitionEvent) return !1;
    currentPopstateTransitionEvent = event;
    return !0;
  }
  currentPopstateTransitionEvent = null;
  return !1;
}
var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
  localPromise = "function" === typeof Promise ? Promise : void 0,
  scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function (callback) {
    return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
  } : scheduleTimeout;
function handleErrorInNextTick(error) {
  setTimeout(function () {
    throw error;
  });
}
function clearSuspenseBoundary(parentInstance, suspenseInstance) {
  var node = suspenseInstance,
    depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, "/$" === node) {
      if (0 === depth) {
        parentInstance.removeChild(nextNode);
        retryIfBlockedOn(suspenseInstance);
        return;
      }
      depth--;
    } else "$" !== node && "$?" !== node && "$!" !== node || depth++;
    node = nextNode;
  } while (node);
  retryIfBlockedOn(suspenseInstance);
}
function clearContainerSparingly(container) {
  var nextNode = container.firstChild;
  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
  for (; nextNode;) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if ("stylesheet" === node.rel.toLowerCase()) continue;
    }
    container.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (; 1 === instance.nodeType;) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
    } else if (!inRootOrSingleton) {
      if ("input" === type && "hidden" === instance.type) {
        var name = null == anyProps.name ? null : "" + anyProps.name;
        if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
      } else return instance;
    } else if (!instance[internalHoistableMarker]) switch (type) {
      case "meta":
        if (!instance.hasAttribute("itemprop")) break;
        return instance;
      case "link":
        name = instance.getAttribute("rel");
        if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
        return instance;
      case "style":
        if (instance.hasAttribute("data-precedence")) break;
        return instance;
      case "script":
        name = instance.getAttribute("src");
        if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
        return instance;
      default:
        return instance;
    }
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if ("" === text) return null;
  for (; 3 !== instance.nodeType;) {
    if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function getNextHydratable(node) {
  for (; null != node; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (1 === nodeType || 3 === nodeType) break;
    if (8 === nodeType) {
      nodeType = node.data;
      if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType) break;
      if ("/$" === nodeType) return null;
    }
  }
  return node;
}
function getParentSuspenseInstance(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0; targetInstance;) {
    if (8 === targetInstance.nodeType) {
      var data = targetInstance.data;
      if ("$" === data || "$!" === data || "$?" === data) {
        if (0 === depth) return targetInstance;
        depth--;
      } else "/$" === data && depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type) throw Error(formatProdErrorMessage(452));
      return type;
    case "head":
      type = props.head;
      if (!type) throw Error(formatProdErrorMessage(453));
      return type;
    case "body":
      type = props.body;
      if (!type) throw Error(formatProdErrorMessage(454));
      return type;
    default:
      throw Error(formatProdErrorMessage(451));
  }
}
var preloadPropsMap = new Map(),
  preconnectsSet = new Set();
function getHoistableRoot(container) {
  return "function" === typeof container.getRootNode ? container.getRootNode() : container.ownerDocument;
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
  f: flushSyncWork,
  r: requestFormReset,
  D: prefetchDNS,
  C: preconnect,
  L: preload,
  m: preloadModule,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(),
    wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
}
var globalDocument = "undefined" === typeof document ? null : document;
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && "string" === typeof href && href) {
    var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {
      rel: rel,
      crossOrigin: crossOrigin,
      href: href
    }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
    "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) || (href = assign({
      rel: "preload",
      href: "image" === as && options && options.imageSrcSet ? void 0 : href,
      as: as
    }, options), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && "string" === typeof options.as ? options.as : "script",
      preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]',
      key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (!preloadPropsMap.has(key) && (href = assign({
      rel: "modulepreload",
      href: href
    }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
      key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = {
        loading: 0,
        preload: null
      };
      if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = 5;else {
        href = assign({
          rel: "stylesheet",
          href: href,
          "data-precedence": precedence
        }, options);
        (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
        var link = resource = ownerDocument.createElement("link");
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function (resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function () {
          state.loading |= 1;
        });
        link.addEventListener("error", function () {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state: state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
      src: src,
      async: !0
    }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
      type: "script",
      instance: resource,
      count: 1,
      state: null
    }, scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
      src: src,
      async: !0,
      type: "module"
    }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
      type: "script",
      instance: resource,
      count: 1,
      state: null
    }, scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
        type: "style",
        instance: null,
        count: 0,
        state: null
      }, pendingProps.set(currentProps, currentResource)), currentResource) : {
        type: "void",
        instance: null,
        count: 0,
        state: null
      };
    case "link":
      if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
        type = getStyleKey(pendingProps.href);
        var styles$242 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles,
          resource$243 = styles$242.get(type);
        resource$243 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$243 = {
          type: "stylesheet",
          instance: null,
          count: 0,
          state: {
            loading: 0,
            preload: null
          }
        }, styles$242.set(type, resource$243), (styles$242 = JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type))) && !styles$242._p && (resource$243.instance = styles$242, resource$243.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
          rel: "preload",
          as: "style",
          href: pendingProps.href,
          crossOrigin: pendingProps.crossOrigin,
          integrity: pendingProps.integrity,
          media: pendingProps.media,
          hrefLang: pendingProps.hrefLang,
          referrerPolicy: pendingProps.referrerPolicy
        }, preloadPropsMap.set(type, pendingProps), styles$242 || preloadStylesheet(JSCompiler_inline_result, type, pendingProps, resource$243.state)));
        if (currentProps && null === currentResource) throw Error(formatProdErrorMessage(528, ""));
        return resource$243;
      }
      if (currentProps && null !== currentResource) throw Error(formatProdErrorMessage(529, ""));
      return null;
    case "script":
      return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
        type: "script",
        instance: null,
        count: 0,
        state: null
      }, pendingProps.set(currentProps, currentResource)), currentResource) : {
        type: "void",
        instance: null,
        count: 0,
        state: null
      };
    default:
      throw Error(formatProdErrorMessage(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function () {
    return state.loading |= 1;
  }), key.addEventListener("error", function () {
    return state.loading |= 2;
  }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (null === resource.instance) switch (resource.type) {
    case "style":
      var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
      if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
      var styleProps = assign({}, props, {
        "data-href": props.href,
        "data-precedence": props.precedence,
        href: null,
        precedence: null
      });
      instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
      markNodeAsHoistable(instance);
      setInitialProperties(instance, "style", styleProps);
      insertStylesheet(instance, props.precedence, hoistableRoot);
      return resource.instance = instance;
    case "stylesheet":
      styleProps = getStyleKey(props.href);
      var instance$248 = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
      if (instance$248) return resource.state.loading |= 4, resource.instance = instance$248, markNodeAsHoistable(instance$248), instance$248;
      instance = stylesheetPropsFromRawProps(props);
      (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
      instance$248 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
      markNodeAsHoistable(instance$248);
      var linkInstance = instance$248;
      linkInstance._p = new Promise(function (resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance$248, "link", instance);
      resource.state.loading |= 4;
      insertStylesheet(instance$248, props.precedence, hoistableRoot);
      return resource.instance = instance$248;
    case "script":
      instance$248 = getScriptKey(props.src);
      if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$248))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
      instance = props;
      if (styleProps = preloadPropsMap.get(instance$248)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      styleProps = hoistableRoot.createElement("script");
      markNodeAsHoistable(styleProps);
      setInitialProperties(styleProps, "link", instance);
      hoistableRoot.head.appendChild(styleProps);
      return resource.instance = styleProps;
    case "void":
      return null;
    default:
      throw Error(formatProdErrorMessage(443, resource.type));
  } else "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root) {
  for (var nodes = root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence) prior = node;else if (prior !== last) break;
  }
  prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
  null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
}
var tagCaches = null;
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (null === tagCaches) {
    var cache = new Map();
    var caches = tagCaches = new Map();
    caches.set(ownerDocument, cache);
  } else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));
  if (cache.has(type)) return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0; caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
}
function isHostHoistableType(type, props, hostContext) {
  if (1 === hostContext || null != props.itemProp) return !1;
  switch (type) {
    case "meta":
    case "title":
      return !0;
    case "style":
      if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) break;
      return !0;
    case "link":
      if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) break;
      switch (props.rel) {
        case "stylesheet":
          return type = props.disabled, "string" === typeof props.precedence && null == type;
        default:
          return !0;
      }
    case "script":
      if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src) return !0;
  }
  return !1;
}
function preloadResource(resource) {
  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? !1 : !0;
}
var suspendedState = null;
function noop() {}
function suspendResource(hoistableRoot, resource, props) {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  if ("stylesheet" === resource.type && ("string" !== typeof props.media || !1 !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
    if (null === resource.instance) {
      var key = getStyleKey(props.href),
        instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
      if (instance) {
        hoistableRoot = instance._p;
        null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function (resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    null === state.stylesheets && (state.stylesheets = new Map());
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
  }
}
function waitForCommitToBeReady() {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count ? function (commit) {
    var stylesheetTimer = setTimeout(function () {
      state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
      if (state.unsuspend) {
        var unsuspend = state.unsuspend;
        state.unsuspend = null;
        unsuspend();
      }
    }, 6e4);
    state.unsuspend = commit;
    return function () {
      state.unsuspend = null;
      clearTimeout(stylesheetTimer);
    };
  } : null;
}
function onUnsuspend() {
  this.count--;
  if (0 === this.count) if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);else if (this.unsuspend) {
    var unsuspend = this.unsuspend;
    this.unsuspend = null;
    unsuspend();
  }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root);
    if (precedences) var last = precedences.get(null);else {
      precedences = new Map();
      precedencesByRoot.set(root, precedences);
      for (var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));
    resource.state.loading |= 4;
  }
}
var HostTransitionContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Provider: null,
  Consumer: null,
  _currentValue: sharedNotPendingObject,
  _currentValue2: sharedNotPendingObject,
  _threadCount: 0
};
function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = new Map();
}
function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
  containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
  tag = 1;
  !0 === isStrictMode && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
  parentComponent = getContextForSubtree(parentComponent);
  null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
  container = createUpdate(lane);
  container.payload = {
    element: element
  };
  callback = void 0 === callback ? null : callback;
  null !== callback && (container.callback = callback);
  element = enqueueUpdate(rootFiber, container, lane);
  null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (null !== fiber && null !== fiber.dehydrated) {
    var a = fiber.retryLane;
    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (13 === fiber.tag) {
    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
var _enabled = !0;
function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
  }
}
function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
  }
}
function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
      for (; null !== blockedOn;) {
        var fiber = getInstanceFromNode(blockedOn);
        if (null !== fiber) switch (fiber.tag) {
          case 3:
            fiber = fiber.stateNode;
            if (fiber.current.memoizedState.isDehydrated) {
              var lanes = getHighestPriorityLanes(fiber.pendingLanes);
              if (0 !== lanes) {
                var root = fiber;
                root.pendingLanes |= 2;
                for (root.entangledLanes |= 2; lanes;) {
                  var lane = 1 << 31 - clz32(lanes);
                  root.entanglements[1] |= lane;
                  lanes &= ~lane;
                }
                ensureRootIsScheduled(fiber);
                0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, !1));
              }
            }
            break;
          case 13:
            root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
        }
        fiber = findInstanceBlockingEvent(nativeEvent);
        null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
        if (fiber === blockedOn) break;
        blockedOn = fiber;
      }
      null !== blockedOn && nativeEvent.stopPropagation();
    } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (null !== targetNode) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (null === nearestMounted) targetNode = null;else {
      var tag = nearestMounted.tag;
      if (13 === tag) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (3 === tag) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
        targetNode = null;
      } else nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var hasScheduledReplayAttempt = !1,
  queuedFocus = null,
  queuedDrag = null,
  queuedMouse = null,
  queuedPointers = new Map(),
  queuedPointerCaptures = new Map(),
  queuedExplicitHydrationTargets = [],
  discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
    blockedOn: blockedOn,
    domEventName: domEventName,
    eventSystemFlags: eventSystemFlags,
    nativeEvent: nativeEvent,
    targetContainers: [targetContainer]
  }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  switch (domEventName) {
    case "focusin":
      return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
    case "dragenter":
      return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
    case "mouseover":
      return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
      return !0;
    case "gotpointercapture":
      return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), !0;
  }
  return !1;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (null !== targetInst) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (null !== nearestMounted) if (targetInst = nearestMounted.tag, 13 === targetInst) {
      if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
        queuedTarget.blockedOn = targetInst;
        runWithPriority(queuedTarget.priority, function () {
          if (13 === nearestMounted.tag) {
            var lane = requestUpdateLane(),
              root = enqueueConcurrentRenderForLane(nearestMounted, lane);
            null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
            markRetryLaneIfNotHydrated(nearestMounted, lane);
          }
        });
        return;
      }
    } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
      queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
      return;
    }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (null !== queuedEvent.blockedOn) return !1;
  for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (null === nextBlockedOn) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn);
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, !1;
    targetContainers.shift();
  }
  return !0;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = !1;
  null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
  null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
  null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function () {
    lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
    for (var i = 0; i < formReplayingQueue.length; i += 3) {
      var form = formReplayingQueue[i],
        submitterOrAction = formReplayingQueue[i + 1],
        formData = formReplayingQueue[i + 2];
      if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;else break;
      var formInst = getInstanceFromNode(form);
      null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(formInst, {
        pending: !0,
        data: formData,
        method: form.method,
        action: submitterOrAction
      }, submitterOrAction, formData));
    }
  }));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);) attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (null != i) for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
    var form = i[queuedTarget],
      submitterOrAction = i[queuedTarget + 1],
      formProps = form[internalPropsKey] || null;
    if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);else if (formProps) {
      var action = null;
      if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) {
        if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;else {
          if (null !== findInstanceBlockingTarget(form)) continue;
        }
      } else action = formProps.action;
      "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
      scheduleReplayQueueIfNeeded(i);
    }
  }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (children) {
  var root = this._internalRoot;
  if (null === root) throw Error(formatProdErrorMessage(409));
  var current = root.current,
    lane = requestUpdateLane();
  updateContainerImpl(current, lane, children, root, null, null);
};
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function () {
  var root = this._internalRoot;
  if (null !== root) {
    this._internalRoot = null;
    var container = root.containerInfo;
    0 === root.tag && flushPassiveEffects();
    updateContainerImpl(root.current, 2, null, root, null, null);
    flushSyncWork$1();
    container[internalContainerInstanceKey] = null;
  }
};
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
  if (target) {
    var updatePriority = resolveUpdatePriority();
    target = {
      blockedOn: null,
      target: target,
      priority: updatePriority
    };
    for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
    queuedExplicitHydrationTargets.splice(i, 0, target);
    0 === i && attemptExplicitHydrationTarget(target);
  }
};
var isomorphicReactPackageVersion$jscomp$inline_1686 = React.version;
if ("19.0.0" !== isomorphicReactPackageVersion$jscomp$inline_1686) throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1686, "19.0.0"));
ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
  var fiber = componentOrElement._reactInternals;
  if (void 0 === fiber) {
    if ("function" === typeof componentOrElement.render) throw Error(formatProdErrorMessage(188));
    componentOrElement = Object.keys(componentOrElement).join(",");
    throw Error(formatProdErrorMessage(268, componentOrElement));
  }
  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
  componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
  componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
  return componentOrElement;
};
var internals$jscomp$inline_2165 = {
  bundleType: 0,
  version: "19.0.0",
  rendererPackageName: "react-dom",
  currentDispatcherRef: ReactSharedInternals,
  findFiberByHostInstance: getClosestInstanceFromNode,
  reconcilerVersion: "19.0.0"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!hook$jscomp$inline_2166.isDisabled && hook$jscomp$inline_2166.supportsFiber) try {
    rendererID = hook$jscomp$inline_2166.inject(internals$jscomp$inline_2165), injectedHook = hook$jscomp$inline_2166;
  } catch (err) {}
}
exports.createRoot = function (container, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    transitionCallbacks = null;
  null !== options && void 0 !== options && (!0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
  options = createFiberRoot(container, 1, !1, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
  container[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(8 === container.nodeType ? container.parentNode : container);
  return new ReactDOMRoot(options);
};
__webpack_unused_export__ = function (container, initialChildren, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    transitionCallbacks = null,
    formState = null;
  null !== options && void 0 !== options && (!0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
  initialChildren = createFiberRoot(container, 1, !0, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  initialChildren.current.lanes = isStrictMode;
  markRootUpdated$1(initialChildren, isStrictMode);
  ensureRootIsScheduled(initialChildren);
  container[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMHydrationRoot(initialChildren);
};
__webpack_unused_export__ = "19.0.0";

/***/ }),

/***/ 672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var React = __webpack_require__(43);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function noop() {}
var Internals = {
    d: {
      f: noop,
      r: function () {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  },
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
function createPortal$1(children, containerInfo, implementation) {
  var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: null == key ? null : "" + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}
var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(as, input) {
  if ("font" === as) return "";
  if ("string" === typeof input) return "use-credentials" === input ? input : "";
}
exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
exports.createPortal = function (children, container) {
  var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
};
exports.flushSync = function (fn) {
  var previousTransition = ReactSharedInternals.T,
    previousUpdatePriority = Internals.p;
  try {
    if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
  } finally {
    ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
  }
};
exports.preconnect = function (href, options) {
  "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
};
exports.prefetchDNS = function (href) {
  "string" === typeof href && Internals.d.D(href);
};
exports.preinit = function (href, options) {
  if ("string" === typeof href && options && "string" === typeof options.as) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
      integrity = "string" === typeof options.integrity ? options.integrity : void 0,
      fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
    "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : void 0, {
      crossOrigin: crossOrigin,
      integrity: integrity,
      fetchPriority: fetchPriority
    }) : "script" === as && Internals.d.X(href, {
      crossOrigin: crossOrigin,
      integrity: integrity,
      fetchPriority: fetchPriority,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0
    });
  }
};
exports.preinitModule = function (href, options) {
  if ("string" === typeof href) if ("object" === typeof options && null !== options) {
    if (null == options.as || "script" === options.as) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.M(href, {
        crossOrigin: crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  } else null == options && Internals.d.M(href);
};
exports.preload = function (href, options) {
  if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin: crossOrigin,
      integrity: "string" === typeof options.integrity ? options.integrity : void 0,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
      type: "string" === typeof options.type ? options.type : void 0,
      fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
      referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
      imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
      imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
      media: "string" === typeof options.media ? options.media : void 0
    });
  }
};
exports.preloadModule = function (href, options) {
  if ("string" === typeof href) if (options) {
    var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
    Internals.d.m(href, {
      as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
      crossOrigin: crossOrigin,
      integrity: "string" === typeof options.integrity ? options.integrity : void 0
    });
  } else Internals.d.m(href);
};
exports.requestFormReset = function (form) {
  Internals.d.r(form);
};
exports.unstable_batchedUpdates = function (fn, a) {
  return fn(a);
};
exports.useFormState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
};
exports.useFormStatus = function () {
  return ReactSharedInternals.H.useHostTransitionStatus();
};
exports.version = "19.0.0";

/***/ }),

/***/ 391:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}
if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(4);
} else {}

/***/ }),

/***/ 950:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}
if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(672);
} else {}

/***/ }),

/***/ 799:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
function jsxProd(type, config, maybeKey) {
  var key = null;
  void 0 !== maybeKey && (key = "" + maybeKey);
  void 0 !== config.key && (key = "" + config.key);
  if ("key" in config) {
    maybeKey = {};
    for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
  } else maybeKey = config;
  config = maybeKey.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== config ? config : null,
    props: maybeKey
  };
}
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsxProd;
exports.jsxs = jsxProd;

/***/ }),

/***/ 288:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var ReactNoopUpdateQueue = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  assign = Object.assign,
  emptyObject = {};
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function (partialState, callback) {
  if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl = Array.isArray,
  ReactSharedInternals = {
    H: null,
    A: null,
    T: null,
    S: null
  },
  hasOwnProperty = Object.prototype.hasOwnProperty;
function ReactElement(type, key, self, source, owner, props) {
  self = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== self ? self : null,
    props: props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(oldElement.type, newKey, void 0, void 0, void 0, oldElement.props);
}
function isValidElement(object) {
  return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
}
function escape(key) {
  var escaperLookup = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + key.replace(/[=:]/g, function (match) {
    return escaperLookup[match];
  });
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(element, index) {
  return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
}
function noop$1() {}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function (fulfilledValue) {
        "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
      }, function (error) {
        "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
      })), thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = !1;
  if (null === children) invokeCallback = !0;else switch (type) {
    case "bigint":
    case "string":
    case "number":
      invokeCallback = !0;
      break;
    case "object":
      switch (children.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          invokeCallback = !0;
          break;
        case REACT_LAZY_TYPE:
          return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
      }
  }
  if (invokeCallback) return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function (c) {
    return c;
  })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if (i = getIteratorFn(children), "function" === typeof i) for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if ("object" === type) {
    if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
    array = String(children);
    throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [],
    count = 0;
  mapIntoArray(children, result, "", "", function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(function (moduleObject) {
      if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
    }, function (error) {
      if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
    });
    -1 === payload._status && (payload._status = 0, payload._result = ctor);
  }
  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}
var reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
  if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
    var event = new window.ErrorEvent("error", {
      bubbles: !0,
      cancelable: !0,
      message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
      error: error
    });
    if (!window.dispatchEvent(event)) return;
  } else if ("object" === typeof process && "function" === typeof process.emit) {
    process.emit("uncaughtException", error);
    return;
  }
  console.error(error);
};
function noop() {}
exports.Children = {
  map: mapChildren,
  forEach: function (children, forEachFunc, forEachContext) {
    mapChildren(children, function () {
      forEachFunc.apply(this, arguments);
    }, forEachContext);
  },
  count: function (children) {
    var n = 0;
    mapChildren(children, function () {
      n++;
    });
    return n;
  },
  toArray: function (children) {
    return mapChildren(children, function (child) {
      return child;
    }) || [];
  },
  only: function (children) {
    if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
    return children;
  }
};
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
exports.act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
exports.cache = function (fn) {
  return function () {
    return fn.apply(null, arguments);
  };
};
exports.cloneElement = function (element, config, children) {
  if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
  var props = assign({}, element.props),
    key = element.key,
    owner = void 0;
  if (null != config) for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++) childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, void 0, void 0, owner, props);
};
exports.createContext = function (defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
};
exports.createElement = function (type, config, children) {
  var propName,
    props = {},
    key = null;
  if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === props[propName] && (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, void 0, void 0, null, props);
};
exports.createRef = function () {
  return {
    current: null
  };
};
exports.forwardRef = function (render) {
  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
};
exports.isValidElement = isValidElement;
exports.lazy = function (ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: {
      _status: -1,
      _result: ctor
    },
    _init: lazyInitializer
  };
};
exports.memo = function (type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: void 0 === compare ? null : compare
  };
};
exports.startTransition = function (scope) {
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  try {
    var returnValue = scope(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    ReactSharedInternals.T = prevTransition;
  }
};
exports.unstable_useCacheRefresh = function () {
  return ReactSharedInternals.H.useCacheRefresh();
};
exports.use = function (usable) {
  return ReactSharedInternals.H.use(usable);
};
exports.useActionState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
};
exports.useCallback = function (callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
};
exports.useContext = function (Context) {
  return ReactSharedInternals.H.useContext(Context);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
};
exports.useEffect = function (create, deps) {
  return ReactSharedInternals.H.useEffect(create, deps);
};
exports.useId = function () {
  return ReactSharedInternals.H.useId();
};
exports.useImperativeHandle = function (ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
};
exports.useInsertionEffect = function (create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
};
exports.useLayoutEffect = function (create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
};
exports.useMemo = function (create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
};
exports.useOptimistic = function (passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
};
exports.useReducer = function (reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
};
exports.useRef = function (initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
};
exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState);
};
exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
  return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
};
exports.useTransition = function () {
  return ReactSharedInternals.H.useTransition();
};
exports.version = "19.0.0";

/***/ }),

/***/ 43:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(288);
} else {}

/***/ }),

/***/ 579:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(799);
} else {}

/***/ }),

/***/ 896:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  a: for (; 0 < index;) {
    var parentIndex = index - 1 >>> 1,
      parent = heap[parentIndex];
    if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;else break a;
  }
}
function peek(heap) {
  return 0 === heap.length ? null : heap[0];
}
function pop(heap) {
  if (0 === heap.length) return null;
  var first = heap[0],
    last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
      var leftIndex = 2 * (index + 1) - 1,
        left = heap[leftIndex],
        rightIndex = leftIndex + 1,
        right = heap[rightIndex];
      if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;else break a;
    }
  }
  return first;
}
function compare(a, b) {
  var diff = a.sortIndex - b.sortIndex;
  return 0 !== diff ? diff : a.id - b.id;
}
exports.unstable_now = void 0;
if ("object" === typeof performance && "function" === typeof performance.now) {
  var localPerformance = performance;
  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date,
    initialTime = localDate.now();
  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}
var taskQueue = [],
  timerQueue = [],
  taskIdCounter = 1,
  currentTask = null,
  currentPriorityLevel = 3,
  isPerformingWork = !1,
  isHostCallbackScheduled = !1,
  isHostTimeoutScheduled = !1,
  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
function advanceTimers(currentTime) {
  for (var timer = peek(timerQueue); null !== timer;) {
    if (null === timer.callback) pop(timerQueue);else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);else break;
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = !1;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, requestHostCallback();else {
    var firstTimer = peek(timerQueue);
    null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
  }
}
var isMessageLoopRunning = !1,
  taskTimeoutID = -1,
  frameInterval = 5,
  startTime = -1;
function shouldYieldToHost() {
  return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
}
function performWorkUntilDeadline() {
  if (isMessageLoopRunning) {
    var currentTime = exports.unstable_now();
    startTime = currentTime;
    var hasMoreWork = !0;
    try {
      a: {
        isHostCallbackScheduled = !1;
        isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
        isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          b: {
            advanceTimers(currentTime);
            for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
              var callback = currentTask.callback;
              if ("function" === typeof callback) {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                currentTime = exports.unstable_now();
                if ("function" === typeof continuationCallback) {
                  currentTask.callback = continuationCallback;
                  advanceTimers(currentTime);
                  hasMoreWork = !0;
                  break b;
                }
                currentTask === peek(taskQueue) && pop(taskQueue);
                advanceTimers(currentTime);
              } else pop(taskQueue);
              currentTask = peek(taskQueue);
            }
            if (null !== currentTask) hasMoreWork = !0;else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              hasMoreWork = !1;
            }
          }
          break a;
        } finally {
          currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
        }
        hasMoreWork = void 0;
      }
    } finally {
      hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
    }
  }
}
var schedulePerformWorkUntilDeadline;
if ("function" === typeof localSetImmediate) schedulePerformWorkUntilDeadline = function () {
  localSetImmediate(performWorkUntilDeadline);
};else if ("undefined" !== typeof MessageChannel) {
  var channel = new MessageChannel(),
    port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = function () {
    port.postMessage(null);
  };
} else schedulePerformWorkUntilDeadline = function () {
  localSetTimeout(performWorkUntilDeadline, 0);
};
function requestHostCallback() {
  isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
}
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(function () {
    callback(exports.unstable_now());
  }, ms);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (task) {
  task.callback = null;
};
exports.unstable_continueExecution = function () {
  isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback());
};
exports.unstable_forceFrameRate = function (fps) {
  0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
};
exports.unstable_getCurrentPriorityLevel = function () {
  return currentPriorityLevel;
};
exports.unstable_getFirstCallbackNode = function () {
  return peek(taskQueue);
};
exports.unstable_next = function (eventHandler) {
  switch (currentPriorityLevel) {
    case 1:
    case 2:
    case 3:
      var priorityLevel = 3;
      break;
    default:
      priorityLevel = currentPriorityLevel;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_pauseExecution = function () {};
exports.unstable_requestPaint = function () {};
exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      priorityLevel = 3;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_scheduleCallback = function (priorityLevel, callback, options) {
  var currentTime = exports.unstable_now();
  "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
  switch (priorityLevel) {
    case 1:
      var timeout = -1;
      break;
    case 2:
      timeout = 250;
      break;
    case 5:
      timeout = 1073741823;
      break;
    case 4:
      timeout = 1e4;
      break;
    default:
      timeout = 5e3;
  }
  timeout = options + timeout;
  priorityLevel = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: options,
    expirationTime: timeout,
    sortIndex: -1
  };
  options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback()));
  return priorityLevel;
};
exports.unstable_shouldYield = shouldYieldToHost;
exports.unstable_wrapCallback = function (callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
};

/***/ }),

/***/ 853:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(896);
} else {}

/***/ }),

/***/ 389:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ``, "",{"version":3,"sources":[],"names":[],"mappings":"","sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 515:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.su-improved-storage ul.item_plate_wrapper{gap:5px}.su-improved-storage ul.item_plate_wrapper li.empty_plate{display:none}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate{width:60px;margin:0;transform:none}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate:before{content:none}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_inner{width:60px;height:60px}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_ellipse{width:100%;height:100%}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_bottom_gradient{width:100%;height:100%}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_expiration .hourglass_wrapper{width:15px;height:15px}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_expiration .hourglass_wrapper img{width:12px;height:12px}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_clock{width:15px;height:15px}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_timer_total{width:auto;font-size:.6rem;padding:2px 12px 2px 18px}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_value{box-sizing:border-box;width:100%;height:auto;height:initial;padding:2px 0;font-size:.6rem}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_value img{height:12px}.su-improved-storage ul.item_plate_wrapper li.item_plate.small_plate .item_plate_amount{box-sizing:border-box;width:100%;height:auto;height:initial;padding:2px 4px;font-size:.7rem;white-space:nowrap}.su-improved-storage .storage_section_wrapper{padding:8px 16px}.su-improved-storage .storage_section_wrapper .filters{margin:0}.su-improved-storage #sell_price .offers_quantity{position:relative}`, "",{"version":3,"sources":["webpack://./src/features/improved-storage/StaticStyles.scss"],"names":[],"mappings":"AAII,2CACI,OAAA,CAEA,0DACI,YAAA,CAGJ,qEACI,UAZL,CAaK,QAAA,CACA,cAAA,CAEA,4EACI,YAAA,CAGJ,uFACI,UArBT,CAsBS,WAtBT,CAyBK,yFACI,UAAA,CACA,WAAA,CAGJ,iGACI,UAAA,CACA,WAAA,CAGA,+GACI,UAAA,CACA,WAAA,CACA,mHACI,UAAA,CACA,WAAA,CAKZ,uFACI,UAAA,CACA,WAAA,CAGJ,6FACI,UAAA,CACA,eAAA,CACA,yBAAA,CAGJ,uFACI,qBAAA,CACA,UAAA,CACA,WAAA,CAAA,cAAA,CACA,aAAA,CACA,eAAA,CAEA,2FACI,WAAA,CAIR,wFACI,qBAAA,CACA,UAAA,CACA,WAAA,CAAA,cAAA,CACA,eAAA,CACA,eAAA,CACA,kBAAA,CAMZ,8CACI,gBAAA,CACA,uDACI,QAAA,CAMJ,kDACI,iBAAA","sourcesContent":["$size: 60px;\n\n.su-improved-storage {\n    // Items List in the storage\n    ul.item_plate_wrapper {\n        gap: 5px;\n        \n        li.empty_plate {\n            display: none;\n        }\n\n        li.item_plate.small_plate {\n            width: $size;\n            margin: 0;\n            transform: none;\n            \n            &:before {\n                content: none;\n            }\n\n            .item_plate_inner {\n                width: $size;\n                height: $size;\n            }\n\n            .item_plate_ellipse {\n                width: 100%;\n                height: 100%;\n            }\n\n            .item_plate_bottom_gradient {\n                width: 100%;\n                height: 100%;\n            }\n            .item_plate_expiration {\n                .hourglass_wrapper {\n                    width: 15px;\n                    height: 15px;\n                    img {\n                        width: 12px;\n                        height: 12px;\n                    }\n                }\n            }\n            \n            .item_plate_clock {\n                width: 15px;\n                height: 15px;\n            }\n            \n            .item_plate_timer_total {\n                width: auto;\n                font-size: 0.6rem;\n                padding: 2px 12px 2px 18px;\n            }\n            \n            .item_plate_value {\n                box-sizing: border-box;\n                width: 100%;\n                height: unset;\n                padding: 2px 0;\n                font-size: 0.6rem;\n\n                img {\n                    height: 12px;\n                }\n            }\n\n            .item_plate_amount {\n                box-sizing: border-box;\n                width: 100%;\n                height: unset;\n                padding: 2px 4px;\n                font-size: 0.7rem;\n                white-space: nowrap;\n            }\n        }\n    }\n    \n    // General padding\n    .storage_section_wrapper {\n        padding: 8px 16px;\n        .filters {\n            margin: 0;\n        }\n    }\n    \n    // Total sell price\n    #sell_price {\n        .offers_quantity {\n            position: relative;\n        }\n    }\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 200:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.AutoTravellerPanel_panel__DtOqy{box-sizing:border-box;position:absolute;z-index:999;box-shadow:0 0 8px 0 rgba(0,0,0,.18);background-color:#fff;border-radius:8px;height:187px;width:293px;right:1%;top:24%;pointer-events:auto !important;cursor:auto !important}header.AutoTravellerPanel_header__osn5h{background-color:#5f7280;padding:11px 16px;border-top-left-radius:8px;border-top-right-radius:8px}header.AutoTravellerPanel_header__osn5h h2.AutoTravellerPanel_title__cVO6T{font-size:16px;color:#fff}form.AutoTravellerPanel_form__gI6H1{padding:16px;display:block}label.AutoTravellerPanel_label__ZGCJT{display:flex;justify-content:space-between;align-items:center;font-size:13px;margin-bottom:8px}input.AutoTravellerPanel_input__GGC1x{width:100px;text-align:center}input.AutoTravellerPanel_input__GGC1x.AutoTravellerPanel_inputError__Lxr4s{border:1px solid red}section.AutoTravellerPanel_actionBar__TCdbo{display:flex;justify-content:flex-end;column-gap:8px}[data-tooltip]{position:relative}[data-tooltip]::after{position:absolute;opacity:1;pointer-events:none;content:attr(data-tooltip);right:0;top:calc(100% + 5px);border-radius:3px;box-shadow:0 0 5px 2px rgba(100,100,100,.6);background-color:#fff;z-index:10;padding:8px;transition:all 150ms cubic-bezier(0.25, 0.8, 0.25, 1);transition-duration:300ms}`, "",{"version":3,"sources":["webpack://./src/features/an-amazing-journey/components/AutoTravellerPanel.module.scss"],"names":[],"mappings":"AAAA,iCACI,qBAAA,CACA,iBAAA,CACA,WAAA,CACA,oCAAA,CACA,qBAAA,CACA,iBAAA,CACA,YAAA,CACA,WAAA,CACA,QAAA,CACA,OAAA,CACA,8BAAA,CACA,sBAAA,CAGJ,wCACI,wBAAA,CACA,iBAAA,CACA,0BAAA,CACA,2BAAA,CAEA,2EACI,cAAA,CACA,UAAA,CAIR,oCACI,YAAA,CACA,aAAA,CAGJ,sCACI,YAAA,CACA,6BAAA,CACA,kBAAA,CACA,cAAA,CACA,iBAAA,CAGJ,sCACI,WAAA,CACA,iBAAA,CAEA,2EACI,oBAAA,CAWR,4CACI,YAAA,CACA,wBAAA,CACA,cAAA,CAOJ,eACI,iBAAA,CAGJ,sBACI,iBAAA,CACA,SAAA,CACA,mBAAA,CACA,0BAAA,CACA,OAAA,CACA,oBAAA,CACA,iBAAA,CACA,2CAAA,CACA,qBAAA,CACA,UAAA,CACA,WAAA,CACA,qDAAA,CAEA,yBAAA","sourcesContent":[".panel {\n    box-sizing: border-box;\n    position: absolute;\n    z-index: 999;\n    box-shadow: 0 0 8px 0 rgba(0,0,0,.18);\n    background-color: #fff;\n    border-radius: 8px;\n    height: 187px;\n    width: 293px;\n    right: 1%;\n    top: 24%;\n    pointer-events: auto !important;\n    cursor: auto !important;\n}\n\nheader.header {\n    background-color: #5f7280;\n    padding: 11px 16px;\n    border-top-left-radius: 8px;\n    border-top-right-radius: 8px;\n\n    h2.title {\n        font-size: 16px;\n        color: #fff;\n    }\n}\n\nform.form {\n    padding: 16px;\n    display: block;\n}\n\nlabel.label {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    font-size: 13px;\n    margin-bottom: 8px;\n}\n\ninput.input {\n    width: 100px;\n    text-align: center;\n\n    &.inputError {\n        border: 1px solid red;\n    }\n}\n\nselect.select {\n}\n\ninput.checkbox{\n\n}\n\nsection.actionBar {\n    display: flex;\n    justify-content: flex-end;\n    column-gap: 8px;\n\n    button.start {\n    }\n\n}\n\n[data-tooltip] {\n    position: relative;\n}\n\n[data-tooltip]::after {\n    position: absolute;\n    opacity: 1;\n    pointer-events: none;\n    content: attr(data-tooltip);\n    right: 0;\n    top: calc(100% + 5px);\n    border-radius: 3px;\n    box-shadow: 0 0 5px 2px rgba(100, 100, 100, 0.6);\n    background-color: #fff;\n    z-index: 10;\n    padding: 8px;\n    transition: all 150ms cubic-bezier(.25, .8, .25, 1);\n\n    transition-duration: 300ms;\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"panel": `AutoTravellerPanel_panel__DtOqy`,
	"header": `AutoTravellerPanel_header__osn5h`,
	"title": `AutoTravellerPanel_title__cVO6T`,
	"form": `AutoTravellerPanel_form__gI6H1`,
	"label": `AutoTravellerPanel_label__ZGCJT`,
	"input": `AutoTravellerPanel_input__GGC1x`,
	"inputError": `AutoTravellerPanel_inputError__Lxr4s`,
	"actionBar": `AutoTravellerPanel_actionBar__TCdbo`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 77:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `section.CollapseButtonPanel_panel__-DTdI{border-radius:8px;background-color:#fff;position:absolute;z-index:1000;top:25.1%;right:2%;transition:all .2s ease-in-out}section.CollapseButtonPanel_panel__-DTdI.CollapseButtonPanel_isCollapsed__i22Jz{box-shadow:0 0 8px 0 rgba(0,0,0,.18)}button.CollapseButtonPanel_button__pC1GN{box-sizing:border-box;width:32px;height:32px;border:none;background:none;padding:4px;cursor:pointer;transition:all .2s ease-in-out}button.CollapseButtonPanel_button__pC1GN.CollapseButtonPanel_isCollapsed__i22Jz{transform:rotate3d(0, 1, 0, 180deg)}`, "",{"version":3,"sources":["webpack://./src/features/an-amazing-journey/components/CollapseButtonPanel.module.scss"],"names":[],"mappings":"AAAA,yCACE,iBAAA,CACA,qBAAA,CACA,iBAAA,CACA,YAAA,CACA,SAAA,CACA,QAAA,CAEA,8BAAA,CAEA,gFACE,oCAAA,CAIJ,yCACE,qBAAA,CACA,UAAA,CACA,WAAA,CAGA,WAAA,CACA,eAAA,CACA,WAAA,CACA,cAAA,CAEA,8BAAA,CAGA,gFAEE,mCAAA","sourcesContent":["section.panel {\n  border-radius: 8px;\n  background-color: #fff;\n  position: absolute;\n  z-index: 1000;\n  top: 25.1%;\n  right: 2%;\n\n  transition: all 0.2s ease-in-out;\n\n  &.isCollapsed {\n    box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.18);\n  }\n}\n\nbutton.button {\n  box-sizing: border-box;\n  width: 32px;\n  height: 32px;\n\n  //reset button styles\n  border: none;\n  background: none;\n  padding: 4px;\n  cursor: pointer;\n\n  transition: all 0.2s ease-in-out;\n\n\n  &.isCollapsed {\n    // rotate 3d 180deg\n    transform: rotate3d(0, 1, 0, 180deg);\n    //transform: rotate(-180deg);\n  }\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"panel": `CollapseButtonPanel_panel__-DTdI`,
	"isCollapsed": `CollapseButtonPanel_isCollapsed__i22Jz`,
	"button": `CollapseButtonPanel_button__pC1GN`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 576:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `section.ErrorPanel_panel__FZdQT{box-sizing:border-box;position:absolute;z-index:10001;box-shadow:0 0 8px 0 rgba(0,0,0,.18);background-color:#812b2b;border-radius:8px;width:293px;right:1%;top:58%;pointer-events:auto !important;cursor:auto !important;color:#fff;padding:8px 16px}.ErrorPanel_errors__GR7ne{display:flex;flex-direction:column;gap:4px;max-height:200px;overflow:auto}.ErrorPanel_errors__GR7ne p.ErrorPanel_error__XQ3p0{font-size:13px}.ErrorPanel_errors__GR7ne p.ErrorPanel_error__XQ3p0:first-of-type{padding-right:16px}.ErrorPanel_errors__GR7ne p.ErrorPanel_error__XQ3p0:not(:last-of-type){border-bottom:1px solid hsla(0,0%,100%,.2)}button.ErrorPanel_close__7Jwbw{background:none;border:none;padding:0;display:flex;align-items:center;justify-content:center;cursor:pointer;color:#fff;position:absolute;top:0;right:0;width:32px;height:32px;transition:background-color .2s ease-in-out;border-bottom-left-radius:8px}button.ErrorPanel_close__7Jwbw:hover{background-color:hsla(0,0%,100%,.2)}`, "",{"version":3,"sources":["webpack://./src/features/an-amazing-journey/components/ErrorPanel.module.scss"],"names":[],"mappings":"AAAA,gCACE,qBAAA,CACA,iBAAA,CACA,aAAA,CACA,oCAAA,CACA,wBAAA,CACA,iBAAA,CACA,WAAA,CACA,QAAA,CACA,OAAA,CACA,8BAAA,CACA,sBAAA,CACA,UAAA,CACA,gBAAA,CAGF,0BACE,YAAA,CACA,qBAAA,CACA,OAAA,CAEA,gBAAA,CACA,aAAA,CAEA,oDACE,cAAA,CAEA,kEACE,kBAAA,CAGF,uEACE,0CAAA,CAKN,+BACE,eAAA,CACA,WAAA,CACA,SAAA,CACA,YAAA,CACA,kBAAA,CACA,sBAAA,CACA,cAAA,CACA,UAAA,CACA,iBAAA,CACA,KAAA,CACA,OAAA,CACA,UAAA,CACA,WAAA,CAEA,2CAAA,CACA,6BAAA,CAEA,qCACE,mCAAA","sourcesContent":["section.panel {\n  box-sizing: border-box;\n  position: absolute;\n  z-index: 10001;\n  box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.18);\n  background-color: #812b2b;\n  border-radius: 8px;\n  width: 293px;\n  right: 1%;\n  top: 58%;\n  pointer-events: auto !important;\n  cursor: auto !important;\n  color: #fff;\n  padding: 8px 16px;\n}\n\n.errors {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n\n  max-height: 200px;\n  overflow: auto;\n\n  p.error {\n    font-size: 13px;\n\n    &:first-of-type {\n      padding-right: 16px;\n    }\n\n    &:not(:last-of-type) {\n      border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n    }\n  }\n}\n\nbutton.close {\n  background: none;\n  border: none;\n  padding: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  color: #fff;\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 32px;\n  height: 32px;\n\n  transition: background-color 0.2s ease-in-out;\n  border-bottom-left-radius: 8px;\n\n  &:hover {\n    background-color: rgba(255, 255, 255, 0.2);\n  }\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"panel": `ErrorPanel_panel__FZdQT`,
	"errors": `ErrorPanel_errors__GR7ne`,
	"error": `ErrorPanel_error__XQ3p0`,
	"close": `ErrorPanel_close__7Jwbw`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 565:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.StatusIndicator_statusIndicator__EYsLz{display:flex}.StatusIndicator_inProgress__ylTkU{color:#cbdae8}.StatusIndicator_inProgress__ylTkU .StatusIndicator_spinner__ut7ky{transform-origin:center;animation:StatusIndicator_spinner__ut7ky .75s infinite linear}@keyframes StatusIndicator_spinner__ut7ky{100%{transform:rotate(360deg)}}.StatusIndicator_error__F1dwS{color:#ff6767;animation:StatusIndicator_pulsate__u3JCS 1.4s ease-out;animation-iteration-count:infinite}@keyframes StatusIndicator_pulsate__u3JCS{0%{transform:scale(1, 1)}50%{transform:scale(1.4, 1.4)}100%{transform:scale(1, 1)}}.StatusIndicator_completed__36OU9{color:#62df7a}`, "",{"version":3,"sources":["webpack://./src/features/an-amazing-journey/components/StatusIndicator.module.scss"],"names":[],"mappings":"AAAA,wCACI,YAAA,CAGJ,mCACI,aAAA,CAEA,mEACI,uBAAA,CACA,6DAAA,CAGJ,0CACI,KACI,wBAAA,CAAA,CAKZ,8BACI,aAAA,CACA,sDAAA,CACA,kCAAA,CAEA,0CACI,GACI,qBAAA,CAEJ,IACI,yBAAA,CAEJ,KACI,qBAAA,CAAA,CAKZ,kCACI,aAAA","sourcesContent":[".statusIndicator {\n    display: flex;\n}\n\n.inProgress {\n    color: #cbdae8;\n\n    .spinner {\n        transform-origin: center;\n        animation: spinner .75s infinite linear;\n    }\n\n    @keyframes spinner {\n        100% {\n            transform: rotate(360deg)\n        }\n    }\n}\n\n.error {\n    color: #ff6767;\n    animation: pulsate 1.4s ease-out;\n    animation-iteration-count: infinite;\n\n    @keyframes pulsate {\n        0% {\n            transform: scale(1,1);\n        }\n        50% {\n            transform: scale(1.4, 1.4);\n        }\n        100% {\n            transform: scale(1, 1);\n        }\n    }\n}\n\n.completed {\n    color: #62df7a;\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"statusIndicator": `StatusIndicator_statusIndicator__EYsLz`,
	"inProgress": `StatusIndicator_inProgress__ylTkU`,
	"spinner": `StatusIndicator_spinner__ut7ky`,
	"error": `StatusIndicator_error__F1dwS`,
	"pulsate": `StatusIndicator_pulsate__u3JCS`,
	"completed": `StatusIndicator_completed__36OU9`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 805:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `section.TravelProgressPanel_panel__McE4q{box-sizing:border-box;position:absolute;z-index:999;box-shadow:0 0 8px 0 rgba(0,0,0,.18);background-color:#fff;border-radius:8px;height:110px;width:189px;right:11.9%;top:58%;pointer-events:auto !important;cursor:auto !important}header.TravelProgressPanel_header__hwZeU{background-color:#5f7280;border-top-left-radius:8px;border-top-right-radius:8px;display:flex;justify-content:space-between;align-items:center;padding-right:8px}header.TravelProgressPanel_header__hwZeU h2.TravelProgressPanel_title__RHoV9{flex:1 1;padding:8px 16px;color:#fff;font-size:14px;font-weight:500}.TravelProgressPanel_rows__I8BES{padding:8px 16px}.TravelProgressPanel_rows__I8BES .TravelProgressPanel_row__fJduM{display:flex;justify-content:space-between}.TravelProgressPanel_rows__I8BES .TravelProgressPanel_row__fJduM .TravelProgressPanel_key__N1yGr{font-size:12px}.TravelProgressPanel_rows__I8BES .TravelProgressPanel_row__fJduM .TravelProgressPanel_value__z3\\+ro{font-size:13px;font-weight:600}`, "",{"version":3,"sources":["webpack://./src/features/an-amazing-journey/components/TravelProgressPanel.module.scss"],"names":[],"mappings":"AAAA,yCACE,qBAAA,CACA,iBAAA,CACA,WAAA,CACA,oCAAA,CACA,qBAAA,CACA,iBAAA,CACA,YAAA,CACA,WAAA,CACA,WAAA,CACA,OAAA,CACA,8BAAA,CACA,sBAAA,CAGF,yCACE,wBAAA,CACA,0BAAA,CACA,2BAAA,CACA,YAAA,CACA,6BAAA,CACA,kBAAA,CACA,iBAAA,CAEA,6EACE,QAAA,CACA,gBAAA,CACA,UAAA,CACA,cAAA,CACA,eAAA,CAIJ,iCACE,gBAAA,CAEA,iEACE,YAAA,CACA,6BAAA,CAEA,iGACE,cAAA,CAGF,oGACE,cAAA,CACA,eAAA","sourcesContent":["section.panel {\n  box-sizing: border-box;\n  position: absolute;\n  z-index: 999;\n  box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.18);\n  background-color: #fff;\n  border-radius: 8px;\n  height: 110px;\n  width: 189px;\n  right: 11.9%;\n  top: 58%;\n  pointer-events: auto !important;\n  cursor: auto !important;\n}\n\nheader.header {\n  background-color: #5f7280;\n  border-top-left-radius: 8px;\n  border-top-right-radius: 8px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding-right: 8px;\n\n  h2.title {\n    flex: 1;\n    padding: 8px 16px;\n    color: #fff;\n    font-size: 14px;\n    font-weight: 500;\n  }\n}\n\n.rows {\n  padding: 8px 16px;\n\n  .row {\n    display: flex;\n    justify-content: space-between;\n\n    .key {\n      font-size: 12px;\n    }\n\n    .value {\n      font-size: 13px;\n      font-weight: 600;\n    }\n  }\n}\n\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"panel": `TravelProgressPanel_panel__McE4q`,
	"header": `TravelProgressPanel_header__hwZeU`,
	"title": `TravelProgressPanel_title__RHoV9`,
	"rows": `TravelProgressPanel_rows__I8BES`,
	"row": `TravelProgressPanel_row__fJduM`,
	"key": `TravelProgressPanel_key__N1yGr`,
	"value": `TravelProgressPanel_value__z3+ro`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 893:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.ItemsSectionToggle_Hidden__tcTMV{display:none !important}`, "",{"version":3,"sources":["webpack://./src/features/improved-storage/components/ItemsSectionToggle.module.scss"],"names":[],"mappings":"AAAA,kCACI,uBAAA","sourcesContent":[".Hidden {\n    display: none !important;\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"Hidden": `ItemsSectionToggle_Hidden__tcTMV`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 374:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.TotalFood_ValueSection__jKsEG{display:flex;align-items:center}.TotalFood_ValueSection__jKsEG .TotalFood_FoodIcon__qrGw\\+{width:30px;height:30px;margin-right:5px}.TotalFood_ValueSection__jKsEG .TotalFood_EnergyValue__D00nP{font-size:1.1em;font-weight:bold}`, "",{"version":3,"sources":["webpack://./src/features/improved-storage/components/TotalFood.module.scss"],"names":[],"mappings":"AAIA,+BACI,YAAA,CACA,kBAAA,CAEA,2DACI,UAAA,CACA,WAAA,CACA,gBAAA,CAGJ,6DACI,eAAA,CACA,gBAAA","sourcesContent":[".Title {\n    \n}\n\n.ValueSection {\n    display: flex;\n    align-items: center;\n\n    .FoodIcon {\n        width: 30px;\n        height: 30px;\n        margin-right: 5px;\n    }\n\n    .EnergyValue {\n        font-size: 1.1em;\n        font-weight: bold;\n    }\n}\n\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"ValueSection": `TotalFood_ValueSection__jKsEG`,
	"FoodIcon": `TotalFood_FoodIcon__qrGw+`,
	"EnergyValue": `TotalFood_EnergyValue__D00nP`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 212:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.TotalLabel_TotalLabelRoot__4wuzY{position:absolute;top:82px;font-size:11px;color:#89afc9;text-shadow:#fff 0 1px 0}.TotalLabel_TotalValue__TLl5\\+{font-weight:bold}`, "",{"version":3,"sources":["webpack://./src/features/improved-storage/components/TotalLabel.module.scss"],"names":[],"mappings":"AAAA,kCACI,iBAAA,CACA,QAAA,CACA,cAAA,CACA,aAAA,CACA,wBAAA,CAGJ,+BACI,gBAAA","sourcesContent":[".TotalLabelRoot {\n    position: absolute;\n    top: 82px;\n    font-size: 11px;\n    color: #89afc9;\n    text-shadow: #fff 0 1px 0;\n}\n\n.TotalValue {\n    font-weight: bold;\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"TotalLabelRoot": `TotalLabel_TotalLabelRoot__4wuzY`,
	"TotalValue": `TotalLabel_TotalValue__TLl5+`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 472:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.StorageInfo_StorageInfo__POTRa{margin-left:4px;display:inline-flex;flex-direction:column}.StorageInfo_MainRow__n-yYh{display:inline-flex}.StorageInfo_MainText__r0ey2{font-size:11px;color:#5a5a5a;text-shadow:0 1px 0 hsla(0,0%,100%,.9);font-weight:700}.StorageInfo_SecondaryText__t34Y3{font-size:11px;color:#5a5a5a;text-shadow:0 1px 0 hsla(0,0%,100%,.9)}.StorageInfo_SupportingRow__ipW5m{font-size:11px;color:#5a5a5a;text-shadow:0 1px 0 hsla(0,0%,100%,.9);margin-left:30px;margin-top:4px}.StorageInfo_Image__7AZbG{height:14px;margin-right:4px}`, "",{"version":3,"sources":["webpack://./src/features/main-page/components/StorageInfo.module.scss"],"names":[],"mappings":"AAAA,gCACI,eAAA,CACA,mBAAA,CACA,qBAAA,CAGJ,4BACI,mBAAA,CAGJ,6BACI,cAAA,CACA,aAAA,CACA,sCAAA,CACA,eAAA,CAGJ,kCACI,cAAA,CACA,aAAA,CACA,sCAAA,CAGJ,kCACI,cAAA,CACA,aAAA,CACA,sCAAA,CACA,gBAAA,CACA,cAAA,CAGJ,0BACI,WAAA,CACA,gBAAA","sourcesContent":[".StorageInfo {\n    margin-left: 4px;\n    display: inline-flex;\n    flex-direction: column;\n}\n\n.MainRow {\n    display: inline-flex;\n}\n\n.MainText {\n    font-size: 11px;\n    color: #5a5a5a;\n    text-shadow: 0 1px 0 rgba(255,255,255,.9);\n    font-weight: 700;\n}\n\n.SecondaryText {\n    font-size: 11px;\n    color: #5a5a5a;\n    text-shadow: 0 1px 0 rgba(255,255,255,.9);\n}\n\n.SupportingRow {\n    font-size: 11px;\n    color: #5a5a5a;\n    text-shadow: 0 1px 0 rgba(255,255,255,.9);\n    margin-left: 30px;\n    margin-top: 4px;\n}\n\n.Image {\n    height: 14px;\n    margin-right: 4px;\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"StorageInfo": `StorageInfo_StorageInfo__POTRa`,
	"MainRow": `StorageInfo_MainRow__n-yYh`,
	"MainText": `StorageInfo_MainText__r0ey2`,
	"SecondaryText": `StorageInfo_SecondaryText__t34Y3`,
	"SupportingRow": `StorageInfo_SupportingRow__ipW5m`,
	"Image": `StorageInfo_Image__7AZbG`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 281:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(981);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.SideInventory_SideInventoryRoot__DlPUi{position:fixed;top:0;left:0}.SideInventory_SideInventory__cYFof{display:flex;flex-direction:column;flex-wrap:wrap;height:100vh}.SideInventory_SideInventory__cYFof .SideInventory_Item__1BEaN{width:39px;display:flex;flex-direction:column}.SideInventory_SideInventory__cYFof .SideInventory_Item__1BEaN .SideInventory_Img__GDNZJ{height:39px;width:100%;background:linear-gradient(#eef1ec, #d5decf)}.SideInventory_SideInventory__cYFof .SideInventory_Item__1BEaN .SideInventory_Text__pw3XH{font:700 10px/13px arial;color:#fff;width:100%;background:#83b70b;text-align:center;cursor:default}.SideInventory_SideInventory__cYFof .SideInventory_Item__1BEaN .SideInventory_Text__pw3XH.SideInventory_IsActive__S4Ir1{background:#c34141}`, "",{"version":3,"sources":["webpack://./src/features/side-inventory/components/SideInventory.module.scss"],"names":[],"mappings":"AAAA,wCACI,cAAA,CACA,KAAA,CACA,MAAA,CAGJ,oCACI,YAAA,CACA,qBAAA,CACA,cAAA,CACA,YAAA,CAEA,+DACI,UAAA,CACA,YAAA,CACA,qBAAA,CAEA,yFACI,WAAA,CACA,UAAA,CACA,4CAAA,CAGJ,0FACI,wBAAA,CACA,UAAA,CACA,UAAA,CACA,kBAAA,CACA,iBAAA,CACA,cAAA,CAEA,wHACI,kBAAA","sourcesContent":[".SideInventoryRoot {\n    position: fixed;\n    top: 0;\n    left: 0;\n}\n\n.SideInventory {\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    height: 100vh;\n    \n    .Item {\n        width: 39px;\n        display: flex;\n        flex-direction: column;\n\n        .Img {\n            height: 39px;\n            width: 100%;\n            background: linear-gradient(#eef1ec, #d5decf)\n        }\n\n        .Text {\n            font: 700 10px/13px arial;\n            color: #fff;\n            width: 100%;\n            background: #83b70b;\n            text-align: center;\n            cursor: default;\n            \n            &.IsActive {\n                background: #c34141;\n            }\n        }\n    }\n    \n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"SideInventoryRoot": `SideInventory_SideInventoryRoot__DlPUi`,
	"SideInventory": `SideInventory_SideInventory__cYFof`,
	"Item": `SideInventory_Item__1BEaN`,
	"Img": `SideInventory_Img__GDNZJ`,
	"Text": `SideInventory_Text__pw3XH`,
	"IsActive": `SideInventory_IsActive__S4Ir1`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 186:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 433:
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 990:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 155:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 827:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 139:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
  'use strict';

  var hasOwn = {}.hasOwnProperty;
  function classNames() {
    var classes = '';
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg) {
        classes = appendClass(classes, parseValue(arg));
      }
    }
    return classes;
  }
  function parseValue(arg) {
    if (typeof arg === 'string' || typeof arg === 'number') {
      return arg;
    }
    if (typeof arg !== 'object') {
      return '';
    }
    if (Array.isArray(arg)) {
      return classNames.apply(null, arg);
    }
    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
      return arg.toString();
    }
    var classes = '';
    for (var key in arg) {
      if (hasOwn.call(arg, key) && arg[key]) {
        classes = appendClass(classes, key);
      }
    }
    return classes;
  }
  function appendClass(value, newClass) {
    if (!newClass) {
      return value;
    }
    if (value) {
      return value + ' ' + newClass;
    }
    return value + newClass;
  }
  if ( true && module.exports) {
    classNames.default = classNames;
    module.exports = classNames;
  } else if (true) {
    // register as 'classnames', consistent with npm package name
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return classNames;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})();

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(186);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(155);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(433);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(626);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(990);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(827);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/index.css
var cjs_js_src = __webpack_require__(389);
;// ./src/index.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(cjs_js_src/* default */.A, options);




       /* harmony default export */ const src = (cjs_js_src/* default */.A && cjs_js_src/* default */.A.locals ? cjs_js_src/* default */.A.locals : undefined);

;// ./src/utils/utils.ts
const APP_NAME="Stuff Unlocked";/**
 * Wrapped console.log function.
 *
 * @export
 * @param {*} args
 */function log(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}console.log("%c".concat(APP_NAME,":"),"color: purple; font-weight: bold",...args);}function error(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}console.log("%c".concat(APP_NAME," [ERROR]:"),"color: red; font-weight: bold; border-bottom: 1px solid red;",...args);}/**
 * Ensure `callback` is called every time window.location changes
 * Code derived from https://stackoverflow.com/questions/3522090/event-when-window-location-href-changes
 *
 * @export
 * @param {function} callback - function to be called when URL changes
 * @returns {MutationObserver} - MutationObserver that watches the URL
 */function addLocationChangeCallback(callback){// Run the callback once right at the start
window.setTimeout(callback,0);// Set up a `MutationObserver` to watch for changes in the URL
let oldHref=window.location.href;const body=document.querySelector("body");const observer=new MutationObserver(mutations=>{if(mutations.some(()=>oldHref!==document.location.href)){oldHref=document.location.href;callback();}});observer.observe(body,{childList:true,subtree:true});return observer;}/**
 * Awaits for an element with the specified `selector` to be found
 * and then returns the selected dom node.
 * This is used to delay rendering a widget until its parent appears.
 */async function awaitElement(selector){const MAX_TRIES=60;let tries=0;return new Promise((resolve,reject)=>{function probe(){tries++;return document.querySelector(selector);}function delayedProbe(){if(tries>=MAX_TRIES){log("Can't find element with selector",selector);reject();return;}const elm=probe();if(elm){resolve(elm);return;}window.setTimeout(delayedProbe,250);}delayedProbe();});}function ensure(thing,message){if(!thing){const msg=message||"Expected a value, got ".concat(thing);throw new Error(msg);}return thing;}
// EXTERNAL MODULE: ./src/old-index.user.js
var old_index_user = __webpack_require__(403);
;// ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

;// ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

;// ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

;// ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

;// ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

;// ./src/utils/feature.ts
function createFeature(feature){return _objectSpread2({},feature);}
;// ./src/utils/erep-global-info.ts
function getCitizenshipCurrencyName(){return erepublik.citizen.citizenshipCurrencyName;}function getCurrentRegionId(){return String(erepublik.citizen.residence.regionId);}function getAuthToken(){return erepublik.settings.pomelo.authToken;}function getCsrfToken(){return SERVER_DATA.csrfToken;}function isOnHomepage(){return Environment.isOnHomepage;}function getCitizenId(){var _erepublik,_erepublik$citizen;return(_erepublik=erepublik)===null||_erepublik===void 0?void 0:(_erepublik$citizen=_erepublik.citizen)===null||_erepublik$citizen===void 0?void 0:_erepublik$citizen.citizenId;}function getStuffVersion(){return GM_info.script.version;}
;// ./src/utils/request.ts
function getCookieHeaders(){return{cookie:"erpk=".concat(getAuthToken())};}function objectToWwwFormUrlEncoded(obj){const searchParams=new URLSearchParams();Object.keys(obj).forEach(key=>{searchParams.append(key,obj[key]);});return searchParams.toString();}
;// ./src/requests/travel-data-request.ts
let TravelData;(function(_TravelData){async function sendRequest(body){const response=fetch("https://www.erepublik.com/en/main/travelData",{method:"POST",headers:_objectSpread2({"content-type":"application/x-www-form-urlencoded"},getCookieHeaders()),body:objectToWwwFormUrlEncoded(body)});return response.then(response=>response.json());}_TravelData.sendRequest=sendRequest;let ZoneName=/*#__PURE__*/function(ZoneName){ZoneName["A1"]="A1";ZoneName["A2"]="A2";ZoneName["A3"]="A3";ZoneName["A4"]="A4";ZoneName["A5"]="A5";ZoneName["B1"]="B1";ZoneName["B3"]="B3";ZoneName["B4"]="B4";ZoneName["B5"]="B5";ZoneName["C1"]="C1";ZoneName["C2"]="C2";ZoneName["C3"]="C3";ZoneName["C4"]="C4";ZoneName["C5"]="C5";ZoneName["D2"]="D2";ZoneName["D3"]="D3";ZoneName["D5"]="D5";return ZoneName;}({});_TravelData.ZoneName=ZoneName;})(TravelData||(TravelData={}));
;// ./src/features/an-amazing-journey/countries-cache.ts
class CountriesCache{constructor(){this.countries=void 0;this.currentRegionId=void 0;}async getCountries(){if(!this.countries){await this.fetchCountries();}return this.countries;}async getCurrentRegionId(){let flags=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{skipCache:false};if(flags.skipCache||!this.currentRegionId){await this.fetchCountries();}return this.currentRegionId;}updateCurrentRegionId(regionId){this.currentRegionId=regionId;}async fetchCountries(){const response=await TravelData.sendRequest({battleId:"0",_token:await getCsrfToken(),regionId:"0",holdingId:"0"});this.updateCurrentRegionId(String(response.citizen.region.id));this.countries=response.countries;}}
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(43);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/an-amazing-journey/components/AutoTravellerPanel.module.scss
var AutoTravellerPanel_module = __webpack_require__(200);
;// ./src/features/an-amazing-journey/components/AutoTravellerPanel.module.scss

      
      
      
      
      
      
      
      
      

var AutoTravellerPanel_module_options = {};

AutoTravellerPanel_module_options.styleTagTransform = (styleTagTransform_default());
AutoTravellerPanel_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      AutoTravellerPanel_module_options.insert = insertBySelector_default().bind(null, "head");
    
AutoTravellerPanel_module_options.domAPI = (styleDomAPI_default());
AutoTravellerPanel_module_options.insertStyleElement = (insertStyleElement_default());

var AutoTravellerPanel_module_update = injectStylesIntoStyleTag_default()(AutoTravellerPanel_module/* default */.A, AutoTravellerPanel_module_options);




       /* harmony default export */ const components_AutoTravellerPanel_module = (AutoTravellerPanel_module/* default */.A && AutoTravellerPanel_module/* default */.A.locals ? AutoTravellerPanel_module/* default */.A.locals : undefined);

;// ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

;// ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js

function objectWithoutProperties_objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}

;// ./node_modules/react-hook-form/dist/index.esm.mjs


const _excluded = (/* unused pure expression or super */ null && (["children"])),
  _excluded2 = ["name"],
  _excluded3 = (/* unused pure expression or super */ null && (["control", "onSubmit", "children", "action", "method", "headers", "encType", "onError", "render", "onSuccess", "validateStatus"])),
  _excluded4 = ["_f"],
  _excluded5 = ["_f"],
  _excluded6 = ["ref", "message", "type"];

var isCheckBoxInput = element => element.type === 'checkbox';
var isDateObject = value => value instanceof Date;
var isNullOrUndefined = value => value == null;
const isObjectType = value => typeof value === 'object';
var isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = event => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = name => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject = tempObject => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf');
};
var isWeb = typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined' && typeof document !== 'undefined';
function cloneObject(data) {
  let copy;
  const isArray = Array.isArray(data);
  const isFileListInstance = typeof FileList !== 'undefined' ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {
    copy = isArray ? [] : {};
    if (!isArray && !isPlainObject(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
var compact = value => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = val => val === undefined;
var get = (object, path, defaultValue) => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean = value => typeof value === 'boolean';
var isKey = value => /^\w*$/.test(value);
var stringToPath = input => compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));
var set = (object, path, value) => {
  let index = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index < length) {
    const key = tempPath[index];
    let newValue = value;
    if (index !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }
    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
};
const EVENTS = {
  BLUR: 'blur',
  FOCUS_OUT: 'focusout',
  CHANGE: 'change'
};
const VALIDATION_MODE = {
  onBlur: 'onBlur',
  onChange: 'onChange',
  onSubmit: 'onSubmit',
  onTouched: 'onTouched',
  all: 'all'
};
const INPUT_VALIDATION_RULES = {
  max: 'max',
  min: 'min',
  maxLength: 'maxLength',
  minLength: 'minLength',
  pattern: 'pattern',
  required: 'required',
  validate: 'validate'
};
const HookFormContext = react.createContext(null);
/**
 * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext) ‚Ä¢ [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @returns return all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const useFormContext = () => React.useContext(HookFormContext);
/**
 * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformcontext) ‚Ä¢ [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @param props - all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const FormProvider = props => {
  const {
      children
    } = props,
    data = _objectWithoutProperties(props, _excluded);
  return React.createElement(HookFormContext.Provider, {
    value: data
  }, children);
};
var getProxyFormState = function (formState, control, localProxyFormState) {
  let isRoot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = value => isObject(value) && !Object.keys(value).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const {
      name
    } = formStateData,
    formState = objectWithoutProperties_objectWithoutProperties(formStateData, _excluded2);
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find(key => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = value => Array.isArray(value) ? value : [value];
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some(currentName => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = react.useRef(props);
  _props.current = props;
  react.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}

/**
 * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useformstate) ‚Ä¢ [Demo](https://codesandbox.io/s/useformstate-75xly)
 *
 * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, control } = useForm({
 *     defaultValues: {
 *     firstName: "firstName"
 *   }});
 *   const { dirtyFields } = useFormState({
 *     control
 *   });
 *   const onSubmit = (data) => console.log(data);
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input {...register("firstName")} placeholder="First Name" />
 *       {dirtyFields.firstName && <p>Field is dirty.</p>}
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFormState(props) {
  const methods = useFormContext();
  const {
    control = methods.control,
    disabled,
    name,
    exact
  } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _mounted = React.useRef(true);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    next: value => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState(_objectSpread(_objectSpread({}, control._formState), value)),
    subject: control._subjects.state
  });
  React.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return React.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = value => typeof value === 'string';
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map(fieldName => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};

/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/docs/usewatch) ‚Ä¢ [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @example
 * ```tsx
 * const { control } = useForm();
 * const values = useWatch({
 *   name: "fieldName"
 *   control,
 * })
 * ```
 */
function useWatch(props) {
  const methods = useFormContext();
  const {
    control = methods.control,
    name,
    defaultValue,
    disabled,
    exact
  } = props || {};
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: formState => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value, updateValue] = React.useState(control._getWatch(name, defaultValue));
  React.useEffect(() => control._removeUnmounted());
  return value;
}

/**
 * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller) ‚Ä¢ [Demo](https://codesandbox.io/s/usecontroller-0o8px)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns field properties, field and form state. {@link UseControllerReturn}
 *
 * @example
 * ```tsx
 * function Input(props) {
 *   const { field, fieldState, formState } = useController(props);
 *   return (
 *     <div>
 *       <input {...field} placeholder={props.name} />
 *       <p>{fieldState.isTouched && "Touched"}</p>
 *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *     </div>
 *   );
 * }
 * ```
 */
function useController(props) {
  const methods = useFormContext();
  const {
    name,
    disabled,
    control = methods.control,
    shouldUnregister
  } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _registerProps = React.useRef(control.register(name, _objectSpread(_objectSpread({}, props.rules), {}, {
    value
  }, isBoolean(props.disabled) ? {
    disabled: props.disabled
  } : {})));
  const fieldState = React.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get(formState.errors, name)
    }
  }), [formState, name]);
  const field = React.useMemo(() => _objectSpread(_objectSpread({
    name,
    value
  }, isBoolean(disabled) || formState.disabled ? {
    disabled: formState.disabled || disabled
  } : {}), {}, {
    onChange: event => _registerProps.current.onChange({
      target: {
        value: getEventValue(event),
        name: name
      },
      type: EVENTS.CHANGE
    }),
    onBlur: () => _registerProps.current.onBlur({
      target: {
        value: get(control._formValues, name),
        name: name
      },
      type: EVENTS.BLUR
    }),
    ref: elm => {
      const field = get(control._fields, name);
      if (field && elm) {
        field._f.ref = {
          focus: () => elm.focus(),
          select: () => elm.select(),
          setCustomValidity: message => elm.setCustomValidity(message),
          reportValidity: () => elm.reportValidity()
        };
      }
    }
  }), [name, control._formValues, disabled, formState.disabled, value, control._fields]);
  React.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const updateMounted = (name, value) => {
      const field = get(control._fields, name);
      if (field && field._f) {
        field._f.mount = value;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value);
      }
    }
    !isArrayField && control.register(name);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React.useEffect(() => {
    control._updateDisabledField({
      disabled,
      fields: control._fields,
      name
    });
  }, [disabled, name, control]);
  return React.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}

/**
 * Component based on `useController` hook to work with controlled component.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usecontroller/controller) ‚Ä¢ [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) ‚Ä¢ [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns provide field handler functions, field and form state.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control } = useForm<FormValues>({
 *     defaultValues: {
 *       test: ""
 *     }
 *   });
 *
 *   return (
 *     <form>
 *       <Controller
 *         control={control}
 *         name="test"
 *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
 *           <>
 *             <input
 *               onChange={onChange} // send value to hook form
 *               onBlur={onBlur} // notify when input is touched
 *               value={value} // return updated value
 *               ref={ref} // set ref for focus management
 *             />
 *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *             <p>{fieldState.isTouched ? "touched" : ""}</p>
 *           </>
 *         )}
 *       />
 *     </form>
 *   );
 * }
 * ```
 */
const Controller = props => props.render(useController(props));
const flatten = obj => {
  const output = {};
  for (const key of Object.keys(obj)) {
    if (isObjectType(obj[key]) && obj[key] !== null) {
      const nested = flatten(obj[key]);
      for (const nestedKey of Object.keys(nested)) {
        output["".concat(key, ".").concat(nestedKey)] = nested[nestedKey];
      }
    } else {
      output[key] = obj[key];
    }
  }
  return output;
};
const POST_REQUEST = 'post';
/**
 * Form component to manage submission.
 *
 * @param props - to setup submission detail. {@link FormProps}
 *
 * @returns form component or headless render prop.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control, formState: { errors } } = useForm();
 *
 *   return (
 *     <Form action="/api" control={control}>
 *       <input {...register("name")} />
 *       <p>{errors?.root?.server && 'Server error'}</p>
 *       <button>Submit</button>
 *     </Form>
 *   );
 * }
 * ```
 */
function Form(props) {
  const methods = useFormContext();
  const [mounted, setMounted] = React.useState(false);
  const {
      control = methods.control,
      onSubmit,
      children,
      action,
      method = POST_REQUEST,
      headers,
      encType,
      onError,
      render,
      onSuccess,
      validateStatus
    } = props,
    rest = _objectWithoutProperties(props, _excluded3);
  const submit = async event => {
    let hasError = false;
    let type = '';
    await control.handleSubmit(async data => {
      const formData = new FormData();
      let formDataJson = '';
      try {
        formDataJson = JSON.stringify(data);
      } catch (_a) {}
      const flattenFormValues = flatten(control._formValues);
      for (const key in flattenFormValues) {
        formData.append(key, flattenFormValues[key]);
      }
      if (onSubmit) {
        await onSubmit({
          data,
          event,
          method,
          formData,
          formDataJson
        });
      }
      if (action) {
        try {
          const shouldStringifySubmissionData = [headers && headers['Content-Type'], encType].some(value => value && value.includes('json'));
          const response = await fetch(String(action), {
            method,
            headers: _objectSpread(_objectSpread({}, headers), encType ? {
              'Content-Type': encType
            } : {}),
            body: shouldStringifySubmissionData ? formDataJson : formData
          });
          if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {
            hasError = true;
            onError && onError({
              response
            });
            type = String(response.status);
          } else {
            onSuccess && onSuccess({
              response
            });
          }
        } catch (error) {
          hasError = true;
          onError && onError({
            error
          });
        }
      }
    })(event);
    if (hasError && props.control) {
      props.control._subjects.state.next({
        isSubmitSuccessful: false
      });
      props.control.setError('root.server', {
        type
      });
    }
  };
  React.useEffect(() => {
    setMounted(true);
  }, []);
  return render ? React.createElement(React.Fragment, null, render({
    submit
  })) : React.createElement("form", _objectSpread({
    noValidate: mounted,
    action: action,
    method: method,
    encType: encType,
    onSubmit: submit
  }, rest), children);
}
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? _objectSpread2(_objectSpread2({}, errors[name]), {}, {
  types: _objectSpread2(_objectSpread2({}, errors[name] && errors[name].types ? errors[name].types : {}), {}, {
    [type]: message || true
  })
}) : {};
var generateId = () => {
  const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = (Math.random() * 16 + d) % 16 | 0;
    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
};
var getFocusFieldName = function (name, index) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || "".concat(name, ".").concat(isUndefined(options.focusIndex) ? index : options.focusIndex, ".") : '';
};
var getValidationModes = mode => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some(watchName => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const {
          _f
        } = field,
        currentField = objectWithoutProperties_objectWithoutProperties(field, _excluded4);
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, 'root', error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isFileInput = element => element.type === 'file';
var isFunction = value => typeof value === 'function';
var isHTMLElement = value => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = value => isString(value);
var isRadioInput = element => element.type === 'radio';
var isRegex = value => value instanceof RegExp;
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = {
  value: true,
  isValid: true
};
var getCheckboxValue = options => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter(option => option && option.checked && !option.disabled).map(option => option.value);
      return {
        value: values,
        isValid: !!values.length
      };
    }
    return options[0].checked && !options[0].disabled ?
    // @ts-expect-error expected to work in the browser
    options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === '' ? validResult : {
      value: options[0].value,
      isValid: true
    } : validResult : defaultResult;
  }
  return defaultResult;
};
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref) {
  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : '',
      ref
    };
  }
}
var getValueAndMessage = validationData => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ''
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const {
    ref,
    refs,
    required,
    maxLength,
    minLength,
    min,
    max,
    pattern,
    validate,
    name,
    valueAsNumber,
    mount
  } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabledFieldNames.has(name)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = message => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === '' || inputValue === '' || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = function (exceedMax, maxLengthMessage, minLengthMessage) {
    let maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;
    let minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = _objectSpread2({
      type: exceedMax ? maxType : minType,
      message,
      ref
    }, appendErrorsCurry(exceedMax ? maxType : minType, message));
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const {
      value,
      message
    } = isMessage(required) ? {
      value: !!required,
      message: required
    } : getValueAndMessage(required);
    if (value) {
      error[name] = _objectSpread2({
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef
      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max);
    const minOutput = getValueAndMessage(min);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = time => new Date(new Date().toDateString() + ' ' + time);
      const isTime = ref.type == 'time';
      const isWeek = ref.type == 'week';
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const {
      value: patternValue,
      message
    } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = _objectSpread2({
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref
      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = _objectSpread2(_objectSpread2({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = _objectSpread2(_objectSpread2({}, validateError), appendErrorsCurry(key, validateError.message));
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = _objectSpread2({
          ref: inputRef
        }, validationResult);
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var appendAt = (data, value) => [...data, ...convertToArrayPayload(value)];
var fillEmptyArray = value => Array.isArray(value) ? value.map(() => undefined) : undefined;
function insert(data, index, value) {
  return [...data.slice(0, index), ...convertToArrayPayload(value), ...data.slice(index)];
}
var moveArrayAt = (data, from, to) => {
  if (!Array.isArray(data)) {
    return [];
  }
  if (isUndefined(data[to])) {
    data[to] = undefined;
  }
  data.splice(to, 0, data.splice(from, 1)[0]);
  return data;
};
var prependAt = (data, value) => [...convertToArrayPayload(value), ...convertToArrayPayload(data)];
function removeAtIndexes(data, indexes) {
  let i = 0;
  const temp = [...data];
  for (const index of indexes) {
    temp.splice(index - i, 1);
    i++;
  }
  return compact(temp).length ? temp : [];
}
var removeArrayAt = (data, index) => isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));
var swapArrayAt = (data, indexA, indexB) => {
  [data[indexA], data[indexB]] = [data[indexB], data[indexA]];
};
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index = 0;
  while (index < length) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index = paths.length - 1;
  const key = paths[index];
  if (childObject) {
    delete childObject[key];
  }
  if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var updateAt = (fieldValues, index, value) => {
  fieldValues[index] = value;
  return fieldValues;
};

/**
 * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. ‚Ä¢ [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) ‚Ä¢ [Video](https://youtu.be/4MrbfGSFY2A)
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/usefieldarray) ‚Ä¢ [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)
 *
 * @param props - useFieldArray props
 *
 * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({
 *     defaultValues: {
 *       test: []
 *     }
 *   });
 *   const { fields, append } = useFieldArray({
 *     control,
 *     name: "test"
 *   });
 *
 *   return (
 *     <form onSubmit={handleSubmit(data => console.log(data))}>
 *       {fields.map((item, index) => (
 *          <input key={item.id} {...register(`test.${index}.firstName`)}  />
 *       ))}
 *       <button type="button" onClick={() => append({ firstName: "bill" })}>
 *         append
 *       </button>
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFieldArray(props) {
  const methods = useFormContext();
  const {
    control = methods.control,
    name,
    keyName = 'id',
    shouldUnregister,
    rules
  } = props;
  const [fields, setFields] = React.useState(control._getFieldArray(name));
  const ids = React.useRef(control._getFieldArray(name).map(generateId));
  const _fieldIds = React.useRef(fields);
  const _name = React.useRef(name);
  const _actioned = React.useRef(false);
  _name.current = name;
  _fieldIds.current = fields;
  control._names.array.add(name);
  rules && control.register(name, rules);
  useSubscribe({
    next: _ref => {
      let {
        values,
        name: fieldArrayName
      } = _ref;
      if (fieldArrayName === _name.current || !fieldArrayName) {
        const fieldValues = get(values, _name.current);
        if (Array.isArray(fieldValues)) {
          setFields(fieldValues);
          ids.current = fieldValues.map(generateId);
        }
      }
    },
    subject: control._subjects.array
  });
  const updateValues = React.useCallback(updatedFieldArrayValues => {
    _actioned.current = true;
    control._updateFieldArray(name, updatedFieldArrayValues);
  }, [control, name]);
  const append = (value, options) => {
    const appendValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);
    control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);
    ids.current = appendAt(ids.current, appendValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {
      argA: fillEmptyArray(value)
    });
  };
  const prepend = (value, options) => {
    const prependValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);
    control._names.focus = getFocusFieldName(name, 0, options);
    ids.current = prependAt(ids.current, prependValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {
      argA: fillEmptyArray(value)
    });
  };
  const remove = index => {
    const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);
    ids.current = removeArrayAt(ids.current, index);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    !Array.isArray(get(control._fields, name)) && set(control._fields, name, undefined);
    control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {
      argA: index
    });
  };
  const insert$1 = (index, value, options) => {
    const insertValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);
    control._names.focus = getFocusFieldName(name, index, options);
    ids.current = insert(ids.current, index, insertValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, insert, {
      argA: index,
      argB: fillEmptyArray(value)
    });
  };
  const swap = (indexA, indexB) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    swapArrayAt(updatedFieldArrayValues, indexA, indexB);
    swapArrayAt(ids.current, indexA, indexB);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {
      argA: indexA,
      argB: indexB
    }, false);
  };
  const move = (from, to) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    moveArrayAt(updatedFieldArrayValues, from, to);
    moveArrayAt(ids.current, from, to);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {
      argA: from,
      argB: to
    }, false);
  };
  const update = (index, value) => {
    const updateValue = cloneObject(value);
    const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);
    ids.current = [...updatedFieldArrayValues].map((item, i) => !item || i === index ? generateId() : ids.current[i]);
    updateValues(updatedFieldArrayValues);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {
      argA: index,
      argB: updateValue
    }, true, false);
  };
  const replace = value => {
    const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value));
    ids.current = updatedFieldArrayValues.map(generateId);
    updateValues([...updatedFieldArrayValues]);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name, [...updatedFieldArrayValues], data => data, {}, true, false);
  };
  React.useEffect(() => {
    control._state.action = false;
    isWatched(name, control._names) && control._subjects.state.next(_objectSpread({}, control._formState));
    if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted)) {
      if (control._options.resolver) {
        control._executeSchema([name]).then(result => {
          const error = get(result.errors, name);
          const existingError = get(control._formState.errors, name);
          if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {
            error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);
            control._subjects.state.next({
              errors: control._formState.errors
            });
          }
        });
      } else {
        const field = get(control._fields, name);
        if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {
          validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then(error => !isEmptyObject(error) && control._subjects.state.next({
            errors: updateFieldArrayRootError(control._formState.errors, error, name)
          }));
        }
      }
    }
    control._subjects.values.next({
      name,
      values: _objectSpread({}, control._formValues)
    });
    control._names.focus && iterateFieldsByAction(control._fields, (ref, key) => {
      if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {
        ref.focus();
        return 1;
      }
      return;
    });
    control._names.focus = '';
    control._updateValid();
    _actioned.current = false;
  }, [fields, name, control]);
  React.useEffect(() => {
    !get(control._formValues, name) && control._updateFieldArray(name);
    return () => {
      (control._options.shouldUnregister || shouldUnregister) && control.unregister(name);
    };
  }, [name, control, keyName, shouldUnregister]);
  return {
    swap: React.useCallback(swap, [updateValues, name, control]),
    move: React.useCallback(move, [updateValues, name, control]),
    prepend: React.useCallback(prepend, [updateValues, name, control]),
    append: React.useCallback(append, [updateValues, name, control]),
    remove: React.useCallback(remove, [updateValues, name, control]),
    insert: React.useCallback(insert$1, [updateValues, name, control]),
    update: React.useCallback(update, [updateValues, name, control]),
    replace: React.useCallback(replace, [updateValues, name, control]),
    fields: React.useMemo(() => fields.map((field, index) => _objectSpread(_objectSpread({}, field), {}, {
      [keyName]: ids.current[index] || generateId()
    })), [fields, keyName])
  };
}
var createSubject = () => {
  let _observers = [];
  const next = value => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = observer => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter(o => o !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
};
var isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== 'ref') {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = element => element.type === "select-multiple";
var isRadioOrCheckbox = ref => isRadioInput(ref) || isCheckBoxInput(ref);
var live = ref => isHTMLElement(ref) && ref.isConnected;
var objectHasFunction = data => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data) {
  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : _objectSpread2({}, markFieldsDirty(data[key]));
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value, _ref2) => {
  let {
    valueAsNumber,
    valueAsDate,
    setValueAs
  } = _ref2;
  return isUndefined(value) ? value : valueAsNumber ? value === '' ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
};
function getFieldValue(_f) {
  const ref = _f.ref;
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(_ref3 => {
      let {
        value
      } = _ref3;
      return value;
    });
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = rule => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
const ASYNC_FUNCTION = 'AsyncFunction';
var hasPromiseValidation = fieldReference => !!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find(validateFunction => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = options => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split('.');
  while (names.length) {
    const fieldName = names.join('.');
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return {
        name
      };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
const defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let _options = _objectSpread2(_objectSpread2({}, defaultOptions), props);
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: new Set(),
    disabled: new Set(),
    unMount: new Set(),
    array: new Set(),
    watch: new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = callback => wait => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _updateValid = async shouldUpdateValid => {
    if (!_options.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {
      const isValid = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid !== _formState.isValid) {
        _subjects.state.next({
          isValid
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach(name => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _updateFieldArray = function (name) {
    let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let method = arguments.length > 2 ? arguments[2] : undefined;
    let args = arguments.length > 3 ? arguments[3] : undefined;
    let shouldSetValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    let shouldUpdateFieldsAndState = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = errors => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!_options.disabled) {
      const disabledField = !!(get(_fields, name) && get(_fields, name)._f && get(_fields, name)._f.disabled);
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = disabledField || deepEqual(get(_defaultValues, name), fieldValue);
        isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));
        isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;
    if (_options.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = _objectSpread2(_objectSpread2(_objectSpread2({}, fieldState), shouldUpdateValid && isBoolean(isValid) ? {
        isValid
      } : {}), {}, {
        errors: _formState.errors,
        name
      });
      _formState = _objectSpread2(_objectSpread2({}, _formState), updatedFormState);
      _subjects.state.next(updatedFormState);
    }
  };
  const _executeSchema = async name => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async names => {
    const {
      errors
    } = await _executeSchema(names);
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async function (fields, shouldOnlyCheckValid) {
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      valid: true
    };
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const {
            _f
          } = field,
          fieldValue = objectWithoutProperties_objectWithoutProperties(field, _excluded5);
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every(ref => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = new Set();
  };
  const _getDirty = (name, data) => !_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, _objectSpread2({}, _state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {
    [names]: defaultValue
  } : defaultValue), isGlobal, defaultValue);
  const _getFieldArray = name => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = function (name, value) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? '' : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach(optionRef => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach(checkboxRef => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find(data => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach(radioRef => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = '';
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: _objectSpread2({}, _formValues)
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = "".concat(name, ".").concat(fieldKey);
      const field = get(_fields, fieldName);
      (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = function (name, value) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: _objectSpread2({}, _formValues)
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next(_objectSpread2({}, _formState));
    _subjects.values.next({
      name: _state.mount ? name : undefined,
      values: _objectSpread2({}, _formValues)
    });
  };
  const onChange = async event => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = fieldValue => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));
    };
    if (field) {
      let error;
      let isValid;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name,
        type: event.type,
        values: _objectSpread2({}, _formValues)
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid) {
          if (_options.mode === 'onBlur' && isBlurEvent) {
            _updateValid();
          } else if (!isBlurEvent) {
            _updateValid();
          }
        }
        return shouldRender && _subjects.state.next(_objectSpread2({
          name
        }, watched ? {} : fieldState));
      }
      !isBlurEvent && watched && _subjects.state.next(_objectSpread2({}, _formState));
      if (_options.resolver) {
        const {
          errors
        } = await _executeSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid = false;
          } else if (_proxyFormState.isValid) {
            isValid = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async function (name) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let isValid;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some(name => get(errors, name)) : isValid;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async fieldName => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? {
          [fieldName]: field
        } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next(_objectSpread2(_objectSpread2(_objectSpread2({}, !isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : {
      name
    }), _options.resolver || !name ? {
      isValid
    } : {}), {}, {
      errors: _formState.errors
    }));
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = fieldNames => {
    const values = _objectSpread2({}, _state.mount ? _formValues : _defaultValues);
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map(name => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name)
  });
  const clearErrors = name => {
    name && convertToArrayPayload(name).forEach(inputName => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get(_fields, name, {
      _f: {}
    })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};
    // Don't override existing error messages elsewhere in the object tree.
    const {
        ref: currentRef,
        message,
        type
      } = currentError,
      restOfErrorTree = objectWithoutProperties_objectWithoutProperties(currentError, _excluded6);
    set(_formState.errors, name, _objectSpread2(_objectSpread2(_objectSpread2({}, restOfErrorTree), error), {}, {
      ref
    }));
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.values.subscribe({
    next: payload => name(_getWatch(undefined, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const unregister = function (name) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: _objectSpread2({}, _formValues)
    });
    _subjects.state.next(_objectSpread2(_objectSpread2({}, _formState), !options.keepDirty ? {} : {
      isDirty: _getDirty()
    }));
    !options.keepIsValid && _updateValid();
  };
  const _updateDisabledField = _ref4 => {
    let {
      disabled,
      name,
      field,
      fields
    } = _ref4;
    if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
      disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
      updateTouchAndDirty(name, getFieldValue(field ? field._f : get(fields, name)._f), false, false, true);
    }
  };
  const register = function (name) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
    set(_fields, name, _objectSpread2(_objectSpread2({}, field || {}), {}, {
      _f: _objectSpread2(_objectSpread2({}, field && field._f ? field._f : {
        ref: {
          name
        }
      }), {}, {
        name,
        mount: true
      }, options)
    }));
    _names.mount.add(name);
    if (field) {
      _updateDisabledField({
        field,
        disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,
        name
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return _objectSpread2(_objectSpread2(_objectSpread2({}, disabledIsDefined ? {
      disabled: options.disabled || _options.disabled
    } : {}), _options.progressive ? {
      required: !!options.required,
      min: getRuleValue(options.min),
      max: getRuleValue(options.max),
      minLength: getRuleValue(options.minLength),
      maxLength: getRuleValue(options.maxLength),
      pattern: getRuleValue(options.pattern)
    } : {}), {}, {
      name,
      onChange,
      onBlur: onChange,
      ref: ref => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll('input,select,textarea')[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find(option => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: _objectSpread2(_objectSpread2({}, field._f), radioOrCheckbox ? {
              refs: [...refs.filter(live), fieldRef, ...(Array.isArray(get(_defaultValues, name)) ? [{}] : [])],
              ref: {
                type: fieldRef.type,
                name
              }
            } : {
              ref: fieldRef
            })
          });
          updateValidAndValue(name, false, undefined, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    });
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = disabled => {
    if (isBoolean(disabled)) {
      _subjects.state.next({
        disabled
      });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach(inputRef => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async e => {
    let onValidError = undefined;
    if (e) {
      e.preventDefault && e.preventDefault();
      e.persist && e.persist();
    }
    let fieldValues = cloneObject(_formValues);
    if (_names.disabled.size) {
      for (const name of _names.disabled) {
        set(fieldValues, name, undefined);
      }
    }
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const {
        errors,
        values
      } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, 'root');
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid(_objectSpread2({}, _formState.errors), e);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = function (name) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next(_objectSpread2({}, _formState));
    }
  };
  const _reset = function (formValues) {
    let keepStateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = new Set([..._names.mount, ...Object.keys(getDirtyFields(_defaultValues, _formValues))]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest('form');
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
      _subjects.array.next({
        values: _objectSpread2({}, values)
      });
      _subjects.values.next({
        values: _objectSpread2({}, values)
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),
      unMount: new Set(),
      array: new Set(),
      disabled: new Set(),
      watch: new Set(),
      watchAll: false,
      focus: ''
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = function (name) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _updateFormState = updatedFormState => {
    _formState = _objectSpread2(_objectSpread2({}, _formState), updatedFormState);
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then(values => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = _objectSpread2(_objectSpread2({}, _options), value);
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}

/**
 * Custom hook to manage the entire form.
 *
 * @remarks
 * [API](https://react-hook-form.com/docs/useform) ‚Ä¢ [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) ‚Ä¢ [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
 *
 * @param props - form configuration and validation parameters.
 *
 * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   console.log(watch("example"));
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input defaultValue="test" {...register("example")} />
 *       <input {...register("exampleRequired", { required: true })} />
 *       {errors.exampleRequired && <span>This field is required</span>}
 *       <button>Submit</button>
 *     </form>
 *   );
 * }
 * ```
 */
function useForm() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const _formControl = react.useRef(undefined);
  const _values = react.useRef(undefined);
  const [formState, updateFormState] = react.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = _objectSpread2(_objectSpread2({}, createFormControl(props)), {}, {
      formState
    });
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: value => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState(_objectSpread2({}, control._formState));
      }
    }
  });
  react.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  react.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty
        });
      }
    }
  }, [control, formState.isDirty]);
  react.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState(state => _objectSpread2({}, state));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  react.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);
  react.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next(_objectSpread2({}, control._formState));
    }
    control._removeUnmounted();
  });
  react.useEffect(() => {
    props.shouldUnregister && control._subjects.values.next({
      values: control._getWatch()
    });
  }, [props.shouldUnregister, control]);
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}

;// ./src/features/an-amazing-journey/hooks/HandleMapEvents.tsx
/**
 * Disable map when mouse is over the panel
 * Enable map when mouse is out of the panel
 */function HandleMapEvents(panelRef){(0,react.useEffect)(()=>{var _panelRef$current,_panelRef$current2,_panelRef$current3,_panelRef$current4;const disableMapCallback=()=>{try{disableMap();}catch(e){error(e);}};(_panelRef$current=panelRef.current)===null||_panelRef$current===void 0?void 0:_panelRef$current.addEventListener("mouseover",disableMapCallback);(_panelRef$current2=panelRef.current)===null||_panelRef$current2===void 0?void 0:_panelRef$current2.addEventListener("touchstart",disableMapCallback);const enableMapCallback=()=>{try{enableMap();}catch(e){error(e);}};(_panelRef$current3=panelRef.current)===null||_panelRef$current3===void 0?void 0:_panelRef$current3.addEventListener("mouseout",enableMapCallback);(_panelRef$current4=panelRef.current)===null||_panelRef$current4===void 0?void 0:_panelRef$current4.addEventListener("touchend",enableMapCallback);return()=>{var _panelRef$current5,_panelRef$current6,_panelRef$current7,_panelRef$current8;(_panelRef$current5=panelRef.current)===null||_panelRef$current5===void 0?void 0:_panelRef$current5.removeEventListener("mouseover",disableMapCallback);(_panelRef$current6=panelRef.current)===null||_panelRef$current6===void 0?void 0:_panelRef$current6.removeEventListener("touchstart",disableMapCallback);(_panelRef$current7=panelRef.current)===null||_panelRef$current7===void 0?void 0:_panelRef$current7.removeEventListener("mouseout",enableMapCallback);// eslint-disable-next-line react-hooks/exhaustive-deps
(_panelRef$current8=panelRef.current)===null||_panelRef$current8===void 0?void 0:_panelRef$current8.removeEventListener("touchend",enableMapCallback);};},[panelRef]);}
;// ./src/hooks/storage.ts
// a hook to preserve state in a localstorage and get it at init
const STORAGE_PREFIX="STUFF_UNLOCKED.";const useLocalStorage=(key,initialValue)=>{const[value,setValue]=(0,react.useState)(()=>{const item=window.localStorage.getItem(STORAGE_PREFIX+key);if(item){return JSON.parse(item);}return initialValue;});(0,react.useEffect)(()=>{window.localStorage.setItem(STORAGE_PREFIX+key,JSON.stringify(value));},[key,value]);return[value,setValue];};
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(139);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(579);
;// ./src/features/an-amazing-journey/components/AutoTravellerPanel.tsx
let AutoTravelFormState=/*#__PURE__*/function(AutoTravelFormState){AutoTravelFormState[AutoTravelFormState["IDLE"]=0]="IDLE";AutoTravelFormState[AutoTravelFormState["STARTED"]=1]="STARTED";AutoTravelFormState[AutoTravelFormState["STOPPING"]=2]="STOPPING";return AutoTravelFormState;}({});const AutoTravellerPanel=props=>{const panelRef=(0,react.useRef)(null);const[formValuesFromStorage,setFormValues]=useLocalStorage("AnAmazingJourney.autoTravellerForm",{targetDistanceKm:"100000",resourceUsed:"preferTicket",travelBackAfterFinish:true});const{register,handleSubmit,formState:{errors},watch}=useForm({defaultValues:formValuesFromStorage});const formValues=watch();const stringifiedFormValues=JSON.stringify(formValues);(0,react.useEffect)(()=>{setFormValues(formValues);// eslint-disable-next-line react-hooks/exhaustive-deps
},[stringifiedFormValues]);HandleMapEvents(panelRef);const onStart=data=>{props.onStart(data);};const onStop=()=>{props.onStop();};return/*#__PURE__*/(0,jsx_runtime.jsxs)("section",{ref:panelRef,className:components_AutoTravellerPanel_module.panel,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("header",{className:components_AutoTravellerPanel_module.header,children:/*#__PURE__*/(0,jsx_runtime.jsx)("h2",{className:components_AutoTravellerPanel_module.title,children:"Auto Traveller"})}),/*#__PURE__*/(0,jsx_runtime.jsxs)("form",{className:components_AutoTravellerPanel_module.form,onSubmit:handleSubmit(onStart),autoComplete:"off",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset",{children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("label",_objectSpread2(_objectSpread2({className:components_AutoTravellerPanel_module.label},errors.targetDistanceKm&&{"data-tooltip":errors.targetDistanceKm.message}),{},{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Target distance (km)"}),/*#__PURE__*/(0,jsx_runtime.jsx)("input",_objectSpread2(_objectSpread2({},register("targetDistanceKm",{required:{value:true,message:"Please enter a distance"},pattern:{value:/^[0-9]*$/,message:"Must be a positive natural number."},min:{value:1,message:"Must be a positive natural number."}})),{},{className:classnames_default()(components_AutoTravellerPanel_module.input,{[components_AutoTravellerPanel_module.inputError]:errors.targetDistanceKm}),type:"text"}))]})),/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{className:components_AutoTravellerPanel_module.label,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Resource Used"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("select",_objectSpread2(_objectSpread2({},register("resourceUsed",{required:true})),{},{className:components_AutoTravellerPanel_module.select,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("option",{value:"preferCurrency",children:"Prefer Currency"}),/*#__PURE__*/(0,jsx_runtime.jsx)("option",{value:"preferTicket",children:"Prefer Tickets"})]}))]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("label",{className:components_AutoTravellerPanel_module.label,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Travel back after finish"}),/*#__PURE__*/(0,jsx_runtime.jsx)("input",_objectSpread2(_objectSpread2({},register("travelBackAfterFinish")),{},{className:components_AutoTravellerPanel_module.checkbox,type:"checkbox"}))]})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("section",{className:components_AutoTravellerPanel_module.actionBar,children:[props.state!==AutoTravelFormState.IDLE&&/*#__PURE__*/(0,jsx_runtime.jsx)("button",{className:components_AutoTravellerPanel_module.start,type:"button",onClick:onStop,disabled:props.state===AutoTravelFormState.STOPPING,children:"Stop"}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{className:components_AutoTravellerPanel_module.start,type:"submit",disabled:props.state!==AutoTravelFormState.IDLE,children:"Start"})]})]})]});};
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(391);
;// ./src/utils/render.ts
function renderElement(jsxElement){const rootElement=document.createElement("div");return renderElementWithRoot(jsxElement,rootElement);}function renderElementWithRoot(jsxElement,rootElement){const root=(0,client.createRoot)(rootElement);root.render(jsxElement);return{before:element=>{if(!element){throw Error("Can't find element to insert before");}element.insertAdjacentElement("beforebegin",rootElement);},after:element=>{if(!element){throw Error("Can't find element to insert after");}element.insertAdjacentElement("afterend",rootElement);}};}
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/an-amazing-journey/components/CollapseButtonPanel.module.scss
var CollapseButtonPanel_module = __webpack_require__(77);
;// ./src/features/an-amazing-journey/components/CollapseButtonPanel.module.scss

      
      
      
      
      
      
      
      
      

var CollapseButtonPanel_module_options = {};

CollapseButtonPanel_module_options.styleTagTransform = (styleTagTransform_default());
CollapseButtonPanel_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      CollapseButtonPanel_module_options.insert = insertBySelector_default().bind(null, "head");
    
CollapseButtonPanel_module_options.domAPI = (styleDomAPI_default());
CollapseButtonPanel_module_options.insertStyleElement = (insertStyleElement_default());

var CollapseButtonPanel_module_update = injectStylesIntoStyleTag_default()(CollapseButtonPanel_module/* default */.A, CollapseButtonPanel_module_options);




       /* harmony default export */ const components_CollapseButtonPanel_module = (CollapseButtonPanel_module/* default */.A && CollapseButtonPanel_module/* default */.A.locals ? CollapseButtonPanel_module/* default */.A.locals : undefined);

;// ./src/features/an-amazing-journey/components/CollapseButtonPanel.tsx
const CollapseButtonPanel=props=>{const panelRef=(0,react.useRef)(null);HandleMapEvents(panelRef);return/*#__PURE__*/(0,jsx_runtime.jsx)("section",{ref:panelRef,className:classnames_default()(components_CollapseButtonPanel_module.panel,{[components_CollapseButtonPanel_module.isCollapsed]:props.isCollapsed}),children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{className:classnames_default()(components_CollapseButtonPanel_module.button,{[components_CollapseButtonPanel_module.isCollapsed]:props.isCollapsed}),onClick:()=>props.onClick(!props.isCollapsed),title:props.isCollapsed?"Expand Auto Traveller":"Collapse Auto Traveller",children:/*#__PURE__*/(0,jsx_runtime.jsx)("svg",{fill:"#000000",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",children:/*#__PURE__*/(0,jsx_runtime.jsx)("path",{d:"M15.2928932,12 L12.1464466,8.85355339 C11.9511845,8.65829124 11.9511845,8.34170876 12.1464466,8.14644661 C12.3417088,7.95118446 12.6582912,7.95118446 12.8535534,8.14644661 L16.8535534,12.1464466 C17.0488155,12.3417088 17.0488155,12.6582912 16.8535534,12.8535534 L12.8535534,16.8535534 C12.6582912,17.0488155 12.3417088,17.0488155 12.1464466,16.8535534 C11.9511845,16.6582912 11.9511845,16.3417088 12.1464466,16.1464466 L15.2928932,13 L4.5,13 C4.22385763,13 4,12.7761424 4,12.5 C4,12.2238576 4.22385763,12 4.5,12 L15.2928932,12 Z M19,5.5 C19,5.22385763 19.2238576,5 19.5,5 C19.7761424,5 20,5.22385763 20,5.5 L20,19.5 C20,19.7761424 19.7761424,20 19.5,20 C19.2238576,20 19,19.7761424 19,19.5 L19,5.5 Z"})})})});};
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/an-amazing-journey/components/TravelProgressPanel.module.scss
var TravelProgressPanel_module = __webpack_require__(805);
;// ./src/features/an-amazing-journey/components/TravelProgressPanel.module.scss

      
      
      
      
      
      
      
      
      

var TravelProgressPanel_module_options = {};

TravelProgressPanel_module_options.styleTagTransform = (styleTagTransform_default());
TravelProgressPanel_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      TravelProgressPanel_module_options.insert = insertBySelector_default().bind(null, "head");
    
TravelProgressPanel_module_options.domAPI = (styleDomAPI_default());
TravelProgressPanel_module_options.insertStyleElement = (insertStyleElement_default());

var TravelProgressPanel_module_update = injectStylesIntoStyleTag_default()(TravelProgressPanel_module/* default */.A, TravelProgressPanel_module_options);




       /* harmony default export */ const components_TravelProgressPanel_module = (TravelProgressPanel_module/* default */.A && TravelProgressPanel_module/* default */.A.locals ? TravelProgressPanel_module/* default */.A.locals : undefined);

;// ./src/utils/format.ts
function formatNumber(number){return number.toLocaleString("en-US");}function formatStringNumberToInt(value){const string=String(value);return parseInt(string);}
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/an-amazing-journey/components/StatusIndicator.module.scss
var StatusIndicator_module = __webpack_require__(565);
;// ./src/features/an-amazing-journey/components/StatusIndicator.module.scss

      
      
      
      
      
      
      
      
      

var StatusIndicator_module_options = {};

StatusIndicator_module_options.styleTagTransform = (styleTagTransform_default());
StatusIndicator_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      StatusIndicator_module_options.insert = insertBySelector_default().bind(null, "head");
    
StatusIndicator_module_options.domAPI = (styleDomAPI_default());
StatusIndicator_module_options.insertStyleElement = (insertStyleElement_default());

var StatusIndicator_module_update = injectStylesIntoStyleTag_default()(StatusIndicator_module/* default */.A, StatusIndicator_module_options);




       /* harmony default export */ const components_StatusIndicator_module = (StatusIndicator_module/* default */.A && StatusIndicator_module/* default */.A.locals ? StatusIndicator_module/* default */.A.locals : undefined);

;// ./src/features/an-amazing-journey/components/StatusIndicator.tsx
const StatusIndicator=props=>{return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_StatusIndicator_module.statusIndicator,children:[props.status===TravelProgressStatus.InProgress&&/*#__PURE__*/(0,jsx_runtime.jsxs)("svg",{width:"24",height:"24",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",className:components_StatusIndicator_module.inProgress,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("path",{d:"M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z",fill:"currentColor",opacity:".25"}),/*#__PURE__*/(0,jsx_runtime.jsx)("path",{d:"M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z",fill:"currentColor",className:components_StatusIndicator_module.spinner})]}),props.status===TravelProgressStatus.Completed&&/*#__PURE__*/(0,jsx_runtime.jsx)("svg",{height:"24",width:"24",viewBox:"0 -960 960 960",xmlns:"http://www.w3.org/2000/svg",className:components_StatusIndicator_module.completed,children:/*#__PURE__*/(0,jsx_runtime.jsx)("path",{fill:"currentColor",d:"m424-296 282-282-56-56-226 226-114-114-56 56 170 170Zm56 216q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"})}),props.status===TravelProgressStatus.Error&&/*#__PURE__*/(0,jsx_runtime.jsx)("svg",{height:"24",width:"24",viewBox:"0 -960 960 960",xmlns:"http://www.w3.org/2000/svg",className:components_StatusIndicator_module.error,children:/*#__PURE__*/(0,jsx_runtime.jsx)("path",{fill:"currentColor",d:"M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240Zm40 360q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"})})]});};
;// ./src/features/an-amazing-journey/components/TravelProgressPanel.tsx
let TravelProgressStatus=/*#__PURE__*/function(TravelProgressStatus){TravelProgressStatus[TravelProgressStatus["InProgress"]=0]="InProgress";TravelProgressStatus[TravelProgressStatus["Completed"]=1]="Completed";TravelProgressStatus[TravelProgressStatus["Error"]=2]="Error";return TravelProgressStatus;}({});const TravelProgressPanel=props=>{const panelRef=(0,react.useRef)(null);HandleMapEvents(panelRef);return/*#__PURE__*/(0,jsx_runtime.jsxs)("section",{ref:panelRef,className:components_TravelProgressPanel_module.panel,children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("header",{className:components_TravelProgressPanel_module.header,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("h2",{className:components_TravelProgressPanel_module.title,children:"Travel Progress"}),/*#__PURE__*/(0,jsx_runtime.jsx)(StatusIndicator,{status:props.state.status})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_TravelProgressPanel_module.rows,children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_TravelProgressPanel_module.row,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:components_TravelProgressPanel_module.key,children:"Travels"}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:components_TravelProgressPanel_module.value,children:formatNumber(props.state.travelsCompleted)})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_TravelProgressPanel_module.row,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:components_TravelProgressPanel_module.key,children:"Distance"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{className:components_TravelProgressPanel_module.value,children:[formatNumber(props.state.travelledDistanceKm)," km"]})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_TravelProgressPanel_module.row,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:components_TravelProgressPanel_module.key,children:"Resources"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{className:components_TravelProgressPanel_module.value,children:[formatNumber(props.state.resourcesSpent.amount)," ",props.state.resourcesSpent.unit]})]})]})]});};
;// ./src/requests/travel-request.ts
let Travel;(function(_Travel){async function sendRequest(body){const response=fetch("https://www.erepublik.com/en/main/travel",{method:"POST",headers:_objectSpread2({"content-type":"application/x-www-form-urlencoded"},getCookieHeaders()),body:objectToWwwFormUrlEncoded(body)});return response.then(response=>response.json());}_Travel.sendRequest=sendRequest;})(Travel||(Travel={}));
;// ./src/features/an-amazing-journey/regions.ts
const MazuriaRegionId="423";const MazoviaRegionId="424";const travelRouteTest={regionIdA:MazuriaRegionId,regionIdB:MazoviaRegionId};const WellingtonRegionId="714";const CastillaYLeonRegionId="173";const travelRouteMain={regionIdA:CastillaYLeonRegionId,regionIdB:WellingtonRegionId};function findCountryIdFor(regionId,countries){var _Object$values$find;const countryId=(_Object$values$find=Object.values(countries).find(country=>{const currentRegions=country.currentRegions;if(typeof currentRegions==="number"){return currentRegions===Number(regionId);}if(typeof currentRegions==="string"){return currentRegions.split(",").includes(regionId);}return false;}))===null||_Object$values$find===void 0?void 0:_Object$values$find.id;if(!countryId){throw new Error("Cannot find countryId for regionId ".concat(regionId));}return String(countryId);}
;// ./src/features/an-amazing-journey/travel.ts
function createNewTravelProgressState(unit){return{status:TravelProgressStatus.InProgress,travelledDistanceKm:0,travelsCompleted:0,resourcesSpent:{amount:0,unit:unit}};}async function executeTravel(nextTargetRegionId,form,countriesCache){let travelInfo;try{log("Getting travel info for region ".concat(nextTargetRegionId,"..."));travelInfo=await getTravelInfoTo(nextTargetRegionId);log("Got travel info for region ".concat(nextTargetRegionId),travelInfo);}catch(e){throw Error("Failed to get travel info for region ".concat(nextTargetRegionId),{cause:e});}try{log("Travelling to region ".concat(nextTargetRegionId,"..."));await travelTo(nextTargetRegionId,form.resourceUsed,countriesCache);log("Travelled to region ".concat(nextTargetRegionId));}catch(e){throw Error("Failed to travel to region ".concat(nextTargetRegionId),{cause:e});}return travelInfo;}async function getTravelInfoTo(regionId){const response=await TravelData.sendRequest({_token:getCsrfToken(),battleId:"0",regionId:regionId,holdingId:"0"});return{distanceKm:response.regions[regionId].distanceInKm,currencyCost:response.regions[regionId].cost,ticketCost:response.regions[regionId].ticketAmount};}async function travelTo(regionId,travelMethod,countriesCache){const response=await Travel.sendRequest({_token:getCsrfToken(),travelMethod:travelMethod,battleId:"0",inRegionId:regionId,toCountryId:findCountryIdFor(regionId,await countriesCache.getCountries())});if(response.error===1){throw Error("Failed to travel to ".concat(regionId,": ").concat(response.message));}}
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/an-amazing-journey/components/ErrorPanel.module.scss
var ErrorPanel_module = __webpack_require__(576);
;// ./src/features/an-amazing-journey/components/ErrorPanel.module.scss

      
      
      
      
      
      
      
      
      

var ErrorPanel_module_options = {};

ErrorPanel_module_options.styleTagTransform = (styleTagTransform_default());
ErrorPanel_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      ErrorPanel_module_options.insert = insertBySelector_default().bind(null, "head");
    
ErrorPanel_module_options.domAPI = (styleDomAPI_default());
ErrorPanel_module_options.insertStyleElement = (insertStyleElement_default());

var ErrorPanel_module_update = injectStylesIntoStyleTag_default()(ErrorPanel_module/* default */.A, ErrorPanel_module_options);




       /* harmony default export */ const components_ErrorPanel_module = (ErrorPanel_module/* default */.A && ErrorPanel_module/* default */.A.locals ? ErrorPanel_module/* default */.A.locals : undefined);

;// ./src/features/an-amazing-journey/components/ErrorPanel.tsx
const ErrorPanel=props=>{const panelRef=(0,react.useRef)(null);HandleMapEvents(panelRef);return/*#__PURE__*/(0,jsx_runtime.jsxs)("section",{ref:panelRef,className:components_ErrorPanel_module.panel,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:components_ErrorPanel_module.errors,children:props.errors.map((error,index)=>{var _error$cause;return/*#__PURE__*/(0,jsx_runtime.jsxs)("p",{className:components_ErrorPanel_module.error,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:error.toString()}),(error.cause||null)&&/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("br",{}),"Caused by: ",(_error$cause=error.cause)===null||_error$cause===void 0?void 0:_error$cause.toString()]})]},index);})}),/*#__PURE__*/(0,jsx_runtime.jsx)("button",{className:components_ErrorPanel_module.close,title:"Dismiss",onClick:props.onClose,children:/*#__PURE__*/(0,jsx_runtime.jsx)("svg",{width:"24",height:"24",viewBox:"0 -960 960 960",xmlns:"http://www.w3.org/2000/svg",children:/*#__PURE__*/(0,jsx_runtime.jsx)("path",{fill:"currentColor",d:"m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"})})})]});};
;// ./src/features/an-amazing-journey/index.tsx
const countriesCache=new CountriesCache();const TIMER_INTERVAL_MS=5000;const currentTravelRoute=travelRouteMain;const AnAmazingJourneyFeature=createFeature({id:"amazing_journey",name:"An Amazing Journey",description:"An Amazing Journey is a feature where you auto travel between 2 locations to maximize efficiency of a distance travel.",canExecute:url=>url.href.includes("/main/anniversaryQuest"),execute:async()=>{renderElement(/*#__PURE__*/(0,jsx_runtime.jsx)(JourneyFeatureComponent,{})).before(document.querySelector("#cityInfoTopPopup"));}});const JourneyFeatureComponent=()=>{const[isCollapsed,setIsCollapsed]=useLocalStorage("AnAmazingJourney.isCollapsed",false);const[travelProgressState,setTravelProgressState]=(0,react.useState)();const[travelFormState,setTravelFormState]=(0,react.useState)(AutoTravelFormState.IDLE);const[shouldStop,setShouldStop]=(0,react.useState)(false);const shouldStopRef=(0,react.useRef)(shouldStop);(0,react.useEffect)(()=>{shouldStopRef.current=shouldStop;},[shouldStop]);const[errors,setErrors]=(0,react.useState)([]);const onStart=async form=>{log("Starting...",form);setTravelFormState(AutoTravelFormState.STARTED);const currencyUnit=form.resourceUsed==="preferCurrency"?getCitizenshipCurrencyName():"tickets";let travelledDistanceKm=0;setTravelProgressState(createNewTravelProgressState(currencyUnit));const initialRegionId=await countriesCache.getCurrentRegionId({skipCache:true});let nextTargetRegionId=initialRegionId===currentTravelRoute.regionIdA?currentTravelRoute.regionIdB:currentTravelRoute.regionIdA;let setIntervalId;const handleStop=async errorMessage=>{if(errorMessage){log("Stopping due to error: ".concat(errorMessage));}else{log("Stopping...");}const stopInternalHandler=async()=>{setShouldStop(false);setTravelProgressState(state=>{if(state){return _objectSpread2(_objectSpread2({},state),{},{status:errorMessage?TravelProgressStatus.Error:TravelProgressStatus.Completed,errorMessage});}return state;});// Stop button should be disabled immediately
setTravelFormState(AutoTravelFormState.STOPPING);// Start button should be enabled after 5 seconds
// to prevent spamming the server
setTimeout(()=>{setTravelFormState(AutoTravelFormState.IDLE);},TIMER_INTERVAL_MS);};clearInterval(setIntervalId);const isInInitialRegion=(await countriesCache.getCurrentRegionId({skipCache:true}))===initialRegionId;if(form.travelBackAfterFinish&&!isInInitialRegion){log("Waiting ".concat(TIMER_INTERVAL_MS,"ms to travel back..."));setTimeout(async()=>{const travelInfo=await executeTravel(initialRegionId,form,countriesCache);updateTravelProgressState(travelInfo);stopInternalHandler();},TIMER_INTERVAL_MS);}else{log("Stopping immediately...");stopInternalHandler();}};function updateTravelProgressState(travelInfo){const resourcesAmountSpentThisTravel=form.resourceUsed==="preferTicket"?travelInfo.ticketCost:travelInfo.currencyCost;travelledDistanceKm+=travelInfo.distanceKm;setTravelProgressState(state=>{if(state){return _objectSpread2(_objectSpread2({},state),{},{travelledDistanceKm:travelledDistanceKm,travelsCompleted:state.travelsCompleted+1,resourcesSpent:{amount:state.resourcesSpent.amount+resourcesAmountSpentThisTravel,unit:state.resourcesSpent.unit}});}return state;});}const callbackLogic=async()=>{if(shouldStopRef.current){await handleStop();return;}let travelInfo=await executeTravel(nextTargetRegionId,form,countriesCache);updateTravelProgressState(travelInfo);nextTargetRegionId=nextTargetRegionId===currentTravelRoute.regionIdA?currentTravelRoute.regionIdB:currentTravelRoute.regionIdA;if(travelledDistanceKm>=Number(form.targetDistanceKm)){await handleStop();}};const callback=async()=>{try{await callbackLogic();}catch(e){setErrors(errors=>[...errors,e]);error(e);try{await handleStop(e.message);}catch(e2){setErrors(errors=>[...errors,e2]);error(e2);}}};await callback();setIntervalId=window.setInterval(callback,TIMER_INTERVAL_MS);};const onStop=()=>{log("Stopping manually...");setTravelFormState(AutoTravelFormState.STOPPING);setShouldStop(true);};const onErrorClose=()=>{setErrors([]);};return/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)(CollapseButtonPanel,{isCollapsed:isCollapsed,onClick:setIsCollapsed}),!isCollapsed&&/*#__PURE__*/(0,jsx_runtime.jsx)(AutoTravellerPanel,{onStart:onStart,onStop:onStop,state:travelFormState}),!isCollapsed&&travelProgressState&&/*#__PURE__*/(0,jsx_runtime.jsx)(TravelProgressPanel,{state:travelProgressState}),errors.length>0&&/*#__PURE__*/(0,jsx_runtime.jsx)(ErrorPanel,{onClose:onErrorClose,errors:errors})]});};
;// ./node_modules/posthog-js/dist/module.js
var e,
  t = "undefined" != typeof window ? window : void 0,
  i = "undefined" != typeof globalThis ? globalThis : t,
  r = Array.prototype,
  s = r.forEach,
  n = r.indexOf,
  o = null == i ? void 0 : i.navigator,
  a = null == i ? void 0 : i.document,
  l = null == i ? void 0 : i.location,
  u = null == i ? void 0 : i.fetch,
  c = null != i && i.XMLHttpRequest && "withCredentials" in new i.XMLHttpRequest() ? i.XMLHttpRequest : void 0,
  d = null == i ? void 0 : i.AbortController,
  h = null == o ? void 0 : o.userAgent,
  _ = null != t ? t : {},
  p = {
    DEBUG: !1,
    LIB_VERSION: "1.211.0"
  },
  v = "$copy_autocapture",
  g = ["$snapshot", "$pageview", "$pageleave", "$set", "survey dismissed", "survey sent", "survey shown", "$identify", "$groupidentify", "$create_alias", "$$client_ingestion_warning", "$web_experiment_applied", "$feature_enrollment_update", "$feature_flag_called"];
!function (e) {
  e.GZipJS = "gzip-js", e.Base64 = "base64";
}(e || (e = {}));
var f = (/* unused pure expression or super */ null && (["fatal", "error", "warning", "log", "info", "debug"]));
function m(e, t) {
  return -1 !== e.indexOf(t);
}
var b = function (e) {
    return e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  },
  y = function (e) {
    return e.replace(/^\$/, "");
  };
var w = Array.isArray,
  S = Object.prototype,
  E = S.hasOwnProperty,
  k = S.toString,
  x = w || function (e) {
    return "[object Array]" === k.call(e);
  },
  I = e => "function" == typeof e,
  C = e => e === Object(e) && !x(e),
  P = e => {
    if (C(e)) {
      for (var t in e) if (E.call(e, t)) return !1;
      return !0;
    }
    return !1;
  },
  R = e => void 0 === e,
  F = e => "[object String]" == k.call(e),
  T = e => F(e) && 0 === e.trim().length,
  $ = e => null === e,
  O = e => R(e) || $(e),
  M = e => "[object Number]" == k.call(e),
  L = e => "[object Boolean]" === k.call(e),
  A = e => e instanceof FormData,
  D = e => m(g, e),
  N = e => {
    var i = {
      _log: function (i) {
        if (t && (p.DEBUG || _.POSTHOG_DEBUG) && !R(t.console) && t.console) {
          for (var r = ("__rrweb_original__" in t.console[i]) ? t.console[i].__rrweb_original__ : t.console[i], s = arguments.length, n = new Array(s > 1 ? s - 1 : 0), o = 1; o < s; o++) n[o - 1] = arguments[o];
          r(e, ...n);
        }
      },
      info: function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
        i._log("log", ...t);
      },
      warn: function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
        i._log("warn", ...t);
      },
      error: function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
        i._log("error", ...t);
      },
      critical: function () {
        for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
        console.error(e, ...i);
      },
      uninitializedWarning: e => {
        i.error("You must initialize PostHog before calling ".concat(e));
      },
      createLogger: t => N("".concat(e, " ").concat(t))
    };
    return i;
  },
  q = N("[PostHog.js]"),
  B = q.createLogger,
  H = B("[ExternalScriptsLoader]"),
  U = (e, t, i) => {
    if (e.config.disable_external_dependency_loading) return H.warn("".concat(t, " was requested but loading of external scripts is disabled.")), i("Loading of external scripts is disabled");
    var r = () => {
      if (!a) return i("document not found");
      var r = a.createElement("script");
      if (r.type = "text/javascript", r.crossOrigin = "anonymous", r.src = t, r.onload = e => i(void 0, e), r.onerror = e => i(e), e.config.prepare_external_dependency_script && (r = e.config.prepare_external_dependency_script(r)), !r) return i("prepare_external_dependency_script returned null");
      var s,
        n = a.querySelectorAll("body > script");
      n.length > 0 ? null === (s = n[0].parentNode) || void 0 === s || s.insertBefore(r, n[0]) : a.body.appendChild(r);
    };
    null != a && a.body ? r() : null == a || a.addEventListener("DOMContentLoaded", r);
  };
function z(e, t) {
  var i = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function (t) {
      return Object.getOwnPropertyDescriptor(e, t).enumerable;
    })), i.push.apply(i, r);
  }
  return i;
}
function j(e) {
  for (var t = 1; t < arguments.length; t++) {
    var i = null != arguments[t] ? arguments[t] : {};
    t % 2 ? z(Object(i), !0).forEach(function (t) {
      W(e, t, i[t]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : z(Object(i)).forEach(function (t) {
      Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
    });
  }
  return e;
}
function W(e, t, i) {
  return t in e ? Object.defineProperty(e, t, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = i, e;
}
function V(e, t) {
  if (null == e) return {};
  var i,
    r,
    s = function (e, t) {
      if (null == e) return {};
      var i,
        r,
        s = {},
        n = Object.keys(e);
      for (r = 0; r < n.length; r++) i = n[r], t.indexOf(i) >= 0 || (s[i] = e[i]);
      return s;
    }(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) i = n[r], t.indexOf(i) >= 0 || Object.prototype.propertyIsEnumerable.call(e, i) && (s[i] = e[i]);
  }
  return s;
}
_.__PosthogExtensions__ = _.__PosthogExtensions__ || {}, _.__PosthogExtensions__.loadExternalDependency = (e, t, i) => {
  var r = "/static/".concat(t, ".js") + "?v=".concat(e.version);
  if ("remote-config" === t && (r = "/array/".concat(e.config.token, "/config.js")), "toolbar" === t) {
    var s = 3e5,
      n = Math.floor(Date.now() / s) * s;
    r = "".concat(r, "&t=").concat(n);
  }
  var o = e.requestRouter.endpointFor("assets", r);
  U(e, o, i);
}, _.__PosthogExtensions__.loadSiteApp = (e, t, i) => {
  var r = e.requestRouter.endpointFor("api", t);
  U(e, r, i);
};
var G = {};
function J(e, t, i) {
  if (x(e)) if (s && e.forEach === s) e.forEach(t, i);else if ("length" in e && e.length === +e.length) for (var r = 0, n = e.length; r < n; r++) if (r in e && t.call(i, e[r], r) === G) return;
}
function Y(e, t, i) {
  if (!O(e)) {
    if (x(e)) return J(e, t, i);
    if (A(e)) {
      for (var r of e.entries()) if (t.call(i, r[1], r[0]) === G) return;
    } else for (var s in e) if (E.call(e, s) && t.call(i, e[s], s) === G) return;
  }
}
var K = function (e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    return J(i, function (t) {
      for (var i in t) void 0 !== t[i] && (e[i] = t[i]);
    }), e;
  },
  X = function (e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    return J(i, function (t) {
      J(t, function (t) {
        e.push(t);
      });
    }), e;
  };
function Q(e) {
  for (var t = Object.keys(e), i = t.length, r = new Array(i); i--;) r[i] = [t[i], e[t[i]]];
  return r;
}
var Z = function (e) {
    try {
      return e();
    } catch (e) {
      return;
    }
  },
  ee = function (e) {
    return function () {
      try {
        for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
        return e.apply(this, i);
      } catch (e) {
        q.critical("Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."), q.critical(e);
      }
    };
  },
  te = function (e) {
    var t = {};
    return Y(e, function (e, i) {
      F(e) && e.length > 0 && (t[i] = e);
    }), t;
  };
function ie(e, t) {
  return i = e, r = e => F(e) && !$(t) ? e.slice(0, t) : e, s = new Set(), function e(t, i) {
    return t !== Object(t) ? r ? r(t, i) : t : s.has(t) ? void 0 : (s.add(t), x(t) ? (n = [], J(t, t => {
      n.push(e(t));
    })) : (n = {}, Y(t, (t, i) => {
      s.has(t) || (n[i] = e(t, i));
    })), n);
    var n;
  }(i);
  var i, r, s;
}
var re = function () {
    function e(t) {
      return t && (t.preventDefault = e.preventDefault, t.stopPropagation = e.stopPropagation), t;
    }
    return e.preventDefault = function () {
      this.returnValue = !1;
    }, e.stopPropagation = function () {
      this.cancelBubble = !0;
    }, function (i, r, s, n, o) {
      if (i) {
        if (i.addEventListener && !n) i.addEventListener(r, s, !!o);else {
          var a = "on" + r,
            l = i[a];
          i[a] = function (i, r, s) {
            return function (n) {
              if (n = n || e(null == t ? void 0 : t.event)) {
                var o,
                  a = !0;
                I(s) && (o = s(n));
                var l = r.call(i, n);
                return !1 !== o && !1 !== l || (a = !1), a;
              }
            };
          }(i, s, l);
        }
      } else q.error("No valid element provided to register_event");
    };
  }(),
  se = ["herokuapp.com", "vercel.app", "netlify.app"];
function ne(e) {
  var t = null == e ? void 0 : e.hostname;
  if (!F(t)) return !1;
  var i = t.split(".").slice(-2).join(".");
  for (var r of se) if (i === r) return !1;
  return !0;
}
function oe(e, t) {
  for (var i = 0; i < e.length; i++) if (t(e[i])) return e[i];
}
var ae = "$people_distinct_id",
  le = "__alias",
  ue = "__timers",
  ce = "$autocapture_disabled_server_side",
  de = "$heatmaps_enabled_server_side",
  he = "$exception_capture_enabled_server_side",
  _e = "$web_vitals_enabled_server_side",
  pe = "$dead_clicks_enabled_server_side",
  ve = "$web_vitals_allowed_metrics",
  ge = "$session_recording_enabled_server_side",
  fe = "$console_log_recording_enabled_server_side",
  me = "$session_recording_network_payload_capture",
  be = "$session_recording_canvas_recording",
  ye = "$replay_sample_rate",
  we = "$replay_minimum_duration",
  Se = "$replay_script_config",
  Ee = "$sesid",
  ke = "$session_is_sampled",
  xe = "$session_recording_url_trigger_activated_session",
  Ie = "$session_recording_event_trigger_activated_session",
  Ce = "$enabled_feature_flags",
  Pe = "$early_access_features",
  Re = "$stored_person_properties",
  Fe = "$stored_group_properties",
  Te = "$surveys",
  $e = "$surveys_activated",
  Oe = "$flag_call_reported",
  Me = "$user_state",
  Le = "$client_session_props",
  Ae = "$capture_rate_limit",
  De = "$initial_campaign_params",
  Ne = "$initial_referrer_info",
  qe = "$initial_person_info",
  Be = "$epp",
  He = "__POSTHOG_TOOLBAR__",
  Ue = "$posthog_cookieless",
  ze = [ae, le, "__cmpns", ue, ge, de, Ee, Ce, Me, Pe, Fe, Re, Te, Oe, Le, Ae, De, Ne, Be],
  je = B("[FeatureFlags]"),
  We = "$active_feature_flags",
  Ve = "$override_feature_flags",
  Ge = "$feature_flag_payloads",
  Je = e => {
    var t = {};
    for (var [i, r] of Q(e || {})) r && (t[i] = r);
    return t;
  };
class Ye {
  constructor(e) {
    W(this, "_override_warning", !1), W(this, "_hasLoadedFlags", !1), W(this, "_requestInFlight", !1), W(this, "_reloadingDisabled", !1), W(this, "_additionalReloadRequested", !1), W(this, "_decideCalled", !1), W(this, "_flagsLoadedFromRemote", !1), this.instance = e, this.featureFlagEventHandlers = [];
  }
  decide() {
    if (this.instance.config.__preview_remote_config) this._decideCalled = !0;else {
      var e = !this._reloadDebouncer && (this.instance.config.advanced_disable_feature_flags || this.instance.config.advanced_disable_feature_flags_on_first_load);
      this._callDecideEndpoint({
        disableFlags: e
      });
    }
  }
  get hasLoadedFlags() {
    return this._hasLoadedFlags;
  }
  getFlags() {
    return Object.keys(this.getFlagVariants());
  }
  getFlagVariants() {
    var e = this.instance.get_property(Ce),
      t = this.instance.get_property(Ve);
    if (!t) return e || {};
    for (var i = K({}, e), r = Object.keys(t), s = 0; s < r.length; s++) i[r[s]] = t[r[s]];
    return this._override_warning || (je.warn(" Overriding feature flags!", {
      enabledFlags: e,
      overriddenFlags: t,
      finalFlags: i
    }), this._override_warning = !0), i;
  }
  getFlagPayloads() {
    return this.instance.get_property(Ge) || {};
  }
  reloadFeatureFlags() {
    this._reloadingDisabled || this.instance.config.advanced_disable_feature_flags || this._reloadDebouncer || (this._reloadDebouncer = setTimeout(() => {
      this._callDecideEndpoint();
    }, 5));
  }
  clearDebouncer() {
    clearTimeout(this._reloadDebouncer), this._reloadDebouncer = void 0;
  }
  ensureFlagsLoaded() {
    this._hasLoadedFlags || this._requestInFlight || this._reloadDebouncer || this.reloadFeatureFlags();
  }
  setAnonymousDistinctId(e) {
    this.$anon_distinct_id = e;
  }
  setReloadingPaused(e) {
    this._reloadingDisabled = e;
  }
  _callDecideEndpoint(t) {
    if (this.clearDebouncer(), !this.instance.config.advanced_disable_decide) if (this._requestInFlight) this._additionalReloadRequested = !0;else {
      var i = {
        token: this.instance.config.token,
        distinct_id: this.instance.get_distinct_id(),
        groups: this.instance.getGroups(),
        $anon_distinct_id: this.$anon_distinct_id,
        person_properties: this.instance.get_property(Re),
        group_properties: this.instance.get_property(Fe)
      };
      (null != t && t.disableFlags || this.instance.config.advanced_disable_feature_flags) && (i.disable_flags = !0), this._requestInFlight = !0, this.instance._send_request({
        method: "POST",
        url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"),
        data: i,
        compression: this.instance.config.disable_compression ? void 0 : e.Base64,
        timeout: this.instance.config.feature_flag_request_timeout_ms,
        callback: e => {
          var t,
            r,
            s = !0;
          (200 === e.statusCode && (this.$anon_distinct_id = void 0, s = !1), this._requestInFlight = !1, this._decideCalled) || (this._decideCalled = !0, this.instance._onRemoteConfig(null !== (r = e.json) && void 0 !== r ? r : {}));
          i.disable_flags || (this._flagsLoadedFromRemote = !s, this.receivedFeatureFlags(null !== (t = e.json) && void 0 !== t ? t : {}, s), this._additionalReloadRequested && (this._additionalReloadRequested = !1, this._callDecideEndpoint()));
        }
      });
    }
  }
  getFeatureFlag(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0) {
      var i,
        r,
        s,
        n,
        o,
        a = this.getFlagVariants()[e],
        l = "".concat(a),
        u = this.instance.get_property(Oe) || {};
      if (t.send_event || !("send_event" in t)) if (!(e in u) || !u[e].includes(l)) x(u[e]) ? u[e].push(l) : u[e] = [l], null === (i = this.instance.persistence) || void 0 === i || i.register({
        [Oe]: u
      }), this.instance.capture("$feature_flag_called", {
        $feature_flag: e,
        $feature_flag_response: a,
        $feature_flag_payload: this.getFeatureFlagPayload(e) || null,
        $feature_flag_bootstrapped_response: (null === (r = this.instance.config.bootstrap) || void 0 === r || null === (s = r.featureFlags) || void 0 === s ? void 0 : s[e]) || null,
        $feature_flag_bootstrapped_payload: (null === (n = this.instance.config.bootstrap) || void 0 === n || null === (o = n.featureFlagPayloads) || void 0 === o ? void 0 : o[e]) || null,
        $used_bootstrap_value: !this._flagsLoadedFromRemote
      });
      return a;
    }
    je.warn('getFeatureFlag for key "' + e + "\" failed. Feature flags didn't load in time.");
  }
  getFeatureFlagPayload(e) {
    return this.getFlagPayloads()[e];
  }
  isFeatureEnabled(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0) return !!this.getFeatureFlag(e, t);
    je.warn('isFeatureEnabled for key "' + e + "\" failed. Feature flags didn't load in time.");
  }
  addFeatureFlagsHandler(e) {
    this.featureFlagEventHandlers.push(e);
  }
  removeFeatureFlagsHandler(e) {
    this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter(t => t !== e);
  }
  receivedFeatureFlags(e, t) {
    if (this.instance.persistence) {
      this._hasLoadedFlags = !0;
      var i = this.getFlagVariants(),
        r = this.getFlagPayloads();
      !function (e, t) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
          r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
          s = e.featureFlags,
          n = e.featureFlagPayloads;
        if (s) if (x(s)) {
          var o = {};
          if (s) for (var a = 0; a < s.length; a++) o[s[a]] = !0;
          t && t.register({
            [We]: s,
            [Ce]: o
          });
        } else {
          var l = s,
            u = n;
          e.errorsWhileComputingFlags && (l = j(j({}, i), l), u = j(j({}, r), u)), t && t.register({
            [We]: Object.keys(Je(l)),
            [Ce]: l || {},
            [Ge]: u || {}
          });
        }
      }(e, this.instance.persistence, i, r), this._fireFeatureFlagsCallbacks(t);
    }
  }
  override(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (!this.instance.__loaded || !this.instance.persistence) return je.uninitializedWarning("posthog.feature_flags.override");
    if (this._override_warning = t, !1 === e) this.instance.persistence.unregister(Ve);else if (x(e)) {
      for (var i = {}, r = 0; r < e.length; r++) i[e[r]] = !0;
      this.instance.persistence.register({
        [Ve]: i
      });
    } else this.instance.persistence.register({
      [Ve]: e
    });
  }
  onFeatureFlags(e) {
    if (this.addFeatureFlagsHandler(e), this._hasLoadedFlags) {
      var {
        flags: t,
        flagVariants: i
      } = this._prepareFeatureFlagsForCallbacks();
      e(t, i);
    }
    return () => this.removeFeatureFlagsHandler(e);
  }
  updateEarlyAccessFeatureEnrollment(e, t) {
    var i,
      r = (this.instance.get_property(Pe) || []).find(t => t.flagKey === e),
      s = {
        ["$feature_enrollment/".concat(e)]: t
      },
      n = {
        $feature_flag: e,
        $feature_enrollment: t,
        $set: s
      };
    r && (n.$early_access_feature_name = r.name), this.instance.capture("$feature_enrollment_update", n), this.setPersonPropertiesForFlags(s, !1);
    var o = j(j({}, this.getFlagVariants()), {}, {
      [e]: t
    });
    null === (i = this.instance.persistence) || void 0 === i || i.register({
      [We]: Object.keys(Je(o)),
      [Ce]: o
    }), this._fireFeatureFlagsCallbacks();
  }
  getEarlyAccessFeatures(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
      i = this.instance.get_property(Pe);
    if (i && !t) return e(i);
    this.instance._send_request({
      url: this.instance.requestRouter.endpointFor("api", "/api/early_access_features/?token=".concat(this.instance.config.token)),
      method: "GET",
      callback: t => {
        var i;
        if (t.json) {
          var r = t.json.earlyAccessFeatures;
          return null === (i = this.instance.persistence) || void 0 === i || i.register({
            [Pe]: r
          }), e(r);
        }
      }
    });
  }
  _prepareFeatureFlagsForCallbacks() {
    var e = this.getFlags(),
      t = this.getFlagVariants();
    return {
      flags: e.filter(e => t[e]),
      flagVariants: Object.keys(t).filter(e => t[e]).reduce((e, i) => (e[i] = t[i], e), {})
    };
  }
  _fireFeatureFlagsCallbacks(e) {
    var {
      flags: t,
      flagVariants: i
    } = this._prepareFeatureFlagsForCallbacks();
    this.featureFlagEventHandlers.forEach(r => r(t, i, {
      errorsLoading: e
    }));
  }
  setPersonPropertiesForFlags(e) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
      i = this.instance.get_property(Re) || {};
    this.instance.register({
      [Re]: j(j({}, i), e)
    }), t && this.instance.reloadFeatureFlags();
  }
  resetPersonPropertiesForFlags() {
    this.instance.unregister(Re);
  }
  setGroupPropertiesForFlags(e) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
      i = this.instance.get_property(Fe) || {};
    0 !== Object.keys(i).length && Object.keys(i).forEach(t => {
      i[t] = j(j({}, i[t]), e[t]), delete e[t];
    }), this.instance.register({
      [Fe]: j(j({}, i), e)
    }), t && this.instance.reloadFeatureFlags();
  }
  resetGroupPropertiesForFlags(e) {
    if (e) {
      var t = this.instance.get_property(Fe) || {};
      this.instance.register({
        [Fe]: j(j({}, t), {}, {
          [e]: {}
        })
      });
    } else this.instance.unregister(Fe);
  }
}
Math.trunc || (Math.trunc = function (e) {
  return e < 0 ? Math.ceil(e) : Math.floor(e);
}), Number.isInteger || (Number.isInteger = function (e) {
  return M(e) && isFinite(e) && Math.floor(e) === e;
});
var Ke = "0123456789abcdef";
class Xe {
  constructor(e) {
    if (this.bytes = e, 16 !== e.length) throw new TypeError("not 128-bit length");
  }
  static fromFieldsV7(e, t, i, r) {
    if (!Number.isInteger(e) || !Number.isInteger(t) || !Number.isInteger(i) || !Number.isInteger(r) || e < 0 || t < 0 || i < 0 || r < 0 || e > 0xffffffffffff || t > 4095 || i > 1073741823 || r > 4294967295) throw new RangeError("invalid field value");
    var s = new Uint8Array(16);
    return s[0] = e / Math.pow(2, 40), s[1] = e / Math.pow(2, 32), s[2] = e / Math.pow(2, 24), s[3] = e / Math.pow(2, 16), s[4] = e / Math.pow(2, 8), s[5] = e, s[6] = 112 | t >>> 8, s[7] = t, s[8] = 128 | i >>> 24, s[9] = i >>> 16, s[10] = i >>> 8, s[11] = i, s[12] = r >>> 24, s[13] = r >>> 16, s[14] = r >>> 8, s[15] = r, new Xe(s);
  }
  toString() {
    for (var e = "", t = 0; t < this.bytes.length; t++) e = e + Ke.charAt(this.bytes[t] >>> 4) + Ke.charAt(15 & this.bytes[t]), 3 !== t && 5 !== t && 7 !== t && 9 !== t || (e += "-");
    if (36 !== e.length) throw new Error("Invalid UUIDv7 was generated");
    return e;
  }
  clone() {
    return new Xe(this.bytes.slice(0));
  }
  equals(e) {
    return 0 === this.compareTo(e);
  }
  compareTo(e) {
    for (var t = 0; t < 16; t++) {
      var i = this.bytes[t] - e.bytes[t];
      if (0 !== i) return Math.sign(i);
    }
    return 0;
  }
}
class Qe {
  constructor() {
    W(this, "timestamp", 0), W(this, "counter", 0), W(this, "random", new tt());
  }
  generate() {
    var e = this.generateOrAbort();
    if (R(e)) {
      this.timestamp = 0;
      var t = this.generateOrAbort();
      if (R(t)) throw new Error("Could not generate UUID after timestamp reset");
      return t;
    }
    return e;
  }
  generateOrAbort() {
    var e = Date.now();
    if (e > this.timestamp) this.timestamp = e, this.resetCounter();else {
      if (!(e + 1e4 > this.timestamp)) return;
      this.counter++, this.counter > 4398046511103 && (this.timestamp++, this.resetCounter());
    }
    return Xe.fromFieldsV7(this.timestamp, Math.trunc(this.counter / Math.pow(2, 30)), this.counter & Math.pow(2, 30) - 1, this.random.nextUint32());
  }
  resetCounter() {
    this.counter = 1024 * this.random.nextUint32() + (1023 & this.random.nextUint32());
  }
}
var Ze,
  et = e => {
    if ("undefined" != typeof UUIDV7_DENY_WEAK_RNG && UUIDV7_DENY_WEAK_RNG) throw new Error("no cryptographically strong RNG available");
    for (var t = 0; t < e.length; t++) e[t] = 65536 * Math.trunc(65536 * Math.random()) + Math.trunc(65536 * Math.random());
    return e;
  };
t && !R(t.crypto) && crypto.getRandomValues && (et = e => crypto.getRandomValues(e));
class tt {
  constructor() {
    W(this, "buffer", new Uint32Array(8)), W(this, "cursor", 1 / 0);
  }
  nextUint32() {
    return this.cursor >= this.buffer.length && (et(this.buffer), this.cursor = 0), this.buffer[this.cursor++];
  }
}
var it = () => rt().toString(),
  rt = () => (Ze || (Ze = new Qe())).generate(),
  st = "Thu, 01 Jan 1970 00:00:00 GMT",
  nt = "";
var ot = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;
function at(e, t) {
  if (t) {
    var i = function (e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a;
      if (nt) return nt;
      if (!t) return "";
      if (["localhost", "127.0.0.1"].includes(e)) return "";
      for (var i = e.split("."), r = Math.min(i.length, 8), s = "dmn_chk_" + it(), n = new RegExp("(^|;)\\s*" + s + "=1"); !nt && r--;) {
        var o = i.slice(r).join("."),
          l = s + "=1;domain=." + o;
        t.cookie = l, n.test(t.cookie) && (t.cookie = l + ";expires=" + st, nt = o);
      }
      return nt;
    }(e);
    if (!i) {
      var r = (e => {
        var t = e.match(ot);
        return t ? t[0] : "";
      })(e);
      r !== i && q.info("Warning: cookie subdomain discovery mismatch", r, i), i = r;
    }
    return i ? "; domain=." + i : "";
  }
  return "";
}
var lt = {
    is_supported: () => !!a,
    error: function (e) {
      q.error("cookieStore error: " + e);
    },
    get: function (e) {
      if (a) {
        try {
          for (var t = e + "=", i = a.cookie.split(";").filter(e => e.length), r = 0; r < i.length; r++) {
            for (var s = i[r]; " " == s.charAt(0);) s = s.substring(1, s.length);
            if (0 === s.indexOf(t)) return decodeURIComponent(s.substring(t.length, s.length));
          }
        } catch (e) {}
        return null;
      }
    },
    parse: function (e) {
      var t;
      try {
        t = JSON.parse(lt.get(e)) || {};
      } catch (e) {}
      return t;
    },
    set: function (e, t, i, r, s) {
      if (a) try {
        var n = "",
          o = "",
          l = at(a.location.hostname, r);
        if (i) {
          var u = new Date();
          u.setTime(u.getTime() + 24 * i * 60 * 60 * 1e3), n = "; expires=" + u.toUTCString();
        }
        s && (o = "; secure");
        var c = e + "=" + encodeURIComponent(JSON.stringify(t)) + n + "; SameSite=Lax; path=/" + l + o;
        return c.length > 3686.4 && q.warn("cookieStore warning: large cookie, len=" + c.length), a.cookie = c, c;
      } catch (e) {
        return;
      }
    },
    remove: function (e, t) {
      try {
        lt.set(e, "", -1, t);
      } catch (e) {
        return;
      }
    }
  },
  ut = null,
  ct = {
    is_supported: function () {
      if (!$(ut)) return ut;
      var e = !0;
      if (R(t)) e = !1;else try {
        var i = "__mplssupport__";
        ct.set(i, "xyz"), '"xyz"' !== ct.get(i) && (e = !1), ct.remove(i);
      } catch (t) {
        e = !1;
      }
      return e || q.error("localStorage unsupported; falling back to cookie store"), ut = e, e;
    },
    error: function (e) {
      q.error("localStorage error: " + e);
    },
    get: function (e) {
      try {
        return null == t ? void 0 : t.localStorage.getItem(e);
      } catch (e) {
        ct.error(e);
      }
      return null;
    },
    parse: function (e) {
      try {
        return JSON.parse(ct.get(e)) || {};
      } catch (e) {}
      return null;
    },
    set: function (e, i) {
      try {
        null == t || t.localStorage.setItem(e, JSON.stringify(i));
      } catch (e) {
        ct.error(e);
      }
    },
    remove: function (e) {
      try {
        null == t || t.localStorage.removeItem(e);
      } catch (e) {
        ct.error(e);
      }
    }
  },
  dt = ["distinct_id", Ee, ke, Be, qe],
  ht = j(j({}, ct), {}, {
    parse: function (e) {
      try {
        var t = {};
        try {
          t = lt.parse(e) || {};
        } catch (e) {}
        var i = K(t, JSON.parse(ct.get(e) || "{}"));
        return ct.set(e, i), i;
      } catch (e) {}
      return null;
    },
    set: function (e, t, i, r, s, n) {
      try {
        ct.set(e, t, void 0, void 0, n);
        var o = {};
        dt.forEach(e => {
          t[e] && (o[e] = t[e]);
        }), Object.keys(o).length && lt.set(e, o, i, r, s, n);
      } catch (e) {
        ct.error(e);
      }
    },
    remove: function (e, i) {
      try {
        null == t || t.localStorage.removeItem(e), lt.remove(e, i);
      } catch (e) {
        ct.error(e);
      }
    }
  }),
  _t = {},
  pt = {
    is_supported: function () {
      return !0;
    },
    error: function (e) {
      q.error("memoryStorage error: " + e);
    },
    get: function (e) {
      return _t[e] || null;
    },
    parse: function (e) {
      return _t[e] || null;
    },
    set: function (e, t) {
      _t[e] = t;
    },
    remove: function (e) {
      delete _t[e];
    }
  },
  vt = null,
  gt = {
    is_supported: function () {
      if (!$(vt)) return vt;
      if (vt = !0, R(t)) vt = !1;else try {
        var e = "__support__";
        gt.set(e, "xyz"), '"xyz"' !== gt.get(e) && (vt = !1), gt.remove(e);
      } catch (e) {
        vt = !1;
      }
      return vt;
    },
    error: function (e) {
      q.error("sessionStorage error: ", e);
    },
    get: function (e) {
      try {
        return null == t ? void 0 : t.sessionStorage.getItem(e);
      } catch (e) {
        gt.error(e);
      }
      return null;
    },
    parse: function (e) {
      try {
        return JSON.parse(gt.get(e)) || null;
      } catch (e) {}
      return null;
    },
    set: function (e, i) {
      try {
        null == t || t.sessionStorage.setItem(e, JSON.stringify(i));
      } catch (e) {
        gt.error(e);
      }
    },
    remove: function (e) {
      try {
        null == t || t.sessionStorage.removeItem(e);
      } catch (e) {
        gt.error(e);
      }
    }
  },
  ft = ["localhost", "127.0.0.1"],
  mt = e => {
    var t = null == a ? void 0 : a.createElement("a");
    return R(t) ? null : (t.href = e, t);
  },
  bt = function (e, t) {
    return !!function (e) {
      try {
        new RegExp(e);
      } catch (e) {
        return !1;
      }
      return !0;
    }(t) && new RegExp(t).test(e);
  },
  yt = function (e) {
    var t,
      i,
      r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "&",
      s = [];
    return Y(e, function (e, r) {
      R(e) || R(r) || "undefined" === r || (t = encodeURIComponent((e => e instanceof File)(e) ? e.name : e.toString()), i = encodeURIComponent(r), s[s.length] = i + "=" + t);
    }), s.join(r);
  },
  wt = function (e, t) {
    for (var i, r = ((e.split("#")[0] || "").split("?")[1] || "").split("&"), s = 0; s < r.length; s++) {
      var n = r[s].split("=");
      if (n[0] === t) {
        i = n;
        break;
      }
    }
    if (!x(i) || i.length < 2) return "";
    var o = i[1];
    try {
      o = decodeURIComponent(o);
    } catch (e) {
      q.error("Skipping decoding for malformed query param: " + o);
    }
    return o.replace(/\+/g, " ");
  },
  St = function (e, t, i) {
    if (!e || !t || !t.length) return e;
    for (var r = e.split("#"), s = r[0] || "", n = r[1], o = s.split("?"), a = o[1], l = o[0], u = (a || "").split("&"), c = [], d = 0; d < u.length; d++) {
      var h = u[d].split("=");
      x(h) && (t.includes(h[0]) ? c.push(h[0] + "=" + i) : c.push(u[d]));
    }
    var _ = l;
    return null != a && (_ += "?" + c.join("&")), null != n && (_ += "#" + n), _;
  },
  Et = function (e, t) {
    var i = e.match(new RegExp(t + "=([^&]*)"));
    return i ? i[1] : null;
  },
  kt = "Mobile",
  xt = "iOS",
  It = "Android",
  Ct = "Tablet",
  Pt = It + " " + Ct,
  Rt = "iPad",
  Ft = "Apple",
  Tt = Ft + " Watch",
  $t = "Safari",
  Ot = "BlackBerry",
  Mt = "Samsung",
  Lt = Mt + "Browser",
  At = Mt + " Internet",
  Dt = "Chrome",
  Nt = Dt + " OS",
  qt = Dt + " " + xt,
  Bt = "Internet Explorer",
  Ht = Bt + " " + kt,
  Ut = "Opera",
  zt = Ut + " Mini",
  jt = "Edge",
  Wt = "Microsoft " + jt,
  Vt = "Firefox",
  Gt = Vt + " " + xt,
  Jt = "Nintendo",
  Yt = "PlayStation",
  Kt = "Xbox",
  Xt = It + " " + kt,
  Qt = kt + " " + $t,
  Zt = "Windows",
  ei = Zt + " Phone",
  ti = "Nokia",
  ii = "Ouya",
  ri = "Generic",
  si = ri + " " + kt.toLowerCase(),
  ni = ri + " " + Ct.toLowerCase(),
  oi = "Konqueror",
  ai = "(\\d+(\\.\\d+)?)",
  li = new RegExp("Version/" + ai),
  ui = new RegExp(Kt, "i"),
  ci = new RegExp(Yt + " \\w+", "i"),
  di = new RegExp(Jt + " \\w+", "i"),
  hi = new RegExp(Ot + "|PlayBook|BB10", "i"),
  _i = {
    "NT3.51": "NT 3.11",
    "NT4.0": "NT 4.0",
    "5.0": "2000",
    5.1: "XP",
    5.2: "XP",
    "6.0": "Vista",
    6.1: "7",
    6.2: "8",
    6.3: "8.1",
    6.4: "10",
    "10.0": "10"
  };
var pi = (e, t) => t && m(t, Ft) || function (e) {
    return m(e, $t) && !m(e, Dt) && !m(e, It);
  }(e),
  vi = function (e, t) {
    return t = t || "", m(e, " OPR/") && m(e, "Mini") ? zt : m(e, " OPR/") ? Ut : hi.test(e) ? Ot : m(e, "IE" + kt) || m(e, "WPDesktop") ? Ht : m(e, Lt) ? At : m(e, jt) || m(e, "Edg/") ? Wt : m(e, "FBIOS") ? "Facebook " + kt : m(e, "UCWEB") || m(e, "UCBrowser") ? "UC Browser" : m(e, "CriOS") ? qt : m(e, "CrMo") || m(e, Dt) ? Dt : m(e, It) && m(e, $t) ? Xt : m(e, "FxiOS") ? Gt : m(e.toLowerCase(), oi.toLowerCase()) ? oi : pi(e, t) ? m(e, kt) ? Qt : $t : m(e, Vt) ? Vt : m(e, "MSIE") || m(e, "Trident/") ? Bt : m(e, "Gecko") ? Vt : "";
  },
  gi = {
    [Ht]: [new RegExp("rv:" + ai)],
    [Wt]: [new RegExp(jt + "?\\/" + ai)],
    [Dt]: [new RegExp("(" + Dt + "|CrMo)\\/" + ai)],
    [qt]: [new RegExp("CriOS\\/" + ai)],
    "UC Browser": [new RegExp("(UCBrowser|UCWEB)\\/" + ai)],
    [$t]: [li],
    [Qt]: [li],
    [Ut]: [new RegExp("(Opera|OPR)\\/" + ai)],
    [Vt]: [new RegExp(Vt + "\\/" + ai)],
    [Gt]: [new RegExp("FxiOS\\/" + ai)],
    [oi]: [new RegExp("Konqueror[:/]?" + ai, "i")],
    [Ot]: [new RegExp(Ot + " " + ai), li],
    [Xt]: [new RegExp("android\\s" + ai, "i")],
    [At]: [new RegExp(Lt + "\\/" + ai)],
    [Bt]: [new RegExp("(rv:|MSIE )" + ai)],
    Mozilla: [new RegExp("rv:" + ai)]
  },
  fi = [[new RegExp(Kt + "; " + Kt + " (.*?)[);]", "i"), e => [Kt, e && e[1] || ""]], [new RegExp(Jt, "i"), [Jt, ""]], [new RegExp(Yt, "i"), [Yt, ""]], [hi, [Ot, ""]], [new RegExp(Zt, "i"), (e, t) => {
    if (/Phone/.test(t) || /WPDesktop/.test(t)) return [ei, ""];
    if (new RegExp(kt).test(t) && !/IEMobile\b/.test(t)) return [Zt + " " + kt, ""];
    var i = /Windows NT ([0-9.]+)/i.exec(t);
    if (i && i[1]) {
      var r = i[1],
        s = _i[r] || "";
      return /arm/i.test(t) && (s = "RT"), [Zt, s];
    }
    return [Zt, ""];
  }], [/((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/, e => {
    if (e && e[3]) {
      var t = [e[3], e[4], e[5] || "0"];
      return [xt, t.join(".")];
    }
    return [xt, ""];
  }], [/(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i, e => {
    var t = "";
    return e && e.length >= 3 && (t = R(e[2]) ? e[3] : e[2]), ["watchOS", t];
  }], [new RegExp("(" + It + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + It + ")", "i"), e => {
    if (e && e[2]) {
      var t = [e[2], e[3], e[4] || "0"];
      return [It, t.join(".")];
    }
    return [It, ""];
  }], [/Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i, e => {
    var t = ["Mac OS X", ""];
    if (e && e[1]) {
      var i = [e[1], e[2], e[3] || "0"];
      t[1] = i.join(".");
    }
    return t;
  }], [/Mac/i, ["Mac OS X", ""]], [/CrOS/, [Nt, ""]], [/Linux|debian/i, ["Linux", ""]]],
  mi = function (e) {
    return di.test(e) ? Jt : ci.test(e) ? Yt : ui.test(e) ? Kt : new RegExp(ii, "i").test(e) ? ii : new RegExp("(" + ei + "|WPDesktop)", "i").test(e) ? ei : /iPad/.test(e) ? Rt : /iPod/.test(e) ? "iPod Touch" : /iPhone/.test(e) ? "iPhone" : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(e) ? Tt : hi.test(e) ? Ot : /(kobo)\s(ereader|touch)/i.test(e) ? "Kobo" : new RegExp(ti, "i").test(e) ? ti : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(e) || /(kf[a-z]+)( bui|\)).+silk\//i.test(e) ? "Kindle Fire" : /(Android|ZTE)/i.test(e) ? !new RegExp(kt).test(e) || /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(e) ? /pixel[\daxl ]{1,6}/i.test(e) && !/pixel c/i.test(e) || /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(e) || /lmy47v/i.test(e) && !/QTAQZ3/i.test(e) ? It : Pt : It : new RegExp("(pda|" + kt + ")", "i").test(e) ? si : new RegExp(Ct, "i").test(e) && !new RegExp(Ct + " pc", "i").test(e) ? ni : "";
  },
  bi = "https?://(.*)",
  yi = ["gclid", "gclsrc", "dclid", "gbraid", "wbraid", "fbclid", "msclkid", "twclid", "li_fat_id", "igshid", "ttclid", "rdt_cid", "irclid", "_kx"],
  wi = X(["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gad_source", "mc_cid"], yi),
  Si = "<masked>",
  Ei = {
    campaignParams: function () {
      var {
        customTrackedParams: e,
        maskPersonalDataProperties: t,
        customPersonalDataProperties: i
      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (!a) return {};
      var r = t ? X([], yi, i || []) : [];
      return this._campaignParamsFromUrl(St(a.URL, r, Si), e);
    },
    _campaignParamsFromUrl: function (e, t) {
      var i = wi.concat(t || []),
        r = {};
      return Y(i, function (t) {
        var i = wt(e, t);
        r[t] = i || null;
      }), r;
    },
    _searchEngine: function (e) {
      return e ? 0 === e.search(bi + "google.([^/?]*)") ? "google" : 0 === e.search(bi + "bing.com") ? "bing" : 0 === e.search(bi + "yahoo.com") ? "yahoo" : 0 === e.search(bi + "duckduckgo.com") ? "duckduckgo" : null : null;
    },
    _searchInfoFromReferrer: function (e) {
      var t = Ei._searchEngine(e),
        i = "yahoo" != t ? "q" : "p",
        r = {};
      if (!$(t)) {
        r.$search_engine = t;
        var s = a ? wt(a.referrer, i) : "";
        s.length && (r.ph_keyword = s);
      }
      return r;
    },
    searchInfo: function () {
      var e = null == a ? void 0 : a.referrer;
      return e ? this._searchInfoFromReferrer(e) : {};
    },
    browser: vi,
    browserVersion: function (e, t) {
      var i = vi(e, t),
        r = gi[i];
      if (R(r)) return null;
      for (var s = 0; s < r.length; s++) {
        var n = r[s],
          o = e.match(n);
        if (o) return parseFloat(o[o.length - 2]);
      }
      return null;
    },
    browserLanguage: function () {
      return navigator.language || navigator.userLanguage;
    },
    browserLanguagePrefix: function () {
      var e = this.browserLanguage();
      return "string" == typeof e ? e.split("-")[0] : void 0;
    },
    os: function (e) {
      for (var t = 0; t < fi.length; t++) {
        var [i, r] = fi[t],
          s = i.exec(e),
          n = s && (I(r) ? r(s, e) : r);
        if (n) return n;
      }
      return ["", ""];
    },
    device: mi,
    deviceType: function (e) {
      var t = mi(e);
      return t === Rt || t === Pt || "Kobo" === t || "Kindle Fire" === t || t === ni ? Ct : t === Jt || t === Kt || t === Yt || t === ii ? "Console" : t === Tt ? "Wearable" : t ? kt : "Desktop";
    },
    referrer: function () {
      return (null == a ? void 0 : a.referrer) || "$direct";
    },
    referringDomain: function () {
      var e;
      return null != a && a.referrer && (null === (e = mt(a.referrer)) || void 0 === e ? void 0 : e.host) || "$direct";
    },
    referrerInfo: function () {
      return {
        $referrer: this.referrer(),
        $referring_domain: this.referringDomain()
      };
    },
    initialPersonInfo: function () {
      return {
        r: this.referrer().substring(0, 1e3),
        u: null == l ? void 0 : l.href.substring(0, 1e3)
      };
    },
    initialPersonPropsFromInfo: function (e) {
      var t,
        {
          r: i,
          u: r
        } = e,
        s = {
          $initial_referrer: i,
          $initial_referring_domain: null == i ? void 0 : "$direct" == i ? "$direct" : null === (t = mt(i)) || void 0 === t ? void 0 : t.host
        };
      if (r) {
        s.$initial_current_url = r;
        var n = mt(r);
        s.$initial_host = null == n ? void 0 : n.host, s.$initial_pathname = null == n ? void 0 : n.pathname, Y(this._campaignParamsFromUrl(r), function (e, t) {
          s["$initial_" + y(t)] = e;
        });
      }
      i && Y(this._searchInfoFromReferrer(i), function (e, t) {
        s["$initial_" + y(t)] = e;
      });
      return s;
    },
    timezone: function () {
      try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      } catch (e) {
        return;
      }
    },
    timezoneOffset: function () {
      try {
        return new Date().getTimezoneOffset();
      } catch (e) {
        return;
      }
    },
    properties: function () {
      var {
        maskPersonalDataProperties: e,
        customPersonalDataProperties: i
      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (!h) return {};
      var r = e ? X([], yi, i || []) : [],
        [s, n] = Ei.os(h);
      return K(te({
        $os: s,
        $os_version: n,
        $browser: Ei.browser(h, navigator.vendor),
        $device: Ei.device(h),
        $device_type: Ei.deviceType(h),
        $timezone: Ei.timezone(),
        $timezone_offset: Ei.timezoneOffset()
      }), {
        $current_url: St(null == l ? void 0 : l.href, r, Si),
        $host: null == l ? void 0 : l.host,
        $pathname: null == l ? void 0 : l.pathname,
        $raw_user_agent: h.length > 1e3 ? h.substring(0, 997) + "..." : h,
        $browser_version: Ei.browserVersion(h, navigator.vendor),
        $browser_language: Ei.browserLanguage(),
        $browser_language_prefix: Ei.browserLanguagePrefix(),
        $screen_height: null == t ? void 0 : t.screen.height,
        $screen_width: null == t ? void 0 : t.screen.width,
        $viewport_height: null == t ? void 0 : t.innerHeight,
        $viewport_width: null == t ? void 0 : t.innerWidth,
        $lib: "web",
        $lib_version: p.LIB_VERSION,
        $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10),
        $time: Date.now() / 1e3
      });
    },
    people_properties: function () {
      if (!h) return {};
      var [e, t] = Ei.os(h);
      return K(te({
        $os: e,
        $os_version: t,
        $browser: Ei.browser(h, navigator.vendor)
      }), {
        $browser_version: Ei.browserVersion(h, navigator.vendor)
      });
    }
  },
  ki = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"];
class xi {
  constructor(e) {
    this.config = e, this.props = {}, this.campaign_params_saved = !1, this.name = (e => {
      var t = "";
      return e.token && (t = e.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")), e.persistence_name ? "ph_" + e.persistence_name : "ph_" + t + "_posthog";
    })(e), this.storage = this.buildStorage(e), this.load(), e.debug && q.info("Persistence loaded", e.persistence, j({}, this.props)), this.update_config(e, e), this.save();
  }
  buildStorage(e) {
    -1 === ki.indexOf(e.persistence.toLowerCase()) && (q.critical("Unknown persistence type " + e.persistence + "; falling back to localStorage+cookie"), e.persistence = "localStorage+cookie");
    var t = e.persistence.toLowerCase();
    return "localstorage" === t && ct.is_supported() ? ct : "localstorage+cookie" === t && ht.is_supported() ? ht : "sessionstorage" === t && gt.is_supported() ? gt : "memory" === t ? pt : "cookie" === t ? lt : ht.is_supported() ? ht : lt;
  }
  properties() {
    var e = {};
    return Y(this.props, function (t, i) {
      if (i === Ce && C(t)) for (var r = Object.keys(t), s = 0; s < r.length; s++) e["$feature/".concat(r[s])] = t[r[s]];else a = i, l = !1, ($(o = ze) ? l : n && o.indexOf === n ? -1 != o.indexOf(a) : (Y(o, function (e) {
        if (l || (l = e === a)) return G;
      }), l)) || (e[i] = t);
      var o, a, l;
    }), e;
  }
  load() {
    if (!this.disabled) {
      var e = this.storage.parse(this.name);
      e && (this.props = K({}, e));
    }
  }
  save() {
    this.disabled || this.storage.set(this.name, this.props, this.expire_days, this.cross_subdomain, this.secure, this.config.debug);
  }
  remove() {
    this.storage.remove(this.name, !1), this.storage.remove(this.name, !0);
  }
  clear() {
    this.remove(), this.props = {};
  }
  register_once(e, t, i) {
    if (C(e)) {
      R(t) && (t = "None"), this.expire_days = R(i) ? this.default_expiry : i;
      var r = !1;
      if (Y(e, (e, i) => {
        this.props.hasOwnProperty(i) && this.props[i] !== t || (this.props[i] = e, r = !0);
      }), r) return this.save(), !0;
    }
    return !1;
  }
  register(e, t) {
    if (C(e)) {
      this.expire_days = R(t) ? this.default_expiry : t;
      var i = !1;
      if (Y(e, (t, r) => {
        e.hasOwnProperty(r) && this.props[r] !== t && (this.props[r] = t, i = !0);
      }), i) return this.save(), !0;
    }
    return !1;
  }
  unregister(e) {
    e in this.props && (delete this.props[e], this.save());
  }
  update_campaign_params() {
    if (!this.campaign_params_saved) {
      var e = Ei.campaignParams({
        customTrackedParams: this.config.custom_campaign_params,
        maskPersonalDataProperties: this.config.mask_personal_data_properties,
        customPersonalDataProperties: this.config.custom_personal_data_properties
      });
      P(te(e)) || this.register(e), this.campaign_params_saved = !0;
    }
  }
  update_search_keyword() {
    this.register(Ei.searchInfo());
  }
  update_referrer_info() {
    this.register_once(Ei.referrerInfo(), void 0);
  }
  set_initial_person_info() {
    this.props[De] || this.props[Ne] || this.register_once({
      [qe]: Ei.initialPersonInfo()
    }, void 0);
  }
  get_referrer_info() {
    return te({
      $referrer: this.props.$referrer,
      $referring_domain: this.props.$referring_domain
    });
  }
  get_initial_props() {
    var e = {};
    Y([Ne, De], t => {
      var i = this.props[t];
      i && Y(i, function (t, i) {
        e["$initial_" + y(i)] = t;
      });
    });
    var t = this.props[qe];
    if (t) {
      var i = Ei.initialPersonPropsFromInfo(t);
      K(e, i);
    }
    return e;
  }
  safe_merge(e) {
    return Y(this.props, function (t, i) {
      i in e || (e[i] = t);
    }), e;
  }
  update_config(e, t) {
    if (this.default_expiry = this.expire_days = e.cookie_expiration, this.set_disabled(e.disable_persistence), this.set_cross_subdomain(e.cross_subdomain_cookie), this.set_secure(e.secure_cookie), e.persistence !== t.persistence) {
      var i = this.buildStorage(e),
        r = this.props;
      this.clear(), this.storage = i, this.props = r, this.save();
    }
  }
  set_disabled(e) {
    this.disabled = e, this.disabled ? this.remove() : this.save();
  }
  set_cross_subdomain(e) {
    e !== this.cross_subdomain && (this.cross_subdomain = e, this.remove(), this.save());
  }
  get_cross_subdomain() {
    return !!this.cross_subdomain;
  }
  set_secure(e) {
    e !== this.secure && (this.secure = e, this.remove(), this.save());
  }
  set_event_timer(e, t) {
    var i = this.props[ue] || {};
    i[e] = t, this.props[ue] = i, this.save();
  }
  remove_event_timer(e) {
    var t = (this.props[ue] || {})[e];
    return R(t) || (delete this.props[ue][e], this.save()), t;
  }
  get_property(e) {
    return this.props[e];
  }
  set_property(e, t) {
    this.props[e] = t, this.save();
  }
}
function Ii(e) {
  var t, i;
  return (null === (t = JSON.stringify(e, (i = [], function (e, t) {
    if (C(t)) {
      for (; i.length > 0 && i[i.length - 1] !== this;) i.pop();
      return i.includes(t) ? "[Circular]" : (i.push(t), t);
    }
    return t;
  }))) || void 0 === t ? void 0 : t.length) || 0;
}
function Ci(e) {
  var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 6606028.8;
  if (e.size >= t && e.data.length > 1) {
    var i = Math.floor(e.data.length / 2),
      r = e.data.slice(0, i),
      s = e.data.slice(i);
    return [Ci({
      size: Ii(r),
      data: r,
      sessionId: e.sessionId,
      windowId: e.windowId
    }), Ci({
      size: Ii(s),
      data: s,
      sessionId: e.sessionId,
      windowId: e.windowId
    })].flatMap(e => e);
  }
  return [e];
}
var Pi = (e => (e[e.DomContentLoaded = 0] = "DomContentLoaded", e[e.Load = 1] = "Load", e[e.FullSnapshot = 2] = "FullSnapshot", e[e.IncrementalSnapshot = 3] = "IncrementalSnapshot", e[e.Meta = 4] = "Meta", e[e.Custom = 5] = "Custom", e[e.Plugin = 6] = "Plugin", e))(Pi || {}),
  Ri = (e => (e[e.Mutation = 0] = "Mutation", e[e.MouseMove = 1] = "MouseMove", e[e.MouseInteraction = 2] = "MouseInteraction", e[e.Scroll = 3] = "Scroll", e[e.ViewportResize = 4] = "ViewportResize", e[e.Input = 5] = "Input", e[e.TouchMove = 6] = "TouchMove", e[e.MediaInteraction = 7] = "MediaInteraction", e[e.StyleSheetRule = 8] = "StyleSheetRule", e[e.CanvasMutation = 9] = "CanvasMutation", e[e.Font = 10] = "Font", e[e.Log = 11] = "Log", e[e.Drag = 12] = "Drag", e[e.StyleDeclaration = 13] = "StyleDeclaration", e[e.Selection = 14] = "Selection", e[e.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", e[e.CustomElement = 16] = "CustomElement", e))(Ri || {});
function Fi(e) {
  var t;
  return e instanceof Element && (e.id === He || !(null === (t = e.closest) || void 0 === t || !t.call(e, ".toolbar-global-fade-container")));
}
function Ti(e) {
  return !!e && 1 === e.nodeType;
}
function $i(e, t) {
  return !!e && !!e.tagName && e.tagName.toLowerCase() === t.toLowerCase();
}
function Oi(e) {
  return !!e && 3 === e.nodeType;
}
function Mi(e) {
  return !!e && 11 === e.nodeType;
}
function Li(e) {
  return e ? b(e).split(/\s+/) : [];
}
function Ai(e) {
  var i = null == t ? void 0 : t.location.href;
  return !!(i && e && e.some(e => i.match(e)));
}
function Di(e) {
  var t = "";
  switch (typeof e.className) {
    case "string":
      t = e.className;
      break;
    case "object":
      t = (e.className && "baseVal" in e.className ? e.className.baseVal : null) || e.getAttribute("class") || "";
      break;
    default:
      t = "";
  }
  return Li(t);
}
function Ni(e) {
  return O(e) ? null : b(e).split(/(\s+)/).filter(e => Qi(e)).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255);
}
function qi(e) {
  var t = "";
  return ji(e) && !Wi(e) && e.childNodes && e.childNodes.length && Y(e.childNodes, function (e) {
    var i;
    Oi(e) && e.textContent && (t += null !== (i = Ni(e.textContent)) && void 0 !== i ? i : "");
  }), b(t);
}
function Bi(e) {
  return R(e.target) ? e.srcElement || null : null !== (t = e.target) && void 0 !== t && t.shadowRoot ? e.composedPath()[0] || null : e.target || null;
  var t;
}
var Hi = ["a", "button", "form", "input", "select", "textarea", "label"];
function Ui(e) {
  var t = e.parentNode;
  return !(!t || !Ti(t)) && t;
}
function zi(e, i) {
  var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
    s = arguments.length > 3 ? arguments[3] : void 0,
    n = arguments.length > 4 ? arguments[4] : void 0;
  if (!t || !e || $i(e, "html") || !Ti(e)) return !1;
  if (null != r && r.url_allowlist && !Ai(r.url_allowlist)) return !1;
  if (null != r && r.url_ignorelist && Ai(r.url_ignorelist)) return !1;
  if (null != r && r.dom_event_allowlist) {
    var o = r.dom_event_allowlist;
    if (o && !o.some(e => i.type === e)) return !1;
  }
  for (var a = !1, l = [e], u = !0, c = e; c.parentNode && !$i(c, "body");) if (Mi(c.parentNode)) l.push(c.parentNode.host), c = c.parentNode.host;else {
    if (!(u = Ui(c))) break;
    if (s || Hi.indexOf(u.tagName.toLowerCase()) > -1) a = !0;else {
      var d = t.getComputedStyle(u);
      d && "pointer" === d.getPropertyValue("cursor") && (a = !0);
    }
    l.push(u), c = u;
  }
  if (!function (e, t) {
    var i = null == t ? void 0 : t.element_allowlist;
    if (R(i)) return !0;
    var r = function (e) {
      if (i.some(t => e.tagName.toLowerCase() === t)) return {
        v: !0
      };
    };
    for (var s of e) {
      var n = r(s);
      if ("object" == typeof n) return n.v;
    }
    return !1;
  }(l, r)) return !1;
  if (!function (e, t) {
    var i = null == t ? void 0 : t.css_selector_allowlist;
    if (R(i)) return !0;
    var r = function (e) {
      if (i.some(t => e.matches(t))) return {
        v: !0
      };
    };
    for (var s of e) {
      var n = r(s);
      if ("object" == typeof n) return n.v;
    }
    return !1;
  }(l, r)) return !1;
  var h = t.getComputedStyle(e);
  if (h && "pointer" === h.getPropertyValue("cursor") && "click" === i.type) return !0;
  var _ = e.tagName.toLowerCase();
  switch (_) {
    case "html":
      return !1;
    case "form":
      return (n || ["submit"]).indexOf(i.type) >= 0;
    case "input":
    case "select":
    case "textarea":
      return (n || ["change", "click"]).indexOf(i.type) >= 0;
    default:
      return a ? (n || ["click"]).indexOf(i.type) >= 0 : (n || ["click"]).indexOf(i.type) >= 0 && (Hi.indexOf(_) > -1 || "true" === e.getAttribute("contenteditable"));
  }
}
function ji(e) {
  for (var t = e; t.parentNode && !$i(t, "body"); t = t.parentNode) {
    var i = Di(t);
    if (m(i, "ph-sensitive") || m(i, "ph-no-capture")) return !1;
  }
  if (m(Di(e), "ph-include")) return !0;
  var r = e.type || "";
  if (F(r)) switch (r.toLowerCase()) {
    case "hidden":
    case "password":
      return !1;
  }
  var s = e.name || e.id || "";
  if (F(s)) {
    if (/^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(s.replace(/[^a-zA-Z0-9]/g, ""))) return !1;
  }
  return !0;
}
function Wi(e) {
  return !!($i(e, "input") && !["button", "checkbox", "submit", "reset"].includes(e.type) || $i(e, "select") || $i(e, "textarea") || "true" === e.getAttribute("contenteditable"));
}
var Vi = "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})",
  Gi = new RegExp("^(?:".concat(Vi, ")$")),
  Ji = new RegExp(Vi),
  Yi = "\\d{3}-?\\d{2}-?\\d{4}",
  Ki = new RegExp("^(".concat(Yi, ")$")),
  Xi = new RegExp("(".concat(Yi, ")"));
function Qi(e) {
  var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  if (O(e)) return !1;
  if (F(e)) {
    if (e = b(e), (t ? Gi : Ji).test((e || "").replace(/[- ]/g, ""))) return !1;
    if ((t ? Ki : Xi).test(e)) return !1;
  }
  return !0;
}
function Zi(e) {
  var t = qi(e);
  return Qi(t = "".concat(t, " ").concat(er(e)).trim()) ? t : "";
}
function er(e) {
  var t = "";
  return e && e.childNodes && e.childNodes.length && Y(e.childNodes, function (e) {
    var i;
    if (e && "span" === (null === (i = e.tagName) || void 0 === i ? void 0 : i.toLowerCase())) try {
      var r = qi(e);
      t = "".concat(t, " ").concat(r).trim(), e.childNodes && e.childNodes.length && (t = "".concat(t, " ").concat(er(e)).trim());
    } catch (e) {
      q.error("[AutoCapture]", e);
    }
  }), t;
}
function tr(e) {
  return function (e) {
    var t = e.map(e => {
      var t,
        i,
        r = "";
      if (e.tag_name && (r += e.tag_name), e.attr_class) for (var s of (e.attr_class.sort(), e.attr_class)) r += ".".concat(s.replace(/"/g, ""));
      var n = j(j(j(j({}, e.text ? {
          text: e.text
        } : {}), {}, {
          "nth-child": null !== (t = e.nth_child) && void 0 !== t ? t : 0,
          "nth-of-type": null !== (i = e.nth_of_type) && void 0 !== i ? i : 0
        }, e.href ? {
          href: e.href
        } : {}), e.attr_id ? {
          attr_id: e.attr_id
        } : {}), e.attributes),
        o = {};
      return Q(n).sort((e, t) => {
        var [i] = e,
          [r] = t;
        return i.localeCompare(r);
      }).forEach(e => {
        var [t, i] = e;
        return o[ir(t.toString())] = ir(i.toString());
      }), r += ":", r += Q(n).map(e => {
        var [t, i] = e;
        return "".concat(t, '="').concat(i, '"');
      }).join("");
    });
    return t.join(";");
  }(function (e) {
    return e.map(e => {
      var t,
        i,
        r = {
          text: null === (t = e.$el_text) || void 0 === t ? void 0 : t.slice(0, 400),
          tag_name: e.tag_name,
          href: null === (i = e.attr__href) || void 0 === i ? void 0 : i.slice(0, 2048),
          attr_class: rr(e),
          attr_id: e.attr__id,
          nth_child: e.nth_child,
          nth_of_type: e.nth_of_type,
          attributes: {}
        };
      return Q(e).filter(e => {
        var [t] = e;
        return 0 === t.indexOf("attr__");
      }).forEach(e => {
        var [t, i] = e;
        return r.attributes[t] = i;
      }), r;
    });
  }(e));
}
function ir(e) {
  return e.replace(/"|\\"/g, '\\"');
}
function rr(e) {
  var t = e.attr__class;
  return t ? x(t) ? t : Li(t) : void 0;
}
var sr = "[SessionRecording]",
  nr = "redacted",
  or = {
    initiatorTypes: ["audio", "beacon", "body", "css", "early-hint", "embed", "fetch", "frame", "iframe", "icon", "image", "img", "input", "link", "navigation", "object", "ping", "script", "track", "video", "xmlhttprequest"],
    maskRequestFn: e => e,
    recordHeaders: !1,
    recordBody: !1,
    recordInitialRequests: !1,
    recordPerformance: !1,
    performanceEntryTypeToObserve: ["first-input", "navigation", "paint", "resource"],
    payloadSizeLimitBytes: 1e6,
    payloadHostDenyList: [".lr-ingest.io", ".ingest.sentry.io", ".clarity.ms", "analytics.google.com"]
  },
  ar = ["authorization", "x-forwarded-for", "authorization", "cookie", "set-cookie", "x-api-key", "x-real-ip", "remote-addr", "forwarded", "proxy-authorization", "x-csrf-token", "x-csrftoken", "x-xsrf-token"],
  lr = ["password", "secret", "passwd", "api_key", "apikey", "auth", "credentials", "mysql_pwd", "privatekey", "private_key", "token"],
  ur = ["/s/", "/e/", "/i/"];
function cr(e, t, i, r) {
  if (O(e)) return e;
  var s = (null == t ? void 0 : t["content-length"]) || function (e) {
    return new Blob([e]).size;
  }(e);
  return F(s) && (s = parseInt(s)), s > i ? sr + " ".concat(r, " body too large to record (").concat(s, " bytes)") : e;
}
function dr(e, t) {
  if (O(e)) return e;
  var i = e;
  return Qi(i, !1) || (i = sr + " " + t + " body " + nr), Y(lr, e => {
    var r, s;
    null !== (r = i) && void 0 !== r && r.length && -1 !== (null === (s = i) || void 0 === s ? void 0 : s.indexOf(e)) && (i = sr + " " + t + " body " + nr + " as might contain: " + e);
  }), i;
}
var hr = (e, t) => {
  var i,
    r,
    s,
    n = {
      payloadSizeLimitBytes: or.payloadSizeLimitBytes,
      performanceEntryTypeToObserve: [...or.performanceEntryTypeToObserve],
      payloadHostDenyList: [...(t.payloadHostDenyList || []), ...or.payloadHostDenyList]
    },
    o = !1 !== e.session_recording.recordHeaders && t.recordHeaders,
    a = !1 !== e.session_recording.recordBody && t.recordBody,
    l = !1 !== e.capture_performance && t.recordPerformance,
    u = (i = n, s = Math.min(1e6, null !== (r = i.payloadSizeLimitBytes) && void 0 !== r ? r : 1e6), e => (null != e && e.requestBody && (e.requestBody = cr(e.requestBody, e.requestHeaders, s, "Request")), null != e && e.responseBody && (e.responseBody = cr(e.responseBody, e.responseHeaders, s, "Response")), e)),
    c = t => {
      return u(((e, t) => {
        var i,
          r = mt(e.name),
          s = 0 === t.indexOf("http") ? null === (i = mt(t)) || void 0 === i ? void 0 : i.pathname : t;
        "/" === s && (s = "");
        var n = null == r ? void 0 : r.pathname.replace(s || "", "");
        if (!(r && n && ur.some(e => 0 === n.indexOf(e)))) return e;
      })((r = (i = t).requestHeaders, O(r) || Y(Object.keys(null != r ? r : {}), e => {
        ar.includes(e.toLowerCase()) && (r[e] = nr);
      }), i), e.api_host));
      var i, r;
    },
    d = I(e.session_recording.maskNetworkRequestFn);
  return d && I(e.session_recording.maskCapturedNetworkRequestFn) && q.warn("Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."), d && (e.session_recording.maskCapturedNetworkRequestFn = t => {
    var i = e.session_recording.maskNetworkRequestFn({
      url: t.name
    });
    return j(j({}, t), {}, {
      name: null == i ? void 0 : i.url
    });
  }), n.maskRequestFn = I(e.session_recording.maskCapturedNetworkRequestFn) ? t => {
    var i,
      r,
      s,
      n = c(t);
    return n && null !== (i = null === (r = (s = e.session_recording).maskCapturedNetworkRequestFn) || void 0 === r ? void 0 : r.call(s, n)) && void 0 !== i ? i : void 0;
  } : e => function (e) {
    if (!R(e)) return e.requestBody = dr(e.requestBody, "Request"), e.responseBody = dr(e.responseBody, "Response"), e;
  }(c(e)), j(j(j({}, or), n), {}, {
    recordHeaders: o,
    recordBody: a,
    recordPerformance: l,
    recordInitialRequests: l
  });
};
function _r(e, t, i, r, s) {
  return t > i && (q.warn("min cannot be greater than max."), t = i), M(e) ? e > i ? (r && q.warn(r + " cannot be  greater than max: " + i + ". Using max value instead."), i) : e < t ? (r && q.warn(r + " cannot be less than min: " + t + ". Using min value instead."), t) : e : (r && q.warn(r + " must be a number. using max or fallback. max: " + i + ", fallback: " + s), _r(s || i, t, i, r));
}
class pr {
  constructor(e) {
    var t,
      i,
      r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    W(this, "bucketSize", 100), W(this, "refillRate", 10), W(this, "mutationBuckets", {}), W(this, "loggedTracker", {}), W(this, "refillBuckets", () => {
      Object.keys(this.mutationBuckets).forEach(e => {
        this.mutationBuckets[e] = this.mutationBuckets[e] + this.refillRate, this.mutationBuckets[e] >= this.bucketSize && delete this.mutationBuckets[e];
      });
    }), W(this, "getNodeOrRelevantParent", e => {
      var t = this.rrweb.mirror.getNode(e);
      if ("svg" !== (null == t ? void 0 : t.nodeName) && t instanceof Element) {
        var i = t.closest("svg");
        if (i) return [this.rrweb.mirror.getId(i), i];
      }
      return [e, t];
    }), W(this, "numberOfChanges", e => {
      var t, i, r, s, n, o, a, l;
      return (null !== (t = null === (i = e.removes) || void 0 === i ? void 0 : i.length) && void 0 !== t ? t : 0) + (null !== (r = null === (s = e.attributes) || void 0 === s ? void 0 : s.length) && void 0 !== r ? r : 0) + (null !== (n = null === (o = e.texts) || void 0 === o ? void 0 : o.length) && void 0 !== n ? n : 0) + (null !== (a = null === (l = e.adds) || void 0 === l ? void 0 : l.length) && void 0 !== a ? a : 0);
    }), W(this, "throttleMutations", e => {
      if (3 !== e.type || 0 !== e.data.source) return e;
      var t = e.data,
        i = this.numberOfChanges(t);
      t.attributes && (t.attributes = t.attributes.filter(e => {
        var t,
          i,
          r,
          [s, n] = this.getNodeOrRelevantParent(e.id);
        if (0 === this.mutationBuckets[s]) return !1;
        (this.mutationBuckets[s] = null !== (t = this.mutationBuckets[s]) && void 0 !== t ? t : this.bucketSize, this.mutationBuckets[s] = Math.max(this.mutationBuckets[s] - 1, 0), 0 === this.mutationBuckets[s]) && (this.loggedTracker[s] || (this.loggedTracker[s] = !0, null === (i = (r = this.options).onBlockedNode) || void 0 === i || i.call(r, s, n)));
        return e;
      }));
      var r = this.numberOfChanges(t);
      return 0 !== r || i === r ? e : void 0;
    }), this.rrweb = e, this.options = r, this.refillRate = _r(null !== (t = this.options.refillRate) && void 0 !== t ? t : this.refillRate, 0, 100, "mutation throttling refill rate"), this.bucketSize = _r(null !== (i = this.options.bucketSize) && void 0 !== i ? i : this.bucketSize, 0, 100, "mutation throttling bucket size"), setInterval(() => {
      this.refillBuckets();
    }, 1e3);
  }
}
var vr = Uint8Array,
  gr = Uint16Array,
  fr = Uint32Array,
  mr = new vr([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
  br = new vr([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
  yr = new vr([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
  wr = function (e, t) {
    for (var i = new gr(31), r = 0; r < 31; ++r) i[r] = t += 1 << e[r - 1];
    var s = new fr(i[30]);
    for (r = 1; r < 30; ++r) for (var n = i[r]; n < i[r + 1]; ++n) s[n] = n - i[r] << 5 | r;
    return [i, s];
  },
  Sr = wr(mr, 2),
  Er = Sr[0],
  kr = Sr[1];
Er[28] = 258, kr[258] = 28;
for (var xr = wr(br, 0)[1], Ir = new gr(32768), Cr = 0; Cr < 32768; ++Cr) {
  var Pr = (43690 & Cr) >>> 1 | (21845 & Cr) << 1;
  Pr = (61680 & (Pr = (52428 & Pr) >>> 2 | (13107 & Pr) << 2)) >>> 4 | (3855 & Pr) << 4, Ir[Cr] = ((65280 & Pr) >>> 8 | (255 & Pr) << 8) >>> 1;
}
var Rr = function (e, t, i) {
    for (var r = e.length, s = 0, n = new gr(t); s < r; ++s) ++n[e[s] - 1];
    var o,
      a = new gr(t);
    for (s = 0; s < t; ++s) a[s] = a[s - 1] + n[s - 1] << 1;
    if (i) {
      o = new gr(1 << t);
      var l = 15 - t;
      for (s = 0; s < r; ++s) if (e[s]) for (var u = s << 4 | e[s], c = t - e[s], d = a[e[s] - 1]++ << c, h = d | (1 << c) - 1; d <= h; ++d) o[Ir[d] >>> l] = u;
    } else for (o = new gr(r), s = 0; s < r; ++s) o[s] = Ir[a[e[s] - 1]++] >>> 15 - e[s];
    return o;
  },
  Fr = new vr(288);
for (Cr = 0; Cr < 144; ++Cr) Fr[Cr] = 8;
for (Cr = 144; Cr < 256; ++Cr) Fr[Cr] = 9;
for (Cr = 256; Cr < 280; ++Cr) Fr[Cr] = 7;
for (Cr = 280; Cr < 288; ++Cr) Fr[Cr] = 8;
var Tr = new vr(32);
for (Cr = 0; Cr < 32; ++Cr) Tr[Cr] = 5;
var $r = Rr(Fr, 9, 0),
  Or = Rr(Tr, 5, 0),
  Mr = function (e) {
    return (e / 8 >> 0) + (7 & e && 1);
  },
  Lr = function (e, t, i) {
    (null == i || i > e.length) && (i = e.length);
    var r = new (e instanceof gr ? gr : e instanceof fr ? fr : vr)(i - t);
    return r.set(e.subarray(t, i)), r;
  },
  Ar = function (e, t, i) {
    i <<= 7 & t;
    var r = t / 8 >> 0;
    e[r] |= i, e[r + 1] |= i >>> 8;
  },
  Dr = function (e, t, i) {
    i <<= 7 & t;
    var r = t / 8 >> 0;
    e[r] |= i, e[r + 1] |= i >>> 8, e[r + 2] |= i >>> 16;
  },
  Nr = function (e, t) {
    for (var i = [], r = 0; r < e.length; ++r) e[r] && i.push({
      s: r,
      f: e[r]
    });
    var s = i.length,
      n = i.slice();
    if (!s) return [new vr(0), 0];
    if (1 == s) {
      var o = new vr(i[0].s + 1);
      return o[i[0].s] = 1, [o, 1];
    }
    i.sort(function (e, t) {
      return e.f - t.f;
    }), i.push({
      s: -1,
      f: 25001
    });
    var a = i[0],
      l = i[1],
      u = 0,
      c = 1,
      d = 2;
    for (i[0] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    }; c != s - 1;) a = i[i[u].f < i[d].f ? u++ : d++], l = i[u != c && i[u].f < i[d].f ? u++ : d++], i[c++] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    };
    var h = n[0].s;
    for (r = 1; r < s; ++r) n[r].s > h && (h = n[r].s);
    var _ = new gr(h + 1),
      p = qr(i[c - 1], _, 0);
    if (p > t) {
      r = 0;
      var v = 0,
        g = p - t,
        f = 1 << g;
      for (n.sort(function (e, t) {
        return _[t.s] - _[e.s] || e.f - t.f;
      }); r < s; ++r) {
        var m = n[r].s;
        if (!(_[m] > t)) break;
        v += f - (1 << p - _[m]), _[m] = t;
      }
      for (v >>>= g; v > 0;) {
        var b = n[r].s;
        _[b] < t ? v -= 1 << t - _[b]++ - 1 : ++r;
      }
      for (; r >= 0 && v; --r) {
        var y = n[r].s;
        _[y] == t && (--_[y], ++v);
      }
      p = t;
    }
    return [new vr(_), p];
  },
  qr = function (e, t, i) {
    return -1 == e.s ? Math.max(qr(e.l, t, i + 1), qr(e.r, t, i + 1)) : t[e.s] = i;
  },
  Br = function (e) {
    for (var t = e.length; t && !e[--t];);
    for (var i = new gr(++t), r = 0, s = e[0], n = 1, o = function (e) {
        i[r++] = e;
      }, a = 1; a <= t; ++a) if (e[a] == s && a != t) ++n;else {
      if (!s && n > 2) {
        for (; n > 138; n -= 138) o(32754);
        n > 2 && (o(n > 10 ? n - 11 << 5 | 28690 : n - 3 << 5 | 12305), n = 0);
      } else if (n > 3) {
        for (o(s), --n; n > 6; n -= 6) o(8304);
        n > 2 && (o(n - 3 << 5 | 8208), n = 0);
      }
      for (; n--;) o(s);
      n = 1, s = e[a];
    }
    return [i.subarray(0, r), t];
  },
  Hr = function (e, t) {
    for (var i = 0, r = 0; r < t.length; ++r) i += e[r] * t[r];
    return i;
  },
  Ur = function (e, t, i) {
    var r = i.length,
      s = Mr(t + 2);
    e[s] = 255 & r, e[s + 1] = r >>> 8, e[s + 2] = 255 ^ e[s], e[s + 3] = 255 ^ e[s + 1];
    for (var n = 0; n < r; ++n) e[s + n + 4] = i[n];
    return 8 * (s + 4 + r);
  },
  zr = function (e, t, i, r, s, n, o, a, l, u, c) {
    Ar(t, c++, i), ++s[256];
    for (var d = Nr(s, 15), h = d[0], _ = d[1], p = Nr(n, 15), v = p[0], g = p[1], f = Br(h), m = f[0], b = f[1], y = Br(v), w = y[0], S = y[1], E = new gr(19), k = 0; k < m.length; ++k) E[31 & m[k]]++;
    for (k = 0; k < w.length; ++k) E[31 & w[k]]++;
    for (var x = Nr(E, 7), I = x[0], C = x[1], P = 19; P > 4 && !I[yr[P - 1]]; --P);
    var R,
      F,
      T,
      $,
      O = u + 5 << 3,
      M = Hr(s, Fr) + Hr(n, Tr) + o,
      L = Hr(s, h) + Hr(n, v) + o + 14 + 3 * P + Hr(E, I) + (2 * E[16] + 3 * E[17] + 7 * E[18]);
    if (O <= M && O <= L) return Ur(t, c, e.subarray(l, l + u));
    if (Ar(t, c, 1 + (L < M)), c += 2, L < M) {
      R = Rr(h, _, 0), F = h, T = Rr(v, g, 0), $ = v;
      var A = Rr(I, C, 0);
      Ar(t, c, b - 257), Ar(t, c + 5, S - 1), Ar(t, c + 10, P - 4), c += 14;
      for (k = 0; k < P; ++k) Ar(t, c + 3 * k, I[yr[k]]);
      c += 3 * P;
      for (var D = [m, w], N = 0; N < 2; ++N) {
        var q = D[N];
        for (k = 0; k < q.length; ++k) {
          var B = 31 & q[k];
          Ar(t, c, A[B]), c += I[B], B > 15 && (Ar(t, c, q[k] >>> 5 & 127), c += q[k] >>> 12);
        }
      }
    } else R = $r, F = Fr, T = Or, $ = Tr;
    for (k = 0; k < a; ++k) if (r[k] > 255) {
      B = r[k] >>> 18 & 31;
      Dr(t, c, R[B + 257]), c += F[B + 257], B > 7 && (Ar(t, c, r[k] >>> 23 & 31), c += mr[B]);
      var H = 31 & r[k];
      Dr(t, c, T[H]), c += $[H], H > 3 && (Dr(t, c, r[k] >>> 5 & 8191), c += br[H]);
    } else Dr(t, c, R[r[k]]), c += F[r[k]];
    return Dr(t, c, R[256]), c + F[256];
  },
  jr = new fr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
  Wr = function () {
    for (var e = new fr(256), t = 0; t < 256; ++t) {
      for (var i = t, r = 9; --r;) i = (1 & i && 3988292384) ^ i >>> 1;
      e[t] = i;
    }
    return e;
  }(),
  Vr = function () {
    var e = 4294967295;
    return {
      p: function (t) {
        for (var i = e, r = 0; r < t.length; ++r) i = Wr[255 & i ^ t[r]] ^ i >>> 8;
        e = i;
      },
      d: function () {
        return 4294967295 ^ e;
      }
    };
  },
  Gr = function (e, t, i, r, s) {
    return function (e, t, i, r, s, n) {
      var o = e.length,
        a = new vr(r + o + 5 * (1 + Math.floor(o / 7e3)) + s),
        l = a.subarray(r, a.length - s),
        u = 0;
      if (!t || o < 8) for (var c = 0; c <= o; c += 65535) {
        var d = c + 65535;
        d < o ? u = Ur(l, u, e.subarray(c, d)) : (l[c] = n, u = Ur(l, u, e.subarray(c, o)));
      } else {
        for (var h = jr[t - 1], _ = h >>> 13, p = 8191 & h, v = (1 << i) - 1, g = new gr(32768), f = new gr(v + 1), m = Math.ceil(i / 3), b = 2 * m, y = function (t) {
            return (e[t] ^ e[t + 1] << m ^ e[t + 2] << b) & v;
          }, w = new fr(25e3), S = new gr(288), E = new gr(32), k = 0, x = 0, I = (c = 0, 0), C = 0, P = 0; c < o; ++c) {
          var R = y(c),
            F = 32767 & c,
            T = f[R];
          if (g[F] = T, f[R] = F, C <= c) {
            var $ = o - c;
            if ((k > 7e3 || I > 24576) && $ > 423) {
              u = zr(e, l, 0, w, S, E, x, I, P, c - P, u), I = k = x = 0, P = c;
              for (var O = 0; O < 286; ++O) S[O] = 0;
              for (O = 0; O < 30; ++O) E[O] = 0;
            }
            var M = 2,
              L = 0,
              A = p,
              D = F - T & 32767;
            if ($ > 2 && R == y(c - D)) for (var N = Math.min(_, $) - 1, q = Math.min(32767, c), B = Math.min(258, $); D <= q && --A && F != T;) {
              if (e[c + M] == e[c + M - D]) {
                for (var H = 0; H < B && e[c + H] == e[c + H - D]; ++H);
                if (H > M) {
                  if (M = H, L = D, H > N) break;
                  var U = Math.min(D, H - 2),
                    z = 0;
                  for (O = 0; O < U; ++O) {
                    var j = c - D + O + 32768 & 32767,
                      W = j - g[j] + 32768 & 32767;
                    W > z && (z = W, T = j);
                  }
                }
              }
              D += (F = T) - (T = g[F]) + 32768 & 32767;
            }
            if (L) {
              w[I++] = 268435456 | kr[M] << 18 | xr[L];
              var V = 31 & kr[M],
                G = 31 & xr[L];
              x += mr[V] + br[G], ++S[257 + V], ++E[G], C = c + M, ++k;
            } else w[I++] = e[c], ++S[e[c]];
          }
        }
        u = zr(e, l, n, w, S, E, x, I, P, c - P, u);
      }
      return Lr(a, 0, r + Mr(u) + s);
    }(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, i, r, !s);
  },
  Jr = function (e, t, i) {
    for (; i; ++t) e[t] = i, i >>>= 8;
  },
  Yr = function (e, t) {
    var i = t.filename;
    if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && Jr(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), i) {
      e[3] = 8;
      for (var r = 0; r <= i.length; ++r) e[r + 10] = i.charCodeAt(r);
    }
  },
  Kr = function (e) {
    return 10 + (e.filename && e.filename.length + 1 || 0);
  };
function Xr(e, t) {
  void 0 === t && (t = {});
  var i = Vr(),
    r = e.length;
  i.p(e);
  var s = Gr(e, t, Kr(t), 8),
    n = s.length;
  return Yr(s, t), Jr(s, n - 8, i.d()), Jr(s, n - 4, r), s;
}
function Qr(e, t) {
  var i = e.length;
  if ("undefined" != typeof TextEncoder) return new TextEncoder().encode(e);
  for (var r = new vr(e.length + (e.length >>> 1)), s = 0, n = function (e) {
      r[s++] = e;
    }, o = 0; o < i; ++o) {
    if (s + 5 > r.length) {
      var a = new vr(s + 8 + (i - o << 1));
      a.set(r), r = a;
    }
    var l = e.charCodeAt(o);
    l < 128 || t ? n(l) : l < 2048 ? (n(192 | l >>> 6), n(128 | 63 & l)) : l > 55295 && l < 57344 ? (n(240 | (l = 65536 + (1047552 & l) | 1023 & e.charCodeAt(++o)) >>> 18), n(128 | l >>> 12 & 63), n(128 | l >>> 6 & 63), n(128 | 63 & l)) : (n(224 | l >>> 12), n(128 | l >>> 6 & 63), n(128 | 63 & l));
  }
  return Lr(r, 0, s);
}
var Zr = "[SessionRecording]",
  es = B(Zr),
  ts = 3e5,
  is = [Ri.MouseMove, Ri.MouseInteraction, Ri.Scroll, Ri.ViewportResize, Ri.Input, Ri.TouchMove, Ri.MediaInteraction, Ri.Drag],
  rs = e => ({
    rrwebMethod: e,
    enqueuedAt: Date.now(),
    attempt: 1
  });
function ss(e) {
  return function (e, t) {
    for (var i = "", r = 0; r < e.length;) {
      var s = e[r++];
      s < 128 || t ? i += String.fromCharCode(s) : s < 224 ? i += String.fromCharCode((31 & s) << 6 | 63 & e[r++]) : s < 240 ? i += String.fromCharCode((15 & s) << 12 | (63 & e[r++]) << 6 | 63 & e[r++]) : (s = ((15 & s) << 18 | (63 & e[r++]) << 12 | (63 & e[r++]) << 6 | 63 & e[r++]) - 65536, i += String.fromCharCode(55296 | s >> 10, 56320 | 1023 & s));
    }
    return i;
  }(Xr(Qr(JSON.stringify(e))), !0);
}
function ns(e) {
  return e.type === Pi.Custom && "sessionIdle" === e.data.tag;
}
function os(e, t) {
  return t.some(t => "regex" === t.matching && new RegExp(t.url).test(e));
}
class as {
  get sessionIdleThresholdMilliseconds() {
    return this.instance.config.session_recording.session_idle_threshold_ms || 3e5;
  }
  get rrwebRecord() {
    var e, t;
    return null == _ || null === (e = _.__PosthogExtensions__) || void 0 === e || null === (t = e.rrweb) || void 0 === t ? void 0 : t.record;
  }
  get started() {
    return this._captureStarted;
  }
  get sessionManager() {
    if (!this.instance.sessionManager) throw new Error(Zr + " must be started with a valid sessionManager.");
    return this.instance.sessionManager;
  }
  get fullSnapshotIntervalMillis() {
    var e, t;
    return "trigger_pending" === this.triggerStatus ? 6e4 : null !== (e = null === (t = this.instance.config.session_recording) || void 0 === t ? void 0 : t.full_snapshot_interval_millis) && void 0 !== e ? e : ts;
  }
  get isSampled() {
    var e = this.instance.get_property(ke);
    return L(e) ? e : null;
  }
  get sessionDuration() {
    var e,
      t,
      i = null === (e = this.buffer) || void 0 === e ? void 0 : e.data[(null === (t = this.buffer) || void 0 === t ? void 0 : t.data.length) - 1],
      {
        sessionStartTimestamp: r
      } = this.sessionManager.checkAndGetSessionAndWindowId(!0);
    return i ? i.timestamp - r : null;
  }
  get isRecordingEnabled() {
    var e = !!this.instance.get_property(ge),
      i = !this.instance.config.disable_session_recording;
    return t && e && i;
  }
  get isConsoleLogCaptureEnabled() {
    var e = !!this.instance.get_property(fe),
      t = this.instance.config.enable_recording_console_log;
    return null != t ? t : e;
  }
  get canvasRecording() {
    var e,
      t,
      i,
      r,
      s,
      n,
      o = this.instance.config.session_recording.captureCanvas,
      a = this.instance.get_property(be),
      l = null !== (e = null !== (t = null == o ? void 0 : o.recordCanvas) && void 0 !== t ? t : null == a ? void 0 : a.enabled) && void 0 !== e && e,
      u = null !== (i = null !== (r = null == o ? void 0 : o.canvasFps) && void 0 !== r ? r : null == a ? void 0 : a.fps) && void 0 !== i ? i : 0,
      c = null !== (s = null !== (n = null == o ? void 0 : o.canvasQuality) && void 0 !== n ? n : null == a ? void 0 : a.quality) && void 0 !== s ? s : 0;
    return {
      enabled: l,
      fps: _r(u, 0, 12, "canvas recording fps"),
      quality: _r(c, 0, 1, "canvas recording quality")
    };
  }
  get networkPayloadCapture() {
    var e,
      t,
      i = this.instance.get_property(me),
      r = {
        recordHeaders: null === (e = this.instance.config.session_recording) || void 0 === e ? void 0 : e.recordHeaders,
        recordBody: null === (t = this.instance.config.session_recording) || void 0 === t ? void 0 : t.recordBody
      },
      s = (null == r ? void 0 : r.recordHeaders) || (null == i ? void 0 : i.recordHeaders),
      n = (null == r ? void 0 : r.recordBody) || (null == i ? void 0 : i.recordBody),
      o = C(this.instance.config.capture_performance) ? this.instance.config.capture_performance.network_timing : this.instance.config.capture_performance,
      a = !!(L(o) ? o : null == i ? void 0 : i.capturePerformance);
    return s || n || a ? {
      recordHeaders: s,
      recordBody: n,
      recordPerformance: a
    } : void 0;
  }
  get sampleRate() {
    var e = this.instance.get_property(ye);
    return M(e) ? e : null;
  }
  get minimumDuration() {
    var e = this.instance.get_property(we);
    return M(e) ? e : null;
  }
  get status() {
    return this.receivedDecide ? this.isRecordingEnabled ? this._urlBlocked ? "paused" : O(this._linkedFlag) || this._linkedFlagSeen ? "trigger_pending" === this.triggerStatus ? "buffering" : L(this.isSampled) ? this.isSampled ? "sampled" : "disabled" : "active" : "buffering" : "disabled" : "buffering";
  }
  get urlTriggerStatus() {
    var e;
    return 0 === this._urlTriggers.length ? "trigger_disabled" : (null === (e = this.instance) || void 0 === e ? void 0 : e.get_property(xe)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get eventTriggerStatus() {
    var e;
    return 0 === this._eventTriggers.length ? "trigger_disabled" : (null === (e = this.instance) || void 0 === e ? void 0 : e.get_property(Ie)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get triggerStatus() {
    var e = "trigger_activated" === this.eventTriggerStatus || "trigger_activated" === this.urlTriggerStatus,
      t = "trigger_pending" === this.eventTriggerStatus || "trigger_pending" === this.urlTriggerStatus;
    return e ? "trigger_activated" : t ? "trigger_pending" : "trigger_disabled";
  }
  constructor(e) {
    if (W(this, "queuedRRWebEvents", []), W(this, "isIdle", !1), W(this, "_linkedFlagSeen", !1), W(this, "_lastActivityTimestamp", Date.now()), W(this, "_linkedFlag", null), W(this, "_removePageViewCaptureHook", void 0), W(this, "_onSessionIdListener", void 0), W(this, "_persistDecideOnSessionListener", void 0), W(this, "_samplingSessionListener", void 0), W(this, "_urlTriggers", []), W(this, "_urlBlocklist", []), W(this, "_urlBlocked", !1), W(this, "_eventTriggers", []), W(this, "_removeEventTriggerCaptureHook", void 0), W(this, "_forceAllowLocalhostNetworkCapture", !1), W(this, "_onBeforeUnload", () => {
      this._flushBuffer();
    }), W(this, "_onOffline", () => {
      this._tryAddCustomEvent("browser offline", {});
    }), W(this, "_onOnline", () => {
      this._tryAddCustomEvent("browser online", {});
    }), W(this, "_onVisibilityChange", () => {
      if (null != a && a.visibilityState) {
        var e = "window " + a.visibilityState;
        this._tryAddCustomEvent(e, {});
      }
    }), this.instance = e, this._captureStarted = !1, this._endpoint = "/s/", this.stopRrweb = void 0, this.receivedDecide = !1, !this.instance.sessionManager) throw es.error("started without valid sessionManager"), new Error(Zr + " started without valid sessionManager. This is a bug.");
    if (this.instance.config.__preview_experimental_cookieless_mode) throw new Error(Zr + " cannot be used with __preview_experimental_cookieless_mode.");
    var {
      sessionId: t,
      windowId: i
    } = this.sessionManager.checkAndGetSessionAndWindowId();
    this.sessionId = t, this.windowId = i, this.buffer = this.clearBuffer(), this.sessionIdleThresholdMilliseconds >= this.sessionManager.sessionTimeoutMs && es.warn("session_idle_threshold_ms (".concat(this.sessionIdleThresholdMilliseconds, ") is greater than the session timeout (").concat(this.sessionManager.sessionTimeoutMs, "). Session will never be detected as idle"));
  }
  startIfEnabledOrStop(e) {
    this.isRecordingEnabled ? (this._startCapture(e), null == t || t.addEventListener("beforeunload", this._onBeforeUnload), null == t || t.addEventListener("offline", this._onOffline), null == t || t.addEventListener("online", this._onOnline), null == t || t.addEventListener("visibilitychange", this._onVisibilityChange), this._setupSampling(), this._addEventTriggerListener(), O(this._removePageViewCaptureHook) && (this._removePageViewCaptureHook = this.instance.on("eventCaptured", e => {
      try {
        if ("$pageview" === e.event) {
          var t = null != e && e.properties.$current_url ? this._maskUrl(null == e ? void 0 : e.properties.$current_url) : "";
          if (!t) return;
          this._tryAddCustomEvent("$pageview", {
            href: t
          });
        }
      } catch (e) {
        es.error("Could not add $pageview to rrweb session", e);
      }
    })), this._onSessionIdListener || (this._onSessionIdListener = this.sessionManager.onSessionId((e, t, i) => {
      var r, s, n, o;
      i && (this._tryAddCustomEvent("$session_id_change", {
        sessionId: e,
        windowId: t,
        changeReason: i
      }), null === (r = this.instance) || void 0 === r || null === (s = r.persistence) || void 0 === s || s.unregister(Ie), null === (n = this.instance) || void 0 === n || null === (o = n.persistence) || void 0 === o || o.unregister(xe));
    }))) : this.stopRecording();
  }
  stopRecording() {
    var e, i, r, s;
    this._captureStarted && this.stopRrweb && (this.stopRrweb(), this.stopRrweb = void 0, this._captureStarted = !1, null == t || t.removeEventListener("beforeunload", this._onBeforeUnload), null == t || t.removeEventListener("offline", this._onOffline), null == t || t.removeEventListener("online", this._onOnline), null == t || t.removeEventListener("visibilitychange", this._onVisibilityChange), this.clearBuffer(), clearInterval(this._fullSnapshotTimer), null === (e = this._removePageViewCaptureHook) || void 0 === e || e.call(this), this._removePageViewCaptureHook = void 0, null === (i = this._removeEventTriggerCaptureHook) || void 0 === i || i.call(this), this._removeEventTriggerCaptureHook = void 0, null === (r = this._onSessionIdListener) || void 0 === r || r.call(this), this._onSessionIdListener = void 0, null === (s = this._samplingSessionListener) || void 0 === s || s.call(this), this._samplingSessionListener = void 0, es.info("stopped"));
  }
  makeSamplingDecision(e) {
    var t,
      i = this.sessionId !== e,
      r = this.sampleRate;
    if (M(r)) {
      var s,
        n = this.isSampled,
        o = i || !L(n);
      if (o) s = Math.random() < r;else s = n;
      o && (s ? this._reportStarted("sampled") : es.warn("Sample rate (".concat(r, ") has determined that this sessionId (").concat(e, ") will not be sent to the server.")), this._tryAddCustomEvent("samplingDecisionMade", {
        sampleRate: r,
        isSampled: s
      })), null === (t = this.instance.persistence) || void 0 === t || t.register({
        [ke]: s
      });
    } else {
      var a;
      null === (a = this.instance.persistence) || void 0 === a || a.register({
        [ke]: null
      });
    }
  }
  onRemoteConfig(e) {
    var t, i, r, s, n, o;
    (this._tryAddCustomEvent("$remote_config_received", e), this._persistRemoteConfig(e), this._linkedFlag = (null === (t = e.sessionRecording) || void 0 === t ? void 0 : t.linkedFlag) || null, null !== (i = e.sessionRecording) && void 0 !== i && i.endpoint) && (this._endpoint = null === (o = e.sessionRecording) || void 0 === o ? void 0 : o.endpoint);
    if (this._setupSampling(), !O(this._linkedFlag) && !this._linkedFlagSeen) {
      var a = F(this._linkedFlag) ? this._linkedFlag : this._linkedFlag.flag,
        l = F(this._linkedFlag) ? null : this._linkedFlag.variant;
      this.instance.onFeatureFlags((e, t) => {
        var i = C(t) && a in t,
          r = l ? t[a] === l : i;
        r && this._reportStarted("linked_flag_matched", {
          linkedFlag: a,
          linkedVariant: l
        }), this._linkedFlagSeen = r;
      });
    }
    null !== (r = e.sessionRecording) && void 0 !== r && r.urlTriggers && (this._urlTriggers = e.sessionRecording.urlTriggers), null !== (s = e.sessionRecording) && void 0 !== s && s.urlBlocklist && (this._urlBlocklist = e.sessionRecording.urlBlocklist), null !== (n = e.sessionRecording) && void 0 !== n && n.eventTriggers && (this._eventTriggers = e.sessionRecording.eventTriggers), this.receivedDecide = !0, this.startIfEnabledOrStop();
  }
  _setupSampling() {
    M(this.sampleRate) && O(this._samplingSessionListener) && (this._samplingSessionListener = this.sessionManager.onSessionId(e => {
      this.makeSamplingDecision(e);
    }));
  }
  _persistRemoteConfig(e) {
    if (this.instance.persistence) {
      var t,
        i = this.instance.persistence,
        r = () => {
          var t,
            r,
            s,
            n,
            o,
            a,
            l,
            u,
            c = null === (t = e.sessionRecording) || void 0 === t ? void 0 : t.sampleRate,
            d = O(c) ? null : parseFloat(c),
            h = null === (r = e.sessionRecording) || void 0 === r ? void 0 : r.minimumDurationMilliseconds;
          i.register({
            [ge]: !!e.sessionRecording,
            [fe]: null === (s = e.sessionRecording) || void 0 === s ? void 0 : s.consoleLogRecordingEnabled,
            [me]: j({
              capturePerformance: e.capturePerformance
            }, null === (n = e.sessionRecording) || void 0 === n ? void 0 : n.networkPayloadCapture),
            [be]: {
              enabled: null === (o = e.sessionRecording) || void 0 === o ? void 0 : o.recordCanvas,
              fps: null === (a = e.sessionRecording) || void 0 === a ? void 0 : a.canvasFps,
              quality: null === (l = e.sessionRecording) || void 0 === l ? void 0 : l.canvasQuality
            },
            [ye]: d,
            [we]: R(h) ? null : h,
            [Se]: null === (u = e.sessionRecording) || void 0 === u ? void 0 : u.scriptConfig
          });
        };
      r(), null === (t = this._persistDecideOnSessionListener) || void 0 === t || t.call(this), this._persistDecideOnSessionListener = this.sessionManager.onSessionId(r);
    }
  }
  log(e) {
    var t,
      i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "log";
    null === (t = this.instance.sessionRecording) || void 0 === t || t.onRRwebEmit({
      type: 6,
      data: {
        plugin: "rrweb/console@1",
        payload: {
          level: i,
          trace: [],
          payload: [JSON.stringify(e)]
        }
      },
      timestamp: Date.now()
    });
  }
  _startCapture(e) {
    if (!R(Object.assign) && !R(Array.from) && !(this._captureStarted || this.instance.config.disable_session_recording || this.instance.consent.isOptedOut())) {
      var t, i;
      if (this._captureStarted = !0, this.sessionManager.checkAndGetSessionAndWindowId(), this.rrwebRecord) this._onScriptLoaded();else null === (t = _.__PosthogExtensions__) || void 0 === t || null === (i = t.loadExternalDependency) || void 0 === i || i.call(t, this.instance, this.scriptName, e => {
        if (e) return es.error("could not load recorder", e);
        this._onScriptLoaded();
      });
      es.info("starting"), "active" === this.status && this._reportStarted(e || "recording_initialized");
    }
  }
  get scriptName() {
    var e, t, i;
    return (null === (e = this.instance) || void 0 === e || null === (t = e.persistence) || void 0 === t || null === (i = t.get_property(Se)) || void 0 === i ? void 0 : i.script) || "recorder";
  }
  isInteractiveEvent(e) {
    var t;
    return 3 === e.type && -1 !== is.indexOf(null === (t = e.data) || void 0 === t ? void 0 : t.source);
  }
  _updateWindowAndSessionIds(e) {
    var t = this.isInteractiveEvent(e);
    t || this.isIdle || e.timestamp - this._lastActivityTimestamp > this.sessionIdleThresholdMilliseconds && (this.isIdle = !0, clearInterval(this._fullSnapshotTimer), this._tryAddCustomEvent("sessionIdle", {
      eventTimestamp: e.timestamp,
      lastActivityTimestamp: this._lastActivityTimestamp,
      threshold: this.sessionIdleThresholdMilliseconds,
      bufferLength: this.buffer.data.length,
      bufferSize: this.buffer.size
    }), this._flushBuffer());
    var i = !1;
    if (t && (this._lastActivityTimestamp = e.timestamp, this.isIdle && (this.isIdle = !1, this._tryAddCustomEvent("sessionNoLongerIdle", {
      reason: "user activity",
      type: e.type
    }), i = !0)), !this.isIdle) {
      var {
          windowId: r,
          sessionId: s
        } = this.sessionManager.checkAndGetSessionAndWindowId(!t, e.timestamp),
        n = this.sessionId !== s,
        o = this.windowId !== r;
      this.windowId = r, this.sessionId = s, n || o ? (this.stopRecording(), this.startIfEnabledOrStop("session_id_changed")) : i && this._scheduleFullSnapshot();
    }
  }
  _tryRRWebMethod(e) {
    try {
      return e.rrwebMethod(), !0;
    } catch (t) {
      return this.queuedRRWebEvents.length < 10 ? this.queuedRRWebEvents.push({
        enqueuedAt: e.enqueuedAt || Date.now(),
        attempt: e.attempt++,
        rrwebMethod: e.rrwebMethod
      }) : es.warn("could not emit queued rrweb event.", t, e), !1;
    }
  }
  _tryAddCustomEvent(e, t) {
    return this._tryRRWebMethod(rs(() => this.rrwebRecord.addCustomEvent(e, t)));
  }
  _tryTakeFullSnapshot() {
    return this._tryRRWebMethod(rs(() => this.rrwebRecord.takeFullSnapshot()));
  }
  _onScriptLoaded() {
    var e,
      t = {
        blockClass: "ph-no-capture",
        blockSelector: void 0,
        ignoreClass: "ph-ignore-input",
        maskTextClass: "ph-mask",
        maskTextSelector: void 0,
        maskTextFn: void 0,
        maskAllInputs: !0,
        maskInputOptions: {
          password: !0
        },
        maskInputFn: void 0,
        slimDOMOptions: {},
        collectFonts: !1,
        inlineStylesheet: !0,
        recordCrossOriginIframes: !1
      },
      i = this.instance.config.session_recording;
    for (var [r, s] of Object.entries(i || {})) r in t && ("maskInputOptions" === r ? t.maskInputOptions = j({
      password: !0
    }, s) : t[r] = s);
    if (this.canvasRecording && this.canvasRecording.enabled && (t.recordCanvas = !0, t.sampling = {
      canvas: this.canvasRecording.fps
    }, t.dataURLOptions = {
      type: "image/webp",
      quality: this.canvasRecording.quality
    }), this.rrwebRecord) {
      this.mutationRateLimiter = null !== (e = this.mutationRateLimiter) && void 0 !== e ? e : new pr(this.rrwebRecord, {
        refillRate: this.instance.config.session_recording.__mutationRateLimiterRefillRate,
        bucketSize: this.instance.config.session_recording.__mutationRateLimiterBucketSize,
        onBlockedNode: (e, t) => {
          var i = "Too many mutations on node '".concat(e, "'. Rate limiting. This could be due to SVG animations or something similar");
          es.info(i, {
            node: t
          }), this.log(Zr + " " + i, "warn");
        }
      });
      var n = this._gatherRRWebPlugins();
      this.stopRrweb = this.rrwebRecord(j({
        emit: e => {
          this.onRRwebEmit(e);
        },
        plugins: n
      }, t)), this._lastActivityTimestamp = Date.now(), this.isIdle = !1, this._tryAddCustomEvent("$session_options", {
        sessionRecordingOptions: t,
        activePlugins: n.map(e => null == e ? void 0 : e.name)
      }), this._tryAddCustomEvent("$posthog_config", {
        config: this.instance.config
      });
    } else es.error("onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.");
  }
  _scheduleFullSnapshot() {
    if (this._fullSnapshotTimer && clearInterval(this._fullSnapshotTimer), !this.isIdle) {
      var e = this.fullSnapshotIntervalMillis;
      e && (this._fullSnapshotTimer = setInterval(() => {
        this._tryTakeFullSnapshot();
      }, e));
    }
  }
  _gatherRRWebPlugins() {
    var e,
      t,
      i,
      r,
      s = [],
      n = null === (e = _.__PosthogExtensions__) || void 0 === e || null === (t = e.rrwebPlugins) || void 0 === t ? void 0 : t.getRecordConsolePlugin;
    n && this.isConsoleLogCaptureEnabled && s.push(n());
    var o = null === (i = _.__PosthogExtensions__) || void 0 === i || null === (r = i.rrwebPlugins) || void 0 === r ? void 0 : r.getRecordNetworkPlugin;
    this.networkPayloadCapture && I(o) && (!ft.includes(location.hostname) || this._forceAllowLocalhostNetworkCapture ? s.push(o(hr(this.instance.config, this.networkPayloadCapture))) : es.info("NetworkCapture not started because we are on localhost."));
    return s;
  }
  onRRwebEmit(e) {
    var t;
    if (this._processQueuedEvents(), e && C(e)) {
      if (e.type === Pi.Meta) {
        var i = this._maskUrl(e.data.href);
        if (this._lastHref = i, !i) return;
        e.data.href = i;
      } else this._pageViewFallBack();
      if (this._checkUrlTriggerConditions(), "paused" !== this.status || function (e) {
        return e.type === Pi.Custom && "recording paused" === e.data.tag;
      }(e)) {
        e.type === Pi.FullSnapshot && this._scheduleFullSnapshot(), e.type === Pi.FullSnapshot && "trigger_pending" === this.triggerStatus && this.clearBuffer();
        var r = this.mutationRateLimiter ? this.mutationRateLimiter.throttleMutations(e) : e;
        if (r) {
          var s = function (e) {
            var t = e;
            if (t && C(t) && 6 === t.type && C(t.data) && "rrweb/console@1" === t.data.plugin) {
              t.data.payload.payload.length > 10 && (t.data.payload.payload = t.data.payload.payload.slice(0, 10), t.data.payload.payload.push("...[truncated]"));
              for (var i = [], r = 0; r < t.data.payload.payload.length; r++) t.data.payload.payload[r] && t.data.payload.payload[r].length > 2e3 ? i.push(t.data.payload.payload[r].slice(0, 2e3) + "...[truncated]") : i.push(t.data.payload.payload[r]);
              return t.data.payload.payload = i, e;
            }
            return e;
          }(r);
          if (this._updateWindowAndSessionIds(s), !this.isIdle || ns(s)) {
            if (ns(s)) {
              var n = s.data.payload;
              if (n) {
                var o = n.lastActivityTimestamp,
                  a = n.threshold;
                s.timestamp = o + a;
              }
            }
            var l = null === (t = this.instance.config.session_recording.compress_events) || void 0 === t || t ? function (e) {
                if (Ii(e) < 1024) return e;
                try {
                  if (e.type === Pi.FullSnapshot) return j(j({}, e), {}, {
                    data: ss(e.data),
                    cv: "2024-10"
                  });
                  if (e.type === Pi.IncrementalSnapshot && e.data.source === Ri.Mutation) return j(j({}, e), {}, {
                    cv: "2024-10",
                    data: j(j({}, e.data), {}, {
                      texts: ss(e.data.texts),
                      attributes: ss(e.data.attributes),
                      removes: ss(e.data.removes),
                      adds: ss(e.data.adds)
                    })
                  });
                  if (e.type === Pi.IncrementalSnapshot && e.data.source === Ri.StyleSheetRule) return j(j({}, e), {}, {
                    cv: "2024-10",
                    data: j(j({}, e.data), {}, {
                      adds: ss(e.data.adds),
                      removes: ss(e.data.removes)
                    })
                  });
                } catch (e) {
                  es.error("could not compress event - will use uncompressed event", e);
                }
                return e;
              }(s) : s,
              u = {
                $snapshot_bytes: Ii(l),
                $snapshot_data: l,
                $session_id: this.sessionId,
                $window_id: this.windowId
              };
            "disabled" !== this.status ? this._captureSnapshotBuffered(u) : this.clearBuffer();
          }
        }
      }
    }
  }
  _pageViewFallBack() {
    if (!this.instance.config.capture_pageview && t) {
      var e = this._maskUrl(t.location.href);
      this._lastHref !== e && (this._tryAddCustomEvent("$url_changed", {
        href: e
      }), this._lastHref = e);
    }
  }
  _processQueuedEvents() {
    if (this.queuedRRWebEvents.length) {
      var e = [...this.queuedRRWebEvents];
      this.queuedRRWebEvents = [], e.forEach(e => {
        Date.now() - e.enqueuedAt <= 2e3 && this._tryRRWebMethod(e);
      });
    }
  }
  _maskUrl(e) {
    var t = this.instance.config.session_recording;
    if (t.maskNetworkRequestFn) {
      var i,
        r = {
          url: e
        };
      return null === (i = r = t.maskNetworkRequestFn(r)) || void 0 === i ? void 0 : i.url;
    }
    return e;
  }
  clearBuffer() {
    return this.buffer = {
      size: 0,
      data: [],
      sessionId: this.sessionId,
      windowId: this.windowId
    }, this.buffer;
  }
  _flushBuffer() {
    this.flushBufferTimer && (clearTimeout(this.flushBufferTimer), this.flushBufferTimer = void 0);
    var e = this.minimumDuration,
      t = this.sessionDuration,
      i = M(t) && t >= 0,
      r = M(e) && i && t < e;
    if ("buffering" === this.status || "paused" === this.status || r) return this.flushBufferTimer = setTimeout(() => {
      this._flushBuffer();
    }, 2e3), this.buffer;
    this.buffer.data.length > 0 && Ci(this.buffer).forEach(e => {
      this._captureSnapshot({
        $snapshot_bytes: e.size,
        $snapshot_data: e.data,
        $session_id: e.sessionId,
        $window_id: e.windowId,
        $lib: "web",
        $lib_version: p.LIB_VERSION
      });
    });
    return this.clearBuffer();
  }
  _captureSnapshotBuffered(e) {
    var t,
      i = 2 + ((null === (t = this.buffer) || void 0 === t ? void 0 : t.data.length) || 0);
    !this.isIdle && (this.buffer.size + e.$snapshot_bytes + i > 943718.4 || this.buffer.sessionId !== this.sessionId) && (this.buffer = this._flushBuffer()), this.buffer.size += e.$snapshot_bytes, this.buffer.data.push(e.$snapshot_data), this.flushBufferTimer || this.isIdle || (this.flushBufferTimer = setTimeout(() => {
      this._flushBuffer();
    }, 2e3));
  }
  _captureSnapshot(e) {
    this.instance.capture("$snapshot", e, {
      _url: this.instance.requestRouter.endpointFor("api", this._endpoint),
      _noTruncate: !0,
      _batchKey: "recordings",
      skip_client_rate_limiting: !0
    });
  }
  _checkUrlTriggerConditions() {
    if (void 0 !== t && t.location.href) {
      var e = t.location.href,
        i = "paused" === this.status,
        r = os(e, this._urlBlocklist);
      r && !i ? this._pauseRecording() : !r && i && this._resumeRecording(), os(e, this._urlTriggers) && this._activateTrigger("url");
    }
  }
  _activateTrigger(e) {
    var t, i;
    "trigger_pending" === this.triggerStatus && (null === (t = this.instance) || void 0 === t || null === (i = t.persistence) || void 0 === i || i.register({
      ["url" === e ? xe : Ie]: this.sessionId
    }), this._flushBuffer(), this._reportStarted(e + "_trigger_matched"));
  }
  _pauseRecording() {
    "paused" !== this.status && (this._urlBlocked = !0, clearInterval(this._fullSnapshotTimer), es.info("recording paused due to URL blocker"), this._tryAddCustomEvent("recording paused", {
      reason: "url blocker"
    }));
  }
  _resumeRecording() {
    "paused" === this.status && (this._urlBlocked = !1, this._tryTakeFullSnapshot(), this._scheduleFullSnapshot(), this._tryAddCustomEvent("recording resumed", {
      reason: "left blocked url"
    }), es.info("recording resumed"));
  }
  _addEventTriggerListener() {
    0 !== this._eventTriggers.length && O(this._removeEventTriggerCaptureHook) && (this._removeEventTriggerCaptureHook = this.instance.on("eventCaptured", e => {
      try {
        this._eventTriggers.includes(e.event) && this._activateTrigger("event");
      } catch (e) {
        es.error("Could not activate event trigger", e);
      }
    }));
  }
  overrideLinkedFlag() {
    this._linkedFlagSeen = !0, this._tryTakeFullSnapshot(), this._reportStarted("linked_flag_overridden");
  }
  overrideSampling() {
    var e;
    null === (e = this.instance.persistence) || void 0 === e || e.register({
      [ke]: !0
    }), this._tryTakeFullSnapshot(), this._reportStarted("sampling_overridden");
  }
  overrideTrigger(e) {
    this._activateTrigger(e);
  }
  _reportStarted(e, t) {
    this.instance.register_for_session({
      $session_recording_start_reason: e
    }), es.info(e.replace("_", " "), t), m(["recording_initialized", "session_id_changed"], e) || this._tryAddCustomEvent(e, t);
  }
}
var ls = B("[RemoteConfig]");
class us {
  constructor(e) {
    this.instance = e;
  }
  get remoteConfig() {
    var e, t;
    return null === (e = _._POSTHOG_REMOTE_CONFIG) || void 0 === e || null === (t = e[this.instance.config.token]) || void 0 === t ? void 0 : t.config;
  }
  _loadRemoteConfigJs(e) {
    var t, i, r;
    null !== (t = _.__PosthogExtensions__) && void 0 !== t && t.loadExternalDependency ? null === (i = _.__PosthogExtensions__) || void 0 === i || null === (r = i.loadExternalDependency) || void 0 === r || r.call(i, this.instance, "remote-config", () => e(this.remoteConfig)) : (ls.error("PostHog Extensions not found. Cannot load remote config."), e());
  }
  _loadRemoteConfigJSON(e) {
    this.instance._send_request({
      method: "GET",
      url: this.instance.requestRouter.endpointFor("assets", "/array/".concat(this.instance.config.token, "/config")),
      callback: t => {
        e(t.json);
      }
    });
  }
  load() {
    try {
      if (this.remoteConfig) return ls.info("Using preloaded remote config", this.remoteConfig), void this.onRemoteConfig(this.remoteConfig);
      if (this.instance.config.advanced_disable_decide) return void ls.warn("Remote config is disabled. Falling back to local config.");
      this._loadRemoteConfigJs(e => {
        if (!e) return ls.info("No config found after loading remote JS config. Falling back to JSON."), void this._loadRemoteConfigJSON(e => {
          this.onRemoteConfig(e);
        });
        this.onRemoteConfig(e);
      });
    } catch (e) {
      ls.error("Error loading remote config", e);
    }
  }
  onRemoteConfig(e) {
    e ? this.instance.config.__preview_remote_config ? (this.instance._onRemoteConfig(e), !1 !== e.hasFeatureFlags && this.instance.featureFlags.ensureFlagsLoaded()) : ls.info("__preview_remote_config is disabled. Logging config instead", e) : ls.error("Failed to fetch remote config from PostHog.");
  }
}
var cs,
  ds = null != t && t.location ? Et(t.location.hash, "__posthog") || Et(location.hash, "state") : null,
  hs = "_postHogToolbarParams",
  _s = B("[Toolbar]");
!function (e) {
  e[e.UNINITIALIZED = 0] = "UNINITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.LOADED = 2] = "LOADED";
}(cs || (cs = {}));
class ps {
  constructor(e) {
    this.instance = e;
  }
  setToolbarState(e) {
    _.ph_toolbar_state = e;
  }
  getToolbarState() {
    var e;
    return null !== (e = _.ph_toolbar_state) && void 0 !== e ? e : cs.UNINITIALIZED;
  }
  maybeLoadToolbar() {
    var e,
      i,
      r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
      s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    if (!t || !a) return !1;
    r = null !== (e = r) && void 0 !== e ? e : t.location, n = null !== (i = n) && void 0 !== i ? i : t.history;
    try {
      if (!s) {
        try {
          t.localStorage.setItem("test", "test"), t.localStorage.removeItem("test");
        } catch (e) {
          return !1;
        }
        s = null == t ? void 0 : t.localStorage;
      }
      var o,
        l = ds || Et(r.hash, "__posthog") || Et(r.hash, "state"),
        u = l ? Z(() => JSON.parse(atob(decodeURIComponent(l)))) || Z(() => JSON.parse(decodeURIComponent(l))) : null;
      return u && "ph_authorize" === u.action ? ((o = u).source = "url", o && Object.keys(o).length > 0 && (u.desiredHash ? r.hash = u.desiredHash : n ? n.replaceState(n.state, "", r.pathname + r.search) : r.hash = "")) : ((o = JSON.parse(s.getItem(hs) || "{}")).source = "localstorage", delete o.userIntent), !(!o.token || this.instance.config.token !== o.token) && (this.loadToolbar(o), !0);
    } catch (e) {
      return !1;
    }
  }
  _callLoadToolbar(e) {
    var t = _.ph_load_toolbar || _.ph_load_editor;
    !O(t) && I(t) ? t(e, this.instance) : _s.warn("No toolbar load function found");
  }
  loadToolbar(e) {
    var i = !(null == a || !a.getElementById(He));
    if (!t || i) return !1;
    var r = "custom" === this.instance.requestRouter.region && this.instance.config.advanced_disable_toolbar_metrics,
      s = j(j({
        token: this.instance.config.token
      }, e), {}, {
        apiURL: this.instance.requestRouter.endpointFor("ui")
      }, r ? {
        instrument: !1
      } : {});
    if (t.localStorage.setItem(hs, JSON.stringify(j(j({}, s), {}, {
      source: void 0
    }))), this.getToolbarState() === cs.LOADED) this._callLoadToolbar(s);else if (this.getToolbarState() === cs.UNINITIALIZED) {
      var n, o;
      this.setToolbarState(cs.LOADING), null === (n = _.__PosthogExtensions__) || void 0 === n || null === (o = n.loadExternalDependency) || void 0 === o || o.call(n, this.instance, "toolbar", e => {
        if (e) return _s.error("[Toolbar] Failed to load", e), void this.setToolbarState(cs.UNINITIALIZED);
        this.setToolbarState(cs.LOADED), this._callLoadToolbar(s);
      }), re(t, "turbolinks:load", () => {
        this.setToolbarState(cs.UNINITIALIZED), this.loadToolbar(s);
      });
    }
    return !0;
  }
  _loadEditor(e) {
    return this.loadToolbar(e);
  }
  maybeLoadEditor() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
      t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    return this.maybeLoadToolbar(e, t, i);
  }
}
class vs {
  constructor(e) {
    W(this, "isPaused", !0), W(this, "queue", []), W(this, "flushTimeoutMs", 3e3), this.sendRequest = e;
  }
  enqueue(e) {
    this.queue.push(e), this.flushTimeout || this.setFlushTimeout();
  }
  unload() {
    this.clearFlushTimeout();
    var e = this.queue.length > 0 ? this.formatQueue() : {},
      t = Object.values(e),
      i = [...t.filter(e => 0 === e.url.indexOf("/e")), ...t.filter(e => 0 !== e.url.indexOf("/e"))];
    i.map(e => {
      this.sendRequest(j(j({}, e), {}, {
        transport: "sendBeacon"
      }));
    });
  }
  enable() {
    this.isPaused = !1, this.setFlushTimeout();
  }
  setFlushTimeout() {
    var e = this;
    this.isPaused || (this.flushTimeout = setTimeout(() => {
      if (this.clearFlushTimeout(), this.queue.length > 0) {
        var t = this.formatQueue(),
          i = function (i) {
            var r = t[i],
              s = new Date().getTime();
            r.data && x(r.data) && Y(r.data, e => {
              e.offset = Math.abs(e.timestamp - s), delete e.timestamp;
            }), e.sendRequest(r);
          };
        for (var r in t) i(r);
      }
    }, this.flushTimeoutMs));
  }
  clearFlushTimeout() {
    clearTimeout(this.flushTimeout), this.flushTimeout = void 0;
  }
  formatQueue() {
    var e = {};
    return Y(this.queue, t => {
      var i,
        r = t,
        s = (r ? r.batchKey : null) || r.url;
      R(e[s]) && (e[s] = j(j({}, r), {}, {
        data: []
      })), null === (i = e[s].data) || void 0 === i || i.push(r.data);
    }), this.queue = [], e;
  }
}
var gs = function (e) {
    var t,
      i,
      r,
      s,
      n = "";
    for (t = i = 0, r = (e = (e + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, s = 0; s < r; s++) {
      var o = e.charCodeAt(s),
        a = null;
      o < 128 ? i++ : a = o > 127 && o < 2048 ? String.fromCharCode(o >> 6 | 192, 63 & o | 128) : String.fromCharCode(o >> 12 | 224, o >> 6 & 63 | 128, 63 & o | 128), $(a) || (i > t && (n += e.substring(t, i)), n += a, t = i = s + 1);
    }
    return i > t && (n += e.substring(t, e.length)), n;
  },
  fs = !!c || !!u,
  ms = "text/plain",
  bs = (e, t) => {
    var [i, r] = e.split("?"),
      s = j({}, t);
    null == r || r.split("&").forEach(e => {
      var [t] = e.split("=");
      delete s[t];
    });
    var n = yt(s);
    return n = n ? (r ? r + "&" : "") + n : r, "".concat(i, "?").concat(n);
  },
  ys = (e, t) => JSON.stringify(e, (e, t) => "bigint" == typeof t ? t.toString() : t, t),
  ws = t => {
    var {
      data: i,
      compression: r
    } = t;
    if (i) {
      if (r === e.GZipJS) {
        var s = Xr(Qr(ys(i)), {
            mtime: 0
          }),
          n = new Blob([s], {
            type: ms
          });
        return {
          contentType: ms,
          body: n,
          estimatedSize: n.size
        };
      }
      if (r === e.Base64) {
        var o = function (e) {
            var t,
              i,
              r,
              s,
              n,
              o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              a = 0,
              l = 0,
              u = "",
              c = [];
            if (!e) return e;
            e = gs(e);
            do {
              t = (n = e.charCodeAt(a++) << 16 | e.charCodeAt(a++) << 8 | e.charCodeAt(a++)) >> 18 & 63, i = n >> 12 & 63, r = n >> 6 & 63, s = 63 & n, c[l++] = o.charAt(t) + o.charAt(i) + o.charAt(r) + o.charAt(s);
            } while (a < e.length);
            switch (u = c.join(""), e.length % 3) {
              case 1:
                u = u.slice(0, -2) + "==";
                break;
              case 2:
                u = u.slice(0, -1) + "=";
            }
            return u;
          }(ys(i)),
          a = (e => "data=" + encodeURIComponent("string" == typeof e ? e : ys(e)))(o);
        return {
          contentType: "application/x-www-form-urlencoded",
          body: a,
          estimatedSize: new Blob([a]).size
        };
      }
      var l = ys(i);
      return {
        contentType: "application/json",
        body: l,
        estimatedSize: new Blob([l]).size
      };
    }
  },
  Ss = [];
u && Ss.push({
  transport: "fetch",
  method: e => {
    var t,
      i,
      {
        contentType: r,
        body: s,
        estimatedSize: n
      } = null !== (t = ws(e)) && void 0 !== t ? t : {},
      o = new Headers();
    Y(e.headers, function (e, t) {
      o.append(t, e);
    }), r && o.append("Content-Type", r);
    var a = e.url,
      l = null;
    if (d) {
      var c = new d();
      l = {
        signal: c.signal,
        timeout: setTimeout(() => c.abort(), e.timeout)
      };
    }
    u(a, j({
      method: (null == e ? void 0 : e.method) || "GET",
      headers: o,
      keepalive: "POST" === e.method && (n || 0) < 52428.8,
      body: s,
      signal: null === (i = l) || void 0 === i ? void 0 : i.signal
    }, e.fetchOptions)).then(t => t.text().then(i => {
      var r,
        s = {
          statusCode: t.status,
          text: i
        };
      if (200 === t.status) try {
        s.json = JSON.parse(i);
      } catch (e) {
        q.error(e);
      }
      null === (r = e.callback) || void 0 === r || r.call(e, s);
    })).catch(t => {
      var i;
      q.error(t), null === (i = e.callback) || void 0 === i || i.call(e, {
        statusCode: 0,
        text: t
      });
    }).finally(() => l ? clearTimeout(l.timeout) : null);
  }
}), c && Ss.push({
  transport: "XHR",
  method: e => {
    var t,
      i = new c();
    i.open(e.method || "GET", e.url, !0);
    var {
      contentType: r,
      body: s
    } = null !== (t = ws(e)) && void 0 !== t ? t : {};
    Y(e.headers, function (e, t) {
      i.setRequestHeader(t, e);
    }), r && i.setRequestHeader("Content-Type", r), e.timeout && (i.timeout = e.timeout), i.withCredentials = !0, i.onreadystatechange = () => {
      if (4 === i.readyState) {
        var t,
          r = {
            statusCode: i.status,
            text: i.responseText
          };
        if (200 === i.status) try {
          r.json = JSON.parse(i.responseText);
        } catch (e) {}
        null === (t = e.callback) || void 0 === t || t.call(e, r);
      }
    }, i.send(s);
  }
}), null != o && o.sendBeacon && Ss.push({
  transport: "sendBeacon",
  method: e => {
    var t = bs(e.url, {
      beacon: "1"
    });
    try {
      var i,
        {
          contentType: r,
          body: s
        } = null !== (i = ws(e)) && void 0 !== i ? i : {},
        n = "string" == typeof s ? new Blob([s], {
          type: r
        }) : s;
      o.sendBeacon(t, n);
    } catch (e) {}
  }
});
var Es = ["retriesPerformedSoFar"];
class ks {
  constructor(e) {
    W(this, "isPolling", !1), W(this, "pollIntervalMs", 3e3), W(this, "queue", []), this.instance = e, this.queue = [], this.areWeOnline = !0, !R(t) && "onLine" in t.navigator && (this.areWeOnline = t.navigator.onLine, t.addEventListener("online", () => {
      this.areWeOnline = !0, this.flush();
    }), t.addEventListener("offline", () => {
      this.areWeOnline = !1;
    }));
  }
  retriableRequest(e) {
    var {
        retriesPerformedSoFar: t
      } = e,
      i = V(e, Es);
    M(t) && t > 0 && (i.url = bs(i.url, {
      retry_count: t
    })), this.instance._send_request(j(j({}, i), {}, {
      callback: e => {
        var r;
        200 !== e.statusCode && (e.statusCode < 400 || e.statusCode >= 500) && (null != t ? t : 0) < 10 ? this.enqueue(j({
          retriesPerformedSoFar: t
        }, i)) : null === (r = i.callback) || void 0 === r || r.call(i, e);
      }
    }));
  }
  enqueue(e) {
    var t = e.retriesPerformedSoFar || 0;
    e.retriesPerformedSoFar = t + 1;
    var i = function (e) {
        var t = 3e3 * Math.pow(2, e),
          i = t / 2,
          r = Math.min(18e5, t),
          s = (Math.random() - .5) * (r - i);
        return Math.ceil(r + s);
      }(t),
      r = Date.now() + i;
    this.queue.push({
      retryAt: r,
      requestOptions: e
    });
    var s = "Enqueued failed request for retry in ".concat(i);
    navigator.onLine || (s += " (Browser is offline)"), q.warn(s), this.isPolling || (this.isPolling = !0, this.poll());
  }
  poll() {
    this.poller && clearTimeout(this.poller), this.poller = setTimeout(() => {
      this.areWeOnline && this.queue.length > 0 && this.flush(), this.poll();
    }, this.pollIntervalMs);
  }
  flush() {
    var e = Date.now(),
      t = [],
      i = this.queue.filter(i => i.retryAt < e || (t.push(i), !1));
    if (this.queue = t, i.length > 0) for (var {
      requestOptions: r
    } of i) this.retriableRequest(r);
  }
  unload() {
    for (var {
      requestOptions: e
    } of (this.poller && (clearTimeout(this.poller), this.poller = void 0), this.queue)) try {
      this.instance._send_request(j(j({}, e), {}, {
        transport: "sendBeacon"
      }));
    } catch (e) {
      q.error(e);
    }
    this.queue = [];
  }
}
var xs,
  Is = B("[SessionId]");
class Cs {
  constructor(e, t, i) {
    var r;
    if (W(this, "_sessionIdChangedHandlers", []), !e.persistence) throw new Error("SessionIdManager requires a PostHogPersistence instance");
    if (e.config.__preview_experimental_cookieless_mode) throw new Error("SessionIdManager cannot be used with __preview_experimental_cookieless_mode");
    this.config = e.config, this.persistence = e.persistence, this._windowId = void 0, this._sessionId = void 0, this._sessionStartTimestamp = null, this._sessionActivityTimestamp = null, this._sessionIdGenerator = t || it, this._windowIdGenerator = i || it;
    var s = this.config.persistence_name || this.config.token,
      n = this.config.session_idle_timeout_seconds || 1800;
    if (this._sessionTimeoutMs = 1e3 * _r(n, 60, 36e3, "session_idle_timeout_seconds", 1800), e.register({
      $configured_session_timeout_ms: this._sessionTimeoutMs
    }), this.resetIdleTimer(), this._window_id_storage_key = "ph_" + s + "_window_id", this._primary_window_exists_storage_key = "ph_" + s + "_primary_window_exists", this._canUseSessionStorage()) {
      var o = gt.parse(this._window_id_storage_key),
        a = gt.parse(this._primary_window_exists_storage_key);
      o && !a ? this._windowId = o : gt.remove(this._window_id_storage_key), gt.set(this._primary_window_exists_storage_key, !0);
    }
    if (null !== (r = this.config.bootstrap) && void 0 !== r && r.sessionID) try {
      var l = (e => {
        var t = e.replace(/-/g, "");
        if (32 !== t.length) throw new Error("Not a valid UUID");
        if ("7" !== t[12]) throw new Error("Not a UUIDv7");
        return parseInt(t.substring(0, 12), 16);
      })(this.config.bootstrap.sessionID);
      this._setSessionId(this.config.bootstrap.sessionID, new Date().getTime(), l);
    } catch (e) {
      Is.error("Invalid sessionID in bootstrap", e);
    }
    this._listenToReloadWindow();
  }
  get sessionTimeoutMs() {
    return this._sessionTimeoutMs;
  }
  onSessionId(e) {
    return R(this._sessionIdChangedHandlers) && (this._sessionIdChangedHandlers = []), this._sessionIdChangedHandlers.push(e), this._sessionId && e(this._sessionId, this._windowId), () => {
      this._sessionIdChangedHandlers = this._sessionIdChangedHandlers.filter(t => t !== e);
    };
  }
  _canUseSessionStorage() {
    return "memory" !== this.config.persistence && !this.persistence.disabled && gt.is_supported();
  }
  _setWindowId(e) {
    e !== this._windowId && (this._windowId = e, this._canUseSessionStorage() && gt.set(this._window_id_storage_key, e));
  }
  _getWindowId() {
    return this._windowId ? this._windowId : this._canUseSessionStorage() ? gt.parse(this._window_id_storage_key) : null;
  }
  _setSessionId(e, t, i) {
    e === this._sessionId && t === this._sessionActivityTimestamp && i === this._sessionStartTimestamp || (this._sessionStartTimestamp = i, this._sessionActivityTimestamp = t, this._sessionId = e, this.persistence.register({
      [Ee]: [t, e, i]
    }));
  }
  _getSessionId() {
    if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp) return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
    var e = this.persistence.props[Ee];
    return x(e) && 2 === e.length && e.push(e[0]), e || [0, null, 0];
  }
  resetSessionId() {
    this._setSessionId(null, null, null);
  }
  _listenToReloadWindow() {
    null == t || t.addEventListener("beforeunload", () => {
      this._canUseSessionStorage() && gt.remove(this._primary_window_exists_storage_key);
    });
  }
  checkAndGetSessionAndWindowId() {
    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
      t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    if (this.config.__preview_experimental_cookieless_mode) throw new Error("checkAndGetSessionAndWindowId should not be called in __preview_experimental_cookieless_mode");
    var i = t || new Date().getTime(),
      [r, s, n] = this._getSessionId(),
      o = this._getWindowId(),
      a = M(n) && n > 0 && Math.abs(i - n) > 864e5,
      l = !1,
      u = !s,
      c = !e && Math.abs(i - r) > this.sessionTimeoutMs;
    u || c || a ? (s = this._sessionIdGenerator(), o = this._windowIdGenerator(), Is.info("new session ID generated", {
      sessionId: s,
      windowId: o,
      changeReason: {
        noSessionId: u,
        activityTimeout: c,
        sessionPastMaximumLength: a
      }
    }), n = i, l = !0) : o || (o = this._windowIdGenerator(), l = !0);
    var d = 0 === r || !e || a ? i : r,
      h = 0 === n ? new Date().getTime() : n;
    return this._setWindowId(o), this._setSessionId(s, d, h), e || this.resetIdleTimer(), l && this._sessionIdChangedHandlers.forEach(e => e(s, o, l ? {
      noSessionId: u,
      activityTimeout: c,
      sessionPastMaximumLength: a
    } : void 0)), {
      sessionId: s,
      windowId: o,
      sessionStartTimestamp: h,
      changeReason: l ? {
        noSessionId: u,
        activityTimeout: c,
        sessionPastMaximumLength: a
      } : void 0,
      lastActivityTimestamp: r
    };
  }
  resetIdleTimer() {
    clearTimeout(this._enforceIdleTimeout), this._enforceIdleTimeout = setTimeout(() => {
      this.resetSessionId();
    }, 1.1 * this.sessionTimeoutMs);
  }
}
!function (e) {
  e.US = "us", e.EU = "eu", e.CUSTOM = "custom";
}(xs || (xs = {}));
var Ps = "i.posthog.com";
class Rs {
  constructor(e) {
    W(this, "_regionCache", {}), this.instance = e;
  }
  get apiHost() {
    var e = this.instance.config.api_host.trim().replace(/\/$/, "");
    return "https://app.posthog.com" === e ? "https://us.i.posthog.com" : e;
  }
  get uiHost() {
    var e,
      t = null === (e = this.instance.config.ui_host) || void 0 === e ? void 0 : e.replace(/\/$/, "");
    return t || (t = this.apiHost.replace(".".concat(Ps), ".posthog.com")), "https://app.posthog.com" === t ? "https://us.posthog.com" : t;
  }
  get region() {
    return this._regionCache[this.apiHost] || (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = xs.US : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = xs.EU : this._regionCache[this.apiHost] = xs.CUSTOM), this._regionCache[this.apiHost];
  }
  endpointFor(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    if (t && (t = "/" === t[0] ? t : "/".concat(t)), "ui" === e) return this.uiHost + t;
    if (this.region === xs.CUSTOM) return this.apiHost + t;
    var i = Ps + t;
    switch (e) {
      case "assets":
        return "https://".concat(this.region, "-assets.").concat(i);
      case "api":
        return "https://".concat(this.region, ".").concat(i);
    }
  }
}
var Fs = "posthog-js";
function Ts(e) {
  var {
    organization: t,
    projectId: i,
    prefix: r,
    severityAllowList: s = ["error"]
  } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return n => {
    var o, a, l, u, c;
    if (!("*" === s || s.includes(n.level)) || !e.__loaded) return n;
    n.tags || (n.tags = {});
    var d = e.requestRouter.endpointFor("ui", "/project/".concat(e.config.token, "/person/").concat(e.get_distinct_id()));
    n.tags["PostHog Person URL"] = d, e.sessionRecordingStarted() && (n.tags["PostHog Recording URL"] = e.get_session_replay_url({
      withTimestamp: !0
    }));
    var h = (null === (o = n.exception) || void 0 === o ? void 0 : o.values) || [];
    h.forEach(e => {
      e.stacktrace && (e.stacktrace.type = "raw", e.stacktrace.frames.forEach(e => {
        e.platform = "web:javascript";
      }));
    });
    var _ = {
      $exception_message: (null === (a = h[0]) || void 0 === a ? void 0 : a.value) || n.message,
      $exception_type: null === (l = h[0]) || void 0 === l ? void 0 : l.type,
      $exception_personURL: d,
      $exception_level: n.level,
      $exception_list: h,
      $sentry_event_id: n.event_id,
      $sentry_exception: n.exception,
      $sentry_exception_message: (null === (u = h[0]) || void 0 === u ? void 0 : u.value) || n.message,
      $sentry_exception_type: null === (c = h[0]) || void 0 === c ? void 0 : c.type,
      $sentry_tags: n.tags
    };
    return t && i && (_.$sentry_url = (r || "https://sentry.io/organizations/") + t + "/issues/?project=" + i + "&query=" + n.event_id), e.exceptions.sendExceptionEvent(_), n;
  };
}
class $s {
  constructor(e, t, i, r, s) {
    this.name = Fs, this.setupOnce = function (n) {
      n(Ts(e, {
        organization: t,
        projectId: i,
        prefix: r,
        severityAllowList: s
      }));
    };
  }
}
var Os = B("[SegmentIntegration]");
function Ms(e, t) {
  var i = e.config.segment;
  if (!i) return t();
  !function (e, t) {
    var i = e.config.segment;
    if (!i) return t();
    var r = i => {
        var r = () => i.anonymousId() || it();
        e.config.get_device_id = r, i.id() && (e.register({
          distinct_id: i.id(),
          $device_id: r()
        }), e.persistence.set_property(Me, "identified")), t();
      },
      s = i.user();
    "then" in s && I(s.then) ? s.then(e => r(e)) : r(s);
  }(e, () => {
    i.register((e => {
      Promise && Promise.resolve || Os.warn("This browser does not have Promise support, and can not use the segment integration");
      var t = (t, i) => {
        var r;
        if (!i) return t;
        t.event.userId || t.event.anonymousId === e.get_distinct_id() || (Os.info("No userId set, resetting PostHog"), e.reset()), t.event.userId && t.event.userId !== e.get_distinct_id() && (Os.info("UserId set, identifying with PostHog"), e.identify(t.event.userId));
        var s = e._calculate_event_properties(i, null !== (r = t.event.properties) && void 0 !== r ? r : {}, new Date());
        return t.event.properties = Object.assign({}, s, t.event.properties), t;
      };
      return {
        name: "PostHog JS",
        type: "enrichment",
        version: "1.0.0",
        isLoaded: () => !0,
        load: () => Promise.resolve(),
        track: e => t(e, e.event.event),
        page: e => t(e, "$pageview"),
        identify: e => t(e, "$identify"),
        screen: e => t(e, "$screen")
      };
    })(e)).then(() => {
      t();
    });
  });
}
class Ls {
  constructor(e) {
    this._instance = e;
  }
  doPageView(e, i) {
    var r,
      s = this._previousPageViewProperties(e, i);
    return this._currentPageview = {
      pathname: null !== (r = null == t ? void 0 : t.location.pathname) && void 0 !== r ? r : "",
      pageViewId: i,
      timestamp: e
    }, this._instance.scrollManager.resetContext(), s;
  }
  doPageLeave(e) {
    var t;
    return this._previousPageViewProperties(e, null === (t = this._currentPageview) || void 0 === t ? void 0 : t.pageViewId);
  }
  doEvent() {
    var e;
    return {
      $pageview_id: null === (e = this._currentPageview) || void 0 === e ? void 0 : e.pageViewId
    };
  }
  _previousPageViewProperties(e, t) {
    var i = this._currentPageview;
    if (!i) return {
      $pageview_id: t
    };
    var r = {
        $pageview_id: t,
        $prev_pageview_id: i.pageViewId
      },
      s = this._instance.scrollManager.getContext();
    if (s && !this._instance.config.disable_scroll_properties) {
      var {
        maxScrollHeight: n,
        lastScrollY: o,
        maxScrollY: a,
        maxContentHeight: l,
        lastContentY: u,
        maxContentY: c
      } = s;
      if (!(R(n) || R(o) || R(a) || R(l) || R(u) || R(c))) {
        n = Math.ceil(n), o = Math.ceil(o), a = Math.ceil(a), l = Math.ceil(l), u = Math.ceil(u), c = Math.ceil(c);
        var d = n <= 1 ? 1 : _r(o / n, 0, 1),
          h = n <= 1 ? 1 : _r(a / n, 0, 1),
          _ = l <= 1 ? 1 : _r(u / l, 0, 1),
          p = l <= 1 ? 1 : _r(c / l, 0, 1);
        r = K(r, {
          $prev_pageview_last_scroll: o,
          $prev_pageview_last_scroll_percentage: d,
          $prev_pageview_max_scroll: a,
          $prev_pageview_max_scroll_percentage: h,
          $prev_pageview_last_content: u,
          $prev_pageview_last_content_percentage: _,
          $prev_pageview_max_content: c,
          $prev_pageview_max_content_percentage: p
        });
      }
    }
    return i.pathname && (r.$prev_pageview_pathname = i.pathname), i.timestamp && (r.$prev_pageview_duration = (e.getTime() - i.timestamp.getTime()) / 1e3), r;
  }
}
var As,
  Ds,
  Ns,
  qs,
  Bs,
  Hs,
  Us,
  zs,
  js = {},
  Ws = [],
  Vs = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
  Gs = Array.isArray;
function Js(e, t) {
  for (var i in t) e[i] = t[i];
  return e;
}
function Ys(e) {
  var t = e.parentNode;
  t && t.removeChild(e);
}
function Ks(e, t, i, r, s) {
  var n = {
    type: e,
    props: t,
    key: i,
    ref: r,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    constructor: void 0,
    __v: null == s ? ++Ns : s,
    __i: -1,
    __u: 0
  };
  return null == s && null != Ds.vnode && Ds.vnode(n), n;
}
function Xs(e) {
  return e.children;
}
function Qs(e, t) {
  this.props = e, this.context = t;
}
function Zs(e, t) {
  if (null == t) return e.__ ? Zs(e.__, e.__i + 1) : null;
  for (var i; t < e.__k.length; t++) if (null != (i = e.__k[t]) && null != i.__e) return i.__e;
  return "function" == typeof e.type ? Zs(e) : null;
}
function en(e) {
  var t, i;
  if (null != (e = e.__) && null != e.__c) {
    for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++) if (null != (i = e.__k[t]) && null != i.__e) {
      e.__e = e.__c.base = i.__e;
      break;
    }
    return en(e);
  }
}
function tn(e) {
  (!e.__d && (e.__d = !0) && qs.push(e) && !rn.__r++ || Bs !== Ds.debounceRendering) && ((Bs = Ds.debounceRendering) || Hs)(rn);
}
function rn() {
  var e, t, i, r, s, n, o, a, l;
  for (qs.sort(Us); e = qs.shift();) e.__d && (t = qs.length, r = void 0, n = (s = (i = e).__v).__e, a = [], l = [], (o = i.__P) && ((r = Js({}, s)).__v = s.__v + 1, Ds.vnode && Ds.vnode(r), hn(o, r, s, i.__n, void 0 !== o.ownerSVGElement, 32 & s.__u ? [n] : null, a, null == n ? Zs(s) : n, !!(32 & s.__u), l), r.__.__k[r.__i] = r, _n(a, r, l), r.__e != n && en(r)), qs.length > t && qs.sort(Us));
  rn.__r = 0;
}
function sn(e, t, i, r, s, n, o, a, l, u, c) {
  var d,
    h,
    _,
    p,
    v,
    g = r && r.__k || Ws,
    f = t.length;
  for (i.__d = l, nn(i, t, g), l = i.__d, d = 0; d < f; d++) null != (_ = i.__k[d]) && "boolean" != typeof _ && "function" != typeof _ && (h = -1 === _.__i ? js : g[_.__i] || js, _.__i = d, hn(e, _, h, s, n, o, a, l, u, c), p = _.__e, _.ref && h.ref != _.ref && (h.ref && vn(h.ref, null, _), c.push(_.ref, _.__c || p, _)), null == v && null != p && (v = p), 65536 & _.__u || h.__k === _.__k ? l = on(_, l, e) : "function" == typeof _.type && void 0 !== _.__d ? l = _.__d : p && (l = p.nextSibling), _.__d = void 0, _.__u &= -196609);
  i.__d = l, i.__e = v;
}
function nn(e, t, i) {
  var r,
    s,
    n,
    o,
    a,
    l = t.length,
    u = i.length,
    c = u,
    d = 0;
  for (e.__k = [], r = 0; r < l; r++) null != (s = e.__k[r] = null == (s = t[r]) || "boolean" == typeof s || "function" == typeof s ? null : "string" == typeof s || "number" == typeof s || "bigint" == typeof s || s.constructor == String ? Ks(null, s, null, null, s) : Gs(s) ? Ks(Xs, {
    children: s
  }, null, null, null) : void 0 === s.constructor && s.__b > 0 ? Ks(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s) ? (s.__ = e, s.__b = e.__b + 1, a = an(s, i, o = r + d, c), s.__i = a, n = null, -1 !== a && (c--, (n = i[a]) && (n.__u |= 131072)), null == n || null === n.__v ? (-1 == a && d--, "function" != typeof s.type && (s.__u |= 65536)) : a !== o && (a === o + 1 ? d++ : a > o ? c > l - o ? d += a - o : d-- : d = a < o && a == o - 1 ? a - o : 0, a !== r + d && (s.__u |= 65536))) : (n = i[r]) && null == n.key && n.__e && (n.__e == e.__d && (e.__d = Zs(n)), gn(n, n, !1), i[r] = null, c--);
  if (c) for (r = 0; r < u; r++) null != (n = i[r]) && 0 == (131072 & n.__u) && (n.__e == e.__d && (e.__d = Zs(n)), gn(n, n));
}
function on(e, t, i) {
  var r, s;
  if ("function" == typeof e.type) {
    for (r = e.__k, s = 0; r && s < r.length; s++) r[s] && (r[s].__ = e, t = on(r[s], t, i));
    return t;
  }
  return e.__e != t && (i.insertBefore(e.__e, t || null), t = e.__e), t && t.nextSibling;
}
function an(e, t, i, r) {
  var s = e.key,
    n = e.type,
    o = i - 1,
    a = i + 1,
    l = t[i];
  if (null === l || l && s == l.key && n === l.type) return i;
  if (r > (null != l && 0 == (131072 & l.__u) ? 1 : 0)) for (; o >= 0 || a < t.length;) {
    if (o >= 0) {
      if ((l = t[o]) && 0 == (131072 & l.__u) && s == l.key && n === l.type) return o;
      o--;
    }
    if (a < t.length) {
      if ((l = t[a]) && 0 == (131072 & l.__u) && s == l.key && n === l.type) return a;
      a++;
    }
  }
  return -1;
}
function ln(e, t, i) {
  "-" === t[0] ? e.setProperty(t, null == i ? "" : i) : e[t] = null == i ? "" : "number" != typeof i || Vs.test(t) ? i : i + "px";
}
function un(e, t, i, r, s) {
  var n;
  e: if ("style" === t) {
    if ("string" == typeof i) e.style.cssText = i;else {
      if ("string" == typeof r && (e.style.cssText = r = ""), r) for (t in r) i && t in i || ln(e.style, t, "");
      if (i) for (t in i) r && i[t] === r[t] || ln(e.style, t, i[t]);
    }
  } else if ("o" === t[0] && "n" === t[1]) n = t !== (t = t.replace(/(PointerCapture)$|Capture$/, "$1")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + n] = i, i ? r ? i.u = r.u : (i.u = Date.now(), e.addEventListener(t, n ? dn : cn, n)) : e.removeEventListener(t, n ? dn : cn, n);else {
    if (s) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== t && "height" !== t && "href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && "rowSpan" !== t && "colSpan" !== t && "role" !== t && t in e) try {
      e[t] = null == i ? "" : i;
      break e;
    } catch (e) {}
    "function" == typeof i || (null == i || !1 === i && "-" !== t[4] ? e.removeAttribute(t) : e.setAttribute(t, i));
  }
}
function cn(e) {
  var t = this.l[e.type + !1];
  if (e.t) {
    if (e.t <= t.u) return;
  } else e.t = Date.now();
  return t(Ds.event ? Ds.event(e) : e);
}
function dn(e) {
  return this.l[e.type + !0](Ds.event ? Ds.event(e) : e);
}
function hn(e, t, i, r, s, n, o, a, l, u) {
  var c,
    d,
    h,
    _,
    p,
    v,
    g,
    f,
    m,
    b,
    y,
    w,
    S,
    E,
    k,
    x = t.type;
  if (void 0 !== t.constructor) return null;
  128 & i.__u && (l = !!(32 & i.__u), n = [a = t.__e = i.__e]), (c = Ds.__b) && c(t);
  e: if ("function" == typeof x) try {
    if (f = t.props, m = (c = x.contextType) && r[c.__c], b = c ? m ? m.props.value : c.__ : r, i.__c ? g = (d = t.__c = i.__c).__ = d.__E : ("prototype" in x && x.prototype.render ? t.__c = d = new x(f, b) : (t.__c = d = new Qs(f, b), d.constructor = x, d.render = fn), m && m.sub(d), d.props = f, d.state || (d.state = {}), d.context = b, d.__n = r, h = d.__d = !0, d.__h = [], d._sb = []), null == d.__s && (d.__s = d.state), null != x.getDerivedStateFromProps && (d.__s == d.state && (d.__s = Js({}, d.__s)), Js(d.__s, x.getDerivedStateFromProps(f, d.__s))), _ = d.props, p = d.state, d.__v = t, h) null == x.getDerivedStateFromProps && null != d.componentWillMount && d.componentWillMount(), null != d.componentDidMount && d.__h.push(d.componentDidMount);else {
      if (null == x.getDerivedStateFromProps && f !== _ && null != d.componentWillReceiveProps && d.componentWillReceiveProps(f, b), !d.__e && (null != d.shouldComponentUpdate && !1 === d.shouldComponentUpdate(f, d.__s, b) || t.__v === i.__v)) {
        for (t.__v !== i.__v && (d.props = f, d.state = d.__s, d.__d = !1), t.__e = i.__e, t.__k = i.__k, t.__k.forEach(function (e) {
          e && (e.__ = t);
        }), y = 0; y < d._sb.length; y++) d.__h.push(d._sb[y]);
        d._sb = [], d.__h.length && o.push(d);
        break e;
      }
      null != d.componentWillUpdate && d.componentWillUpdate(f, d.__s, b), null != d.componentDidUpdate && d.__h.push(function () {
        d.componentDidUpdate(_, p, v);
      });
    }
    if (d.context = b, d.props = f, d.__P = e, d.__e = !1, w = Ds.__r, S = 0, "prototype" in x && x.prototype.render) {
      for (d.state = d.__s, d.__d = !1, w && w(t), c = d.render(d.props, d.state, d.context), E = 0; E < d._sb.length; E++) d.__h.push(d._sb[E]);
      d._sb = [];
    } else do {
      d.__d = !1, w && w(t), c = d.render(d.props, d.state, d.context), d.state = d.__s;
    } while (d.__d && ++S < 25);
    d.state = d.__s, null != d.getChildContext && (r = Js(Js({}, r), d.getChildContext())), h || null == d.getSnapshotBeforeUpdate || (v = d.getSnapshotBeforeUpdate(_, p)), sn(e, Gs(k = null != c && c.type === Xs && null == c.key ? c.props.children : c) ? k : [k], t, i, r, s, n, o, a, l, u), d.base = t.__e, t.__u &= -161, d.__h.length && o.push(d), g && (d.__E = d.__ = null);
  } catch (e) {
    t.__v = null, l || null != n ? (t.__e = a, t.__u |= l ? 160 : 32, n[n.indexOf(a)] = null) : (t.__e = i.__e, t.__k = i.__k), Ds.__e(e, t, i);
  } else null == n && t.__v === i.__v ? (t.__k = i.__k, t.__e = i.__e) : t.__e = pn(i.__e, t, i, r, s, n, o, l, u);
  (c = Ds.diffed) && c(t);
}
function _n(e, t, i) {
  t.__d = void 0;
  for (var r = 0; r < i.length; r++) vn(i[r], i[++r], i[++r]);
  Ds.__c && Ds.__c(t, e), e.some(function (t) {
    try {
      e = t.__h, t.__h = [], e.some(function (e) {
        e.call(t);
      });
    } catch (e) {
      Ds.__e(e, t.__v);
    }
  });
}
function pn(e, t, i, r, s, n, o, a, l) {
  var u,
    c,
    d,
    h,
    _,
    p,
    v,
    g = i.props,
    f = t.props,
    m = t.type;
  if ("svg" === m && (s = !0), null != n) for (u = 0; u < n.length; u++) if ((_ = n[u]) && "setAttribute" in _ == !!m && (m ? _.localName === m : 3 === _.nodeType)) {
    e = _, n[u] = null;
    break;
  }
  if (null == e) {
    if (null === m) return document.createTextNode(f);
    e = s ? document.createElementNS("http://www.w3.org/2000/svg", m) : document.createElement(m, f.is && f), n = null, a = !1;
  }
  if (null === m) g === f || a && e.data === f || (e.data = f);else {
    if (n = n && As.call(e.childNodes), g = i.props || js, !a && null != n) for (g = {}, u = 0; u < e.attributes.length; u++) g[(_ = e.attributes[u]).name] = _.value;
    for (u in g) _ = g[u], "children" == u || ("dangerouslySetInnerHTML" == u ? d = _ : "key" === u || u in f || un(e, u, null, _, s));
    for (u in f) _ = f[u], "children" == u ? h = _ : "dangerouslySetInnerHTML" == u ? c = _ : "value" == u ? p = _ : "checked" == u ? v = _ : "key" === u || a && "function" != typeof _ || g[u] === _ || un(e, u, _, g[u], s);
    if (c) a || d && (c.__html === d.__html || c.__html === e.innerHTML) || (e.innerHTML = c.__html), t.__k = [];else if (d && (e.innerHTML = ""), sn(e, Gs(h) ? h : [h], t, i, r, s && "foreignObject" !== m, n, o, n ? n[0] : i.__k && Zs(i, 0), a, l), null != n) for (u = n.length; u--;) null != n[u] && Ys(n[u]);
    a || (u = "value", void 0 !== p && (p !== e[u] || "progress" === m && !p || "option" === m && p !== g[u]) && un(e, u, p, g[u], !1), u = "checked", void 0 !== v && v !== e[u] && un(e, u, v, g[u], !1));
  }
  return e;
}
function vn(e, t, i) {
  try {
    "function" == typeof e ? e(t) : e.current = t;
  } catch (e) {
    Ds.__e(e, i);
  }
}
function gn(e, t, i) {
  var r, s;
  if (Ds.unmount && Ds.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || vn(r, null, t)), null != (r = e.__c)) {
    if (r.componentWillUnmount) try {
      r.componentWillUnmount();
    } catch (e) {
      Ds.__e(e, t);
    }
    r.base = r.__P = null, e.__c = void 0;
  }
  if (r = e.__k) for (s = 0; s < r.length; s++) r[s] && gn(r[s], t, i || "function" != typeof e.type);
  i || null == e.__e || Ys(e.__e), e.__ = e.__e = e.__d = void 0;
}
function fn(e, t, i) {
  return this.constructor(e, i);
}
As = Ws.slice, Ds = {
  __e: function (e, t, i, r) {
    for (var s, n, o; t = t.__;) if ((s = t.__c) && !s.__) try {
      if ((n = s.constructor) && null != n.getDerivedStateFromError && (s.setState(n.getDerivedStateFromError(e)), o = s.__d), null != s.componentDidCatch && (s.componentDidCatch(e, r || {}), o = s.__d), o) return s.__E = s;
    } catch (t) {
      e = t;
    }
    throw e;
  }
}, Ns = 0, Qs.prototype.setState = function (e, t) {
  var i;
  i = null != this.__s && this.__s !== this.state ? this.__s : this.__s = Js({}, this.state), "function" == typeof e && (e = e(Js({}, i), this.props)), e && Js(i, e), null != e && this.__v && (t && this._sb.push(t), tn(this));
}, Qs.prototype.forceUpdate = function (e) {
  this.__v && (this.__e = !0, e && this.__h.push(e), tn(this));
}, Qs.prototype.render = Xs, qs = [], Hs = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Us = function (e, t) {
  return e.__v.__b - t.__v.__b;
}, rn.__r = 0, zs = 0;
var mn, bn, yn;
!function (e, t) {
  var i = {
    __c: t = "__cC" + zs++,
    __: e,
    Consumer: function (e, t) {
      return e.children(t);
    },
    Provider: function (e) {
      var i, r;
      return this.getChildContext || (i = [], (r = {})[t] = this, this.getChildContext = function () {
        return r;
      }, this.shouldComponentUpdate = function (e) {
        this.props.value !== e.value && i.some(function (e) {
          e.__e = !0, tn(e);
        });
      }, this.sub = function (e) {
        i.push(e);
        var t = e.componentWillUnmount;
        e.componentWillUnmount = function () {
          i.splice(i.indexOf(e), 1), t && t.call(e);
        };
      }), e.children;
    }
  };
  i.Provider.__ = i.Consumer.contextType = i;
}({
  isPreviewMode: !1,
  previewPageIndex: 0,
  handleCloseSurveyPopup: () => {},
  isPopup: !0,
  onPreviewSubmit: () => {}
}), function (e) {
  e.Popover = "popover", e.API = "api", e.Widget = "widget";
}(mn || (mn = {})), function (e) {
  e.Open = "open", e.MultipleChoice = "multiple_choice", e.SingleChoice = "single_choice", e.Rating = "rating", e.Link = "link";
}(bn || (bn = {})), function (e) {
  e.NextQuestion = "next_question", e.End = "end", e.ResponseBased = "response_based", e.SpecificQuestion = "specific_question";
}(yn || (yn = {}));
class wn {
  constructor() {
    W(this, "events", {}), this.events = {};
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = []), this.events[e].push(t), () => {
      this.events[e] = this.events[e].filter(e => e !== t);
    };
  }
  emit(e, t) {
    for (var i of this.events[e] || []) i(t);
    for (var r of this.events["*"] || []) r(e, t);
  }
}
class Sn {
  constructor(e) {
    W(this, "_debugEventEmitter", new wn()), W(this, "checkStep", (e, t) => this.checkStepEvent(e, t) && this.checkStepUrl(e, t) && this.checkStepElement(e, t)), W(this, "checkStepEvent", (e, t) => null == t || !t.event || (null == e ? void 0 : e.event) === (null == t ? void 0 : t.event)), this.instance = e, this.actionEvents = new Set(), this.actionRegistry = new Set();
  }
  init() {
    var e;
    if (!R(null === (e = this.instance) || void 0 === e ? void 0 : e._addCaptureHook)) {
      var t;
      null === (t = this.instance) || void 0 === t || t._addCaptureHook((e, t) => {
        this.on(e, t);
      });
    }
  }
  register(e) {
    var t, i;
    if (!R(null === (t = this.instance) || void 0 === t ? void 0 : t._addCaptureHook) && (e.forEach(e => {
      var t, i;
      null === (t = this.actionRegistry) || void 0 === t || t.add(e), null === (i = e.steps) || void 0 === i || i.forEach(e => {
        var t;
        null === (t = this.actionEvents) || void 0 === t || t.add((null == e ? void 0 : e.event) || "");
      });
    }), null !== (i = this.instance) && void 0 !== i && i.autocapture)) {
      var r,
        s = new Set();
      e.forEach(e => {
        var t;
        null === (t = e.steps) || void 0 === t || t.forEach(e => {
          null != e && e.selector && s.add(null == e ? void 0 : e.selector);
        });
      }), null === (r = this.instance) || void 0 === r || r.autocapture.setElementSelectors(s);
    }
  }
  on(e, t) {
    var i;
    null != t && 0 != e.length && (this.actionEvents.has(e) || this.actionEvents.has(null == t ? void 0 : t.event)) && this.actionRegistry && (null === (i = this.actionRegistry) || void 0 === i ? void 0 : i.size) > 0 && this.actionRegistry.forEach(e => {
      this.checkAction(t, e) && this._debugEventEmitter.emit("actionCaptured", e.name);
    });
  }
  _addActionHook(e) {
    this.onAction("actionCaptured", t => e(t));
  }
  checkAction(e, t) {
    if (null == (null == t ? void 0 : t.steps)) return !1;
    for (var i of t.steps) if (this.checkStep(e, i)) return !0;
    return !1;
  }
  onAction(e, t) {
    return this._debugEventEmitter.on(e, t);
  }
  checkStepUrl(e, t) {
    if (null != t && t.url) {
      var i,
        r = null == e || null === (i = e.properties) || void 0 === i ? void 0 : i.$current_url;
      if (!r || "string" != typeof r) return !1;
      if (!Sn.matchString(r, null == t ? void 0 : t.url, (null == t ? void 0 : t.url_matching) || "contains")) return !1;
    }
    return !0;
  }
  static matchString(e, i, r) {
    switch (r) {
      case "regex":
        return !!t && bt(e, i);
      case "exact":
        return i === e;
      case "contains":
        var s = Sn.escapeStringRegexp(i).replace(/_/g, ".").replace(/%/g, ".*");
        return bt(e, s);
      default:
        return !1;
    }
  }
  static escapeStringRegexp(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  checkStepElement(e, t) {
    if ((null != t && t.href || null != t && t.tag_name || null != t && t.text) && !this.getElementsList(e).some(e => !(null != t && t.href && !Sn.matchString(e.href || "", null == t ? void 0 : t.href, (null == t ? void 0 : t.href_matching) || "exact")) && (null == t || !t.tag_name || e.tag_name === (null == t ? void 0 : t.tag_name)) && !(null != t && t.text && !Sn.matchString(e.text || "", null == t ? void 0 : t.text, (null == t ? void 0 : t.text_matching) || "exact") && !Sn.matchString(e.$el_text || "", null == t ? void 0 : t.text, (null == t ? void 0 : t.text_matching) || "exact")))) return !1;
    if (null != t && t.selector) {
      var i,
        r = null == e || null === (i = e.properties) || void 0 === i ? void 0 : i.$element_selectors;
      if (!r) return !1;
      if (!r.includes(null == t ? void 0 : t.selector)) return !1;
    }
    return !0;
  }
  getElementsList(e) {
    return null == (null == e ? void 0 : e.properties.$elements) ? [] : null == e ? void 0 : e.properties.$elements;
  }
}
class En {
  constructor(e) {
    this.instance = e, this.eventToSurveys = new Map(), this.actionToSurveys = new Map();
  }
  register(e) {
    var t;
    R(null === (t = this.instance) || void 0 === t ? void 0 : t._addCaptureHook) || (this.setupEventBasedSurveys(e), this.setupActionBasedSurveys(e));
  }
  setupActionBasedSurveys(e) {
    var t = e.filter(e => {
      var t, i, r, s;
      return (null === (t = e.conditions) || void 0 === t ? void 0 : t.actions) && (null === (i = e.conditions) || void 0 === i || null === (r = i.actions) || void 0 === r || null === (s = r.values) || void 0 === s ? void 0 : s.length) > 0;
    });
    if (0 !== t.length) {
      if (null == this.actionMatcher) {
        this.actionMatcher = new Sn(this.instance), this.actionMatcher.init();
        this.actionMatcher._addActionHook(e => {
          this.onAction(e);
        });
      }
      t.forEach(e => {
        var t, i, r, s, n, o, a, l, u, c;
        e.conditions && null !== (t = e.conditions) && void 0 !== t && t.actions && null !== (i = e.conditions) && void 0 !== i && null !== (r = i.actions) && void 0 !== r && r.values && (null === (s = e.conditions) || void 0 === s || null === (n = s.actions) || void 0 === n || null === (o = n.values) || void 0 === o ? void 0 : o.length) > 0 && (null === (a = this.actionMatcher) || void 0 === a || a.register(e.conditions.actions.values), null === (l = e.conditions) || void 0 === l || null === (u = l.actions) || void 0 === u || null === (c = u.values) || void 0 === c || c.forEach(t => {
          if (t && t.name) {
            var i = this.actionToSurveys.get(t.name);
            i && i.push(e.id), this.actionToSurveys.set(t.name, i || [e.id]);
          }
        }));
      });
    }
  }
  setupEventBasedSurveys(e) {
    var t;
    if (0 !== e.filter(e => {
      var t, i, r, s;
      return (null === (t = e.conditions) || void 0 === t ? void 0 : t.events) && (null === (i = e.conditions) || void 0 === i || null === (r = i.events) || void 0 === r || null === (s = r.values) || void 0 === s ? void 0 : s.length) > 0;
    }).length) {
      null === (t = this.instance) || void 0 === t || t._addCaptureHook((e, t) => {
        this.onEvent(e, t);
      }), e.forEach(e => {
        var t, i, r;
        null === (t = e.conditions) || void 0 === t || null === (i = t.events) || void 0 === i || null === (r = i.values) || void 0 === r || r.forEach(t => {
          if (t && t.name) {
            var i = this.eventToSurveys.get(t.name);
            i && i.push(e.id), this.eventToSurveys.set(t.name, i || [e.id]);
          }
        });
      });
    }
  }
  onEvent(e, t) {
    var i,
      r,
      s = (null === (i = this.instance) || void 0 === i || null === (r = i.persistence) || void 0 === r ? void 0 : r.props[$e]) || [];
    if (En.SURVEY_SHOWN_EVENT_NAME == e && t && s.length > 0) {
      var n,
        o = null == t || null === (n = t.properties) || void 0 === n ? void 0 : n.$survey_id;
      if (o) {
        var a = s.indexOf(o);
        a >= 0 && (s.splice(a, 1), this._updateActivatedSurveys(s));
      }
    } else this.eventToSurveys.has(e) && this._updateActivatedSurveys(s.concat(this.eventToSurveys.get(e) || []));
  }
  onAction(e) {
    var t,
      i,
      r = (null === (t = this.instance) || void 0 === t || null === (i = t.persistence) || void 0 === i ? void 0 : i.props[$e]) || [];
    this.actionToSurveys.has(e) && this._updateActivatedSurveys(r.concat(this.actionToSurveys.get(e) || []));
  }
  _updateActivatedSurveys(e) {
    var t, i;
    null === (t = this.instance) || void 0 === t || null === (i = t.persistence) || void 0 === i || i.register({
      [$e]: [...new Set(e)]
    });
  }
  getSurveys() {
    var e,
      t,
      i = null === (e = this.instance) || void 0 === e || null === (t = e.persistence) || void 0 === t ? void 0 : t.props[$e];
    return i || [];
  }
  getEventToSurveys() {
    return this.eventToSurveys;
  }
  _getActionMatcher() {
    return this.actionMatcher;
  }
}
W(En, "SURVEY_SHOWN_EVENT_NAME", "survey shown");
var kn = B("[Surveys]"),
  xn = {
    icontains: e => !!t && t.location.href.toLowerCase().indexOf(e.toLowerCase()) > -1,
    not_icontains: e => !!t && -1 === t.location.href.toLowerCase().indexOf(e.toLowerCase()),
    regex: e => !!t && bt(t.location.href, e),
    not_regex: e => !!t && !bt(t.location.href, e),
    exact: e => (null == t ? void 0 : t.location.href) === e,
    is_not: e => (null == t ? void 0 : t.location.href) !== e
  };
function In(e, t, i) {
  var r,
    s = e.questions[t],
    n = t + 1;
  if (null === (r = s.branching) || void 0 === r || !r.type) return t === e.questions.length - 1 ? yn.End : n;
  if (s.branching.type === yn.End) return yn.End;
  if (s.branching.type === yn.SpecificQuestion) {
    if (Number.isInteger(s.branching.index)) return s.branching.index;
  } else if (s.branching.type === yn.ResponseBased) {
    if (s.type === bn.SingleChoice) {
      var o,
        a,
        l = s.choices.indexOf("".concat(i));
      if (null !== (o = s.branching) && void 0 !== o && null !== (a = o.responseValues) && void 0 !== a && a.hasOwnProperty(l)) {
        var u = s.branching.responseValues[l];
        return Number.isInteger(u) ? u : u === yn.End ? yn.End : n;
      }
    } else if (s.type === bn.Rating) {
      var c, d;
      if ("number" != typeof i || !Number.isInteger(i)) throw new Error("The response type must be an integer");
      var h = function (e, t) {
        if (3 === t) {
          if (e < 1 || e > 3) throw new Error("The response must be in range 1-3");
          return 1 === e ? "negative" : 2 === e ? "neutral" : "positive";
        }
        if (5 === t) {
          if (e < 1 || e > 5) throw new Error("The response must be in range 1-5");
          return e <= 2 ? "negative" : 3 === e ? "neutral" : "positive";
        }
        if (7 === t) {
          if (e < 1 || e > 7) throw new Error("The response must be in range 1-7");
          return e <= 3 ? "negative" : 4 === e ? "neutral" : "positive";
        }
        if (10 === t) {
          if (e < 0 || e > 10) throw new Error("The response must be in range 0-10");
          return e <= 6 ? "detractors" : e <= 8 ? "passives" : "promoters";
        }
        throw new Error("The scale must be one of: 3, 5, 7, 10");
      }(i, s.scale);
      if (null !== (c = s.branching) && void 0 !== c && null !== (d = c.responseValues) && void 0 !== d && d.hasOwnProperty(h)) {
        var _ = s.branching.responseValues[h];
        return Number.isInteger(_) ? _ : _ === yn.End ? yn.End : n;
      }
    }
    return n;
  }
  return kn.warn("Falling back to next question index due to unexpected branching type"), n;
}
class Cn {
  constructor(e) {
    W(this, "getNextSurveyStep", In), this.instance = e, this._surveyEventReceiver = null;
  }
  onRemoteConfig(e) {
    this._decideServerResponse = !!e.surveys, kn.info("decideServerResponse set to ".concat(this._decideServerResponse)), this.loadIfEnabled();
  }
  reset() {
    localStorage.removeItem("lastSeenSurveyDate");
    var e = (() => {
      for (var e = [], t = 0; t < localStorage.length; t++) {
        var i = localStorage.key(t);
        null != i && i.startsWith("seenSurvey_") && e.push(i);
      }
      return e;
    })();
    e.forEach(e => localStorage.removeItem(e));
  }
  loadIfEnabled() {
    if (!this._surveyManager) if (this.instance.config.disable_surveys) kn.info("Disabled. Not loading surveys.");else {
      var e = null == _ ? void 0 : _.__PosthogExtensions__;
      if (e) {
        var t = e.generateSurveys;
        if (this._decideServerResponse) {
          if (null == this._surveyEventReceiver && (this._surveyEventReceiver = new En(this.instance)), t) this._surveyManager = t(this.instance);else {
            var i = e.loadExternalDependency;
            i ? i(this.instance, "surveys", t => {
              var i;
              t ? kn.error("Could not load surveys script", t) : this._surveyManager = null === (i = e.generateSurveys) || void 0 === i ? void 0 : i.call(e, this.instance);
            }) : kn.error("PostHog loadExternalDependency extension not found. Cannot load remote config.");
          }
        } else kn.warn("Decide not loaded yet. Not loading surveys.");
      } else kn.error("PostHog Extensions not found.");
    }
  }
  getSurveys(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (this.instance.config.disable_surveys) return kn.info("Disabled. Not loading surveys."), e([]);
    null == this._surveyEventReceiver && (this._surveyEventReceiver = new En(this.instance));
    var i = this.instance.get_property(Te);
    if (i && !t) return kn.info("Surveys already loaded, using existing data."), e(i);
    this.instance._send_request({
      url: this.instance.requestRouter.endpointFor("api", "/api/surveys/?token=".concat(this.instance.config.token)),
      method: "GET",
      callback: t => {
        var i,
          r = t.statusCode;
        if (200 !== r || !t.json) return kn.error("Surveys API could not be loaded, status: ".concat(r)), e([]);
        var s,
          n = t.json.surveys || [],
          o = n.filter(e => {
            var t, i, r, s, n, o, a, l, u, c, d, h;
            return (null === (t = e.conditions) || void 0 === t ? void 0 : t.events) && (null === (i = e.conditions) || void 0 === i || null === (r = i.events) || void 0 === r ? void 0 : r.values) && (null === (s = e.conditions) || void 0 === s || null === (n = s.events) || void 0 === n || null === (o = n.values) || void 0 === o ? void 0 : o.length) > 0 || (null === (a = e.conditions) || void 0 === a ? void 0 : a.actions) && (null === (l = e.conditions) || void 0 === l || null === (u = l.actions) || void 0 === u ? void 0 : u.values) && (null === (c = e.conditions) || void 0 === c || null === (d = c.actions) || void 0 === d || null === (h = d.values) || void 0 === h ? void 0 : h.length) > 0;
          });
        o.length > 0 && (null === (s = this._surveyEventReceiver) || void 0 === s || s.register(o));
        return null === (i = this.instance.persistence) || void 0 === i || i.register({
          [Te]: n
        }), e(n);
      }
    });
  }
  getActiveMatchingSurveys(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.getSurveys(t => {
      var i,
        r = t.filter(e => !(!e.start_date || e.end_date)).filter(e => {
          var t, i, r, s;
          if (!e.conditions) return !0;
          var n = null === (t = e.conditions) || void 0 === t || !t.url || xn[null !== (i = null === (r = e.conditions) || void 0 === r ? void 0 : r.urlMatchType) && void 0 !== i ? i : "icontains"](e.conditions.url),
            o = null === (s = e.conditions) || void 0 === s || !s.selector || (null == a ? void 0 : a.querySelector(e.conditions.selector));
          return n && o;
        }),
        s = null === (i = this._surveyEventReceiver) || void 0 === i ? void 0 : i.getSurveys(),
        n = r.filter(e => {
          var t, i, r, n, o, a, l, u, c, d, h;
          if (!(e.linked_flag_key || e.targeting_flag_key || e.internal_targeting_flag_key || null !== (t = e.feature_flag_keys) && void 0 !== t && t.length)) return !0;
          var _ = !e.linked_flag_key || this.instance.featureFlags.isFeatureEnabled(e.linked_flag_key),
            p = !e.targeting_flag_key || this.instance.featureFlags.isFeatureEnabled(e.targeting_flag_key),
            v = (null === (i = e.conditions) || void 0 === i ? void 0 : i.events) && (null === (r = e.conditions) || void 0 === r || null === (n = r.events) || void 0 === n ? void 0 : n.values) && (null === (o = e.conditions) || void 0 === o || null === (a = o.events) || void 0 === a ? void 0 : a.values.length) > 0,
            g = (null === (l = e.conditions) || void 0 === l ? void 0 : l.actions) && (null === (u = e.conditions) || void 0 === u || null === (c = u.actions) || void 0 === c ? void 0 : c.values) && (null === (d = e.conditions) || void 0 === d || null === (h = d.actions) || void 0 === h ? void 0 : h.values.length) > 0,
            f = !v && !g || (null == s ? void 0 : s.includes(e.id)),
            m = this._canActivateRepeatedly(e),
            b = !(e.internal_targeting_flag_key && !m) || this.instance.featureFlags.isFeatureEnabled(e.internal_targeting_flag_key),
            y = this.checkFlags(e);
          return _ && p && b && f && y;
        });
      return e(n);
    }, t);
  }
  checkFlags(e) {
    var t;
    return null === (t = e.feature_flag_keys) || void 0 === t || !t.length || e.feature_flag_keys.every(e => {
      var {
        key: t,
        value: i
      } = e;
      return !t || !i || this.instance.featureFlags.isFeatureEnabled(i);
    });
  }
  _canActivateRepeatedly(e) {
    var t;
    return O(null === (t = _.__PosthogExtensions__) || void 0 === t ? void 0 : t.canActivateRepeatedly) ? (kn.warn("init was not called"), !1) : _.__PosthogExtensions__.canActivateRepeatedly(e);
  }
  canRenderSurvey(e) {
    O(this._surveyManager) ? kn.warn("init was not called") : this.getSurveys(t => {
      var i = t.filter(t => t.id === e)[0];
      this._surveyManager.canRenderSurvey(i);
    });
  }
  renderSurvey(e, t) {
    O(this._surveyManager) ? kn.warn("init was not called") : this.getSurveys(i => {
      var r = i.filter(t => t.id === e)[0];
      this._surveyManager.renderSurvey(r, null == a ? void 0 : a.querySelector(t));
    });
  }
}
var Pn = B("[RateLimiter]");
class Rn {
  constructor(e) {
    var t, i;
    W(this, "serverLimits", {}), W(this, "lastEventRateLimited", !1), W(this, "checkForLimiting", e => {
      var t = e.text;
      if (t && t.length) try {
        (JSON.parse(t).quota_limited || []).forEach(e => {
          Pn.info("".concat(e || "events", " is quota limited.")), this.serverLimits[e] = new Date().getTime() + 6e4;
        });
      } catch (e) {
        return void Pn.warn('could not rate limit - continuing. Error: "'.concat(null == e ? void 0 : e.message, '"'), {
          text: t
        });
      }
    }), this.instance = e, this.captureEventsPerSecond = (null === (t = e.config.rate_limiting) || void 0 === t ? void 0 : t.events_per_second) || 10, this.captureEventsBurstLimit = Math.max((null === (i = e.config.rate_limiting) || void 0 === i ? void 0 : i.events_burst_limit) || 10 * this.captureEventsPerSecond, this.captureEventsPerSecond), this.lastEventRateLimited = this.clientRateLimitContext(!0).isRateLimited;
  }
  clientRateLimitContext() {
    var e,
      t,
      i,
      r = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
      s = new Date().getTime(),
      n = null !== (e = null === (t = this.instance.persistence) || void 0 === t ? void 0 : t.get_property(Ae)) && void 0 !== e ? e : {
        tokens: this.captureEventsBurstLimit,
        last: s
      };
    n.tokens += (s - n.last) / 1e3 * this.captureEventsPerSecond, n.last = s, n.tokens > this.captureEventsBurstLimit && (n.tokens = this.captureEventsBurstLimit);
    var o = n.tokens < 1;
    return o || r || (n.tokens = Math.max(0, n.tokens - 1)), !o || this.lastEventRateLimited || r || this.instance.capture("$$client_ingestion_warning", {
      $$client_ingestion_warning_message: "posthog-js client rate limited. Config is set to ".concat(this.captureEventsPerSecond, " events per second and ").concat(this.captureEventsBurstLimit, " events burst limit.")
    }, {
      skip_client_rate_limiting: !0
    }), this.lastEventRateLimited = o, null === (i = this.instance.persistence) || void 0 === i || i.set_property(Ae, n), {
      isRateLimited: o,
      remainingTokens: n.tokens
    };
  }
  isServerRateLimited(e) {
    var t = this.serverLimits[e || "events"] || !1;
    return !1 !== t && new Date().getTime() < t;
  }
}
var Fn = e => {
  var t = null == e ? void 0 : e.config;
  return j({
    initialPathName: (null == l ? void 0 : l.pathname) || "",
    referringDomain: Ei.referringDomain()
  }, Ei.campaignParams({
    customTrackedParams: null == t ? void 0 : t.custom_campaign_params,
    maskPersonalDataProperties: null == t ? void 0 : t.mask_personal_data_properties,
    customPersonalDataProperties: null == t ? void 0 : t.custom_personal_data_properties
  }));
};
class Tn {
  constructor(e, t, i, r) {
    W(this, "_onSessionIdCallback", e => {
      var t = this._getStoredProps();
      if (!t || t.sessionId !== e) {
        var i = {
          sessionId: e,
          props: this._sessionSourceParamGenerator(this.instance)
        };
        this._persistence.register({
          [Le]: i
        });
      }
    }), this.instance = e, this._sessionIdManager = t, this._persistence = i, this._sessionSourceParamGenerator = r || Fn, this._sessionIdManager.onSessionId(this._onSessionIdCallback);
  }
  _getStoredProps() {
    return this._persistence.props[Le];
  }
  getSessionProps() {
    var e,
      t = null === (e = this._getStoredProps()) || void 0 === e ? void 0 : e.props;
    return t ? {
      $client_session_initial_referring_host: t.referringDomain,
      $client_session_initial_pathname: t.initialPathName,
      $client_session_initial_utm_source: t.utm_source,
      $client_session_initial_utm_campaign: t.utm_campaign,
      $client_session_initial_utm_medium: t.utm_medium,
      $client_session_initial_utm_content: t.utm_content,
      $client_session_initial_utm_term: t.utm_term
    } : {};
  }
}
var $n = ["ahrefsbot", "ahrefssiteaudit", "applebot", "baiduspider", "better uptime bot", "bingbot", "bingpreview", "bot.htm", "bot.php", "crawler", "deepscan", "duckduckbot", "facebookexternal", "facebookcatalog", "http://yandex.com/bots", "hubspot", "ia_archiver", "linkedinbot", "mj12bot", "msnbot", "nessus", "petalbot", "pinterest", "prerender", "rogerbot", "screaming frog", "semrushbot", "sitebulb", "slurp", "turnitin", "twitterbot", "vercelbot", "yahoo! slurp", "yandexbot", "gptbot", "oai-searchbot", "chatgpt-user", "headlesschrome", "cypress", "Google-HotelAdsVerifier", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google", "Bytespider;"],
  On = function (e, t) {
    if (!e) return !1;
    var i = e.toLowerCase();
    return $n.concat(t || []).some(e => {
      var t = e.toLowerCase();
      return -1 !== i.indexOf(t);
    });
  },
  Mn = function (e, t) {
    if (!e) return !1;
    var i = e.userAgent;
    if (i && On(i, t)) return !0;
    try {
      var r = null == e ? void 0 : e.userAgentData;
      if (null != r && r.brands && r.brands.some(e => On(null == e ? void 0 : e.brand, t))) return !0;
    } catch (e) {}
    return !!e.webdriver;
  };
class Ln {
  constructor() {
    this.clicks = [];
  }
  isRageClick(e, t, i) {
    var r = this.clicks[this.clicks.length - 1];
    if (r && Math.abs(e - r.x) + Math.abs(t - r.y) < 30 && i - r.timestamp < 1e3) {
      if (this.clicks.push({
        x: e,
        y: t,
        timestamp: i
      }), 3 === this.clicks.length) return !0;
    } else this.clicks = [{
      x: e,
      y: t,
      timestamp: i
    }];
    return !1;
  }
}
var An = B("[Dead Clicks]"),
  Dn = () => !0,
  Nn = e => {
    var t,
      i = !(null === (t = e.instance.persistence) || void 0 === t || !t.get_property(pe)),
      r = e.instance.config.capture_dead_clicks;
    return L(r) ? r : i;
  };
class qn {
  get lazyLoadedDeadClicksAutocapture() {
    return this._lazyLoadedDeadClicksAutocapture;
  }
  constructor(e, t, i) {
    this.instance = e, this.isEnabled = t, this.onCapture = i, this.startIfEnabled();
  }
  onRemoteConfig(e) {
    this.instance.persistence && this.instance.persistence.register({
      [pe]: null == e ? void 0 : e.captureDeadClicks
    }), this.startIfEnabled();
  }
  startIfEnabled() {
    this.isEnabled(this) && this.loadScript(() => {
      this.start();
    });
  }
  loadScript(e) {
    var t, i, r;
    null !== (t = _.__PosthogExtensions__) && void 0 !== t && t.initDeadClicksAutocapture && e(), null === (i = _.__PosthogExtensions__) || void 0 === i || null === (r = i.loadExternalDependency) || void 0 === r || r.call(i, this.instance, "dead-clicks-autocapture", t => {
      t ? An.error("failed to load script", t) : e();
    });
  }
  start() {
    var e;
    if (a) {
      if (!this._lazyLoadedDeadClicksAutocapture && null !== (e = _.__PosthogExtensions__) && void 0 !== e && e.initDeadClicksAutocapture) {
        var t = C(this.instance.config.capture_dead_clicks) ? this.instance.config.capture_dead_clicks : {};
        t.__onCapture = this.onCapture, this._lazyLoadedDeadClicksAutocapture = _.__PosthogExtensions__.initDeadClicksAutocapture(this.instance, t), this._lazyLoadedDeadClicksAutocapture.start(a), An.info("starting...");
      }
    } else An.error("`document` not found. Cannot start.");
  }
  stop() {
    this._lazyLoadedDeadClicksAutocapture && (this._lazyLoadedDeadClicksAutocapture.stop(), this._lazyLoadedDeadClicksAutocapture = void 0, An.info("stopping..."));
  }
}
var Bn = B("[Heatmaps]");
function Hn(e) {
  return C(e) && "clientX" in e && "clientY" in e && M(e.clientX) && M(e.clientY);
}
class Un {
  constructor(e) {
    var i;
    W(this, "rageclicks", new Ln()), W(this, "_enabledServerSide", !1), W(this, "_initialized", !1), W(this, "_flushInterval", null), this.instance = e, this._enabledServerSide = !(null === (i = this.instance.persistence) || void 0 === i || !i.props[de]), null == t || t.addEventListener("beforeunload", () => {
      this.flush();
    });
  }
  get flushIntervalMilliseconds() {
    var e = 5e3;
    return C(this.instance.config.capture_heatmaps) && this.instance.config.capture_heatmaps.flush_interval_milliseconds && (e = this.instance.config.capture_heatmaps.flush_interval_milliseconds), e;
  }
  get isEnabled() {
    return R(this.instance.config.capture_heatmaps) ? R(this.instance.config.enable_heatmaps) ? this._enabledServerSide : this.instance.config.enable_heatmaps : !1 !== this.instance.config.capture_heatmaps;
  }
  startIfEnabled() {
    if (this.isEnabled) {
      if (this._initialized) return;
      Bn.info("starting..."), this._setupListeners(), this._flushInterval = setInterval(this.flush.bind(this), this.flushIntervalMilliseconds);
    } else {
      var e, t;
      clearInterval(null !== (e = this._flushInterval) && void 0 !== e ? e : void 0), null === (t = this.deadClicksCapture) || void 0 === t || t.stop(), this.getAndClearBuffer();
    }
  }
  onRemoteConfig(e) {
    var t = !!e.heatmaps;
    this.instance.persistence && this.instance.persistence.register({
      [de]: t
    }), this._enabledServerSide = t, this.startIfEnabled();
  }
  getAndClearBuffer() {
    var e = this.buffer;
    return this.buffer = void 0, e;
  }
  _onDeadClick(e) {
    this._onClick(e.originalEvent, "deadclick");
  }
  _setupListeners() {
    t && a && (re(a, "click", e => this._onClick(e || (null == t ? void 0 : t.event)), !1, !0), re(a, "mousemove", e => this._onMouseMove(e || (null == t ? void 0 : t.event)), !1, !0), this.deadClicksCapture = new qn(this.instance, Dn, this._onDeadClick.bind(this)), this.deadClicksCapture.startIfEnabled(), this._initialized = !0);
  }
  _getProperties(e, i) {
    var r = this.instance.scrollManager.scrollY(),
      s = this.instance.scrollManager.scrollX(),
      n = this.instance.scrollManager.scrollElement(),
      o = function (e, i, r) {
        for (var s = e; s && Ti(s) && !$i(s, "body");) {
          if (s === r) return !1;
          if (m(i, null == t ? void 0 : t.getComputedStyle(s).position)) return !0;
          s = Ui(s);
        }
        return !1;
      }(Bi(e), ["fixed", "sticky"], n);
    return {
      x: e.clientX + (o ? 0 : s),
      y: e.clientY + (o ? 0 : r),
      target_fixed: o,
      type: i
    };
  }
  _onClick(e) {
    var t,
      i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "click";
    if (!Fi(e.target) && Hn(e)) {
      var r = this._getProperties(e, i);
      null !== (t = this.rageclicks) && void 0 !== t && t.isRageClick(e.clientX, e.clientY, new Date().getTime()) && this._capture(j(j({}, r), {}, {
        type: "rageclick"
      })), this._capture(r);
    }
  }
  _onMouseMove(e) {
    !Fi(e.target) && Hn(e) && (clearTimeout(this._mouseMoveTimeout), this._mouseMoveTimeout = setTimeout(() => {
      this._capture(this._getProperties(e, "mousemove"));
    }, 500));
  }
  _capture(e) {
    if (t) {
      var i = t.location.href;
      this.buffer = this.buffer || {}, this.buffer[i] || (this.buffer[i] = []), this.buffer[i].push(e);
    }
  }
  flush() {
    this.buffer && !P(this.buffer) && this.instance.capture("$$heatmap", {
      $heatmap_data: this.getAndClearBuffer()
    });
  }
}
class zn {
  constructor(e) {
    W(this, "_updateScrollData", () => {
      var e, t, i, r;
      this.context || (this.context = {});
      var s = this.scrollElement(),
        n = this.scrollY(),
        o = s ? Math.max(0, s.scrollHeight - s.clientHeight) : 0,
        a = n + ((null == s ? void 0 : s.clientHeight) || 0),
        l = (null == s ? void 0 : s.scrollHeight) || 0;
      this.context.lastScrollY = Math.ceil(n), this.context.maxScrollY = Math.max(n, null !== (e = this.context.maxScrollY) && void 0 !== e ? e : 0), this.context.maxScrollHeight = Math.max(o, null !== (t = this.context.maxScrollHeight) && void 0 !== t ? t : 0), this.context.lastContentY = a, this.context.maxContentY = Math.max(a, null !== (i = this.context.maxContentY) && void 0 !== i ? i : 0), this.context.maxContentHeight = Math.max(l, null !== (r = this.context.maxContentHeight) && void 0 !== r ? r : 0);
    }), this.instance = e;
  }
  getContext() {
    return this.context;
  }
  resetContext() {
    var e = this.context;
    return setTimeout(this._updateScrollData, 0), e;
  }
  startMeasuringScrollPosition() {
    null == t || t.addEventListener("scroll", this._updateScrollData, {
      capture: !0,
      passive: !0
    }), null == t || t.addEventListener("scrollend", this._updateScrollData, {
      capture: !0,
      passive: !0
    }), null == t || t.addEventListener("resize", this._updateScrollData, {
      passive: !0
    });
  }
  scrollElement() {
    if (!this.instance.config.scroll_root_selector) return null == t ? void 0 : t.document.documentElement;
    var e = x(this.instance.config.scroll_root_selector) ? this.instance.config.scroll_root_selector : [this.instance.config.scroll_root_selector];
    for (var i of e) {
      var r = null == t ? void 0 : t.document.querySelector(i);
      if (r) return r;
    }
  }
  scrollY() {
    if (this.instance.config.scroll_root_selector) {
      var e = this.scrollElement();
      return e && e.scrollTop || 0;
    }
    return t && (t.scrollY || t.pageYOffset || t.document.documentElement.scrollTop) || 0;
  }
  scrollX() {
    if (this.instance.config.scroll_root_selector) {
      var e = this.scrollElement();
      return e && e.scrollLeft || 0;
    }
    return t && (t.scrollX || t.pageXOffset || t.document.documentElement.scrollLeft) || 0;
  }
}
var jn = B("[AutoCapture]");
function Wn(e, t) {
  return t.length > e ? t.slice(0, e) + "..." : t;
}
function Vn(e) {
  if (e.previousElementSibling) return e.previousElementSibling;
  var t = e;
  do {
    t = t.previousSibling;
  } while (t && !Ti(t));
  return t;
}
function Gn(e, t, i, r) {
  var s = e.tagName.toLowerCase(),
    n = {
      tag_name: s
    };
  Hi.indexOf(s) > -1 && !i && ("a" === s.toLowerCase() || "button" === s.toLowerCase() ? n.$el_text = Wn(1024, Zi(e)) : n.$el_text = Wn(1024, qi(e)));
  var o = Di(e);
  o.length > 0 && (n.classes = o.filter(function (e) {
    return "" !== e;
  })), Y(e.attributes, function (i) {
    var s;
    if ((!Wi(e) || -1 !== ["name", "id", "class", "aria-label"].indexOf(i.name)) && (null == r || !r.includes(i.name)) && !t && Qi(i.value) && (s = i.name, !F(s) || "_ngcontent" !== s.substring(0, 10) && "_nghost" !== s.substring(0, 7))) {
      var o = i.value;
      "class" === i.name && (o = Li(o).join(" ")), n["attr__" + i.name] = Wn(1024, o);
    }
  });
  for (var a = 1, l = 1, u = e; u = Vn(u);) a++, u.tagName === e.tagName && l++;
  return n.nth_child = a, n.nth_of_type = l, n;
}
function Jn(e, i) {
  for (var r, s, {
      e: n,
      maskAllElementAttributes: o,
      maskAllText: a,
      elementAttributeIgnoreList: l,
      elementsChainAsString: u
    } = i, c = [e], d = e; d.parentNode && !$i(d, "body");) Mi(d.parentNode) ? (c.push(d.parentNode.host), d = d.parentNode.host) : (c.push(d.parentNode), d = d.parentNode);
  var h,
    _ = [],
    p = {},
    v = !1,
    g = !1;
  if (Y(c, e => {
    var t = ji(e);
    "a" === e.tagName.toLowerCase() && (v = e.getAttribute("href"), v = t && v && Qi(v) && v), m(Di(e), "ph-no-capture") && (g = !0), _.push(Gn(e, o, a, l));
    var i = function (e) {
      if (!ji(e)) return {};
      var t = {};
      return Y(e.attributes, function (e) {
        if (e.name && 0 === e.name.indexOf("data-ph-capture-attribute")) {
          var i = e.name.replace("data-ph-capture-attribute-", ""),
            r = e.value;
          i && r && Qi(r) && (t[i] = r);
        }
      }), t;
    }(e);
    K(p, i);
  }), g) return {
    props: {},
    explicitNoCapture: g
  };
  if (a || ("a" === e.tagName.toLowerCase() || "button" === e.tagName.toLowerCase() ? _[0].$el_text = Zi(e) : _[0].$el_text = qi(e)), v) {
    var f, b;
    _[0].attr__href = v;
    var y = null === (f = mt(v)) || void 0 === f ? void 0 : f.host,
      w = null == t || null === (b = t.location) || void 0 === b ? void 0 : b.host;
    y && w && y !== w && (h = v);
  }
  return {
    props: K({
      $event_type: n.type,
      $ce_version: 1
    }, u ? {} : {
      $elements: _
    }, {
      $elements_chain: tr(_)
    }, null !== (r = _[0]) && void 0 !== r && r.$el_text ? {
      $el_text: null === (s = _[0]) || void 0 === s ? void 0 : s.$el_text
    } : {}, h && "click" === n.type ? {
      $external_click_url: h
    } : {}, p)
  };
}
class Yn {
  constructor(e) {
    W(this, "_initialized", !1), W(this, "_isDisabledServerSide", null), W(this, "rageclicks", new Ln()), W(this, "_elementsChainAsString", !1), this.instance = e, this._elementSelectors = null;
  }
  get config() {
    var e,
      t,
      i = C(this.instance.config.autocapture) ? this.instance.config.autocapture : {};
    return i.url_allowlist = null === (e = i.url_allowlist) || void 0 === e ? void 0 : e.map(e => new RegExp(e)), i.url_ignorelist = null === (t = i.url_ignorelist) || void 0 === t ? void 0 : t.map(e => new RegExp(e)), i;
  }
  _addDomEventHandlers() {
    if (this.isBrowserSupported()) {
      if (t && a) {
        var e = e => {
            e = e || (null == t ? void 0 : t.event);
            try {
              this._captureEvent(e);
            } catch (e) {
              jn.error("Failed to capture event", e);
            }
          },
          i = e => {
            e = e || (null == t ? void 0 : t.event), this._captureEvent(e, v);
          };
        re(a, "submit", e, !1, !0), re(a, "change", e, !1, !0), re(a, "click", e, !1, !0), this.config.capture_copied_text && (re(a, "copy", i, !1, !0), re(a, "cut", i, !1, !0));
      }
    } else jn.info("Disabling Automatic Event Collection because this browser is not supported");
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (this._addDomEventHandlers(), this._initialized = !0);
  }
  onRemoteConfig(e) {
    e.elementsChainAsString && (this._elementsChainAsString = e.elementsChainAsString), this.instance.persistence && this.instance.persistence.register({
      [ce]: !!e.autocapture_opt_out
    }), this._isDisabledServerSide = !!e.autocapture_opt_out, this.startIfEnabled();
  }
  setElementSelectors(e) {
    this._elementSelectors = e;
  }
  getElementSelectors(e) {
    var t,
      i = [];
    return null === (t = this._elementSelectors) || void 0 === t || t.forEach(t => {
      var r = null == a ? void 0 : a.querySelectorAll(t);
      null == r || r.forEach(r => {
        e === r && i.push(t);
      });
    }), i;
  }
  get isEnabled() {
    var e,
      t,
      i = null === (e = this.instance.persistence) || void 0 === e ? void 0 : e.props[ce],
      r = this._isDisabledServerSide;
    if ($(r) && !L(i) && !this.instance.config.advanced_disable_decide) return !1;
    var s = null !== (t = this._isDisabledServerSide) && void 0 !== t ? t : !!i;
    return !!this.instance.config.autocapture && !s;
  }
  _captureEvent(e) {
    var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "$autocapture";
    if (this.isEnabled) {
      var r,
        s = Bi(e);
      if (Oi(s) && (s = s.parentNode || null), "$autocapture" === i && "click" === e.type && e instanceof MouseEvent) this.instance.config.rageclick && null !== (r = this.rageclicks) && void 0 !== r && r.isRageClick(e.clientX, e.clientY, new Date().getTime()) && this._captureEvent(e, "$rageclick");
      var n = i === v;
      if (s && zi(s, e, this.config, n, n ? ["copy", "cut"] : void 0)) {
        var {
          props: o,
          explicitNoCapture: a
        } = Jn(s, {
          e: e,
          maskAllElementAttributes: this.instance.config.mask_all_element_attributes,
          maskAllText: this.instance.config.mask_all_text,
          elementAttributeIgnoreList: this.config.element_attribute_ignorelist,
          elementsChainAsString: this._elementsChainAsString
        });
        if (a) return !1;
        var l = this.getElementSelectors(s);
        if (l && l.length > 0 && (o.$element_selectors = l), i === v) {
          var u,
            c = Ni(null == t || null === (u = t.getSelection()) || void 0 === u ? void 0 : u.toString()),
            d = e.type || "clipboard";
          if (!c) return !1;
          o.$selected_content = c, o.$copy_type = d;
        }
        return this.instance.capture(i, o), !0;
      }
    }
  }
  isBrowserSupported() {
    return I(null == a ? void 0 : a.querySelectorAll);
  }
}
var Kn = B("[TracingHeaders]");
class Xn {
  constructor(e) {
    W(this, "_restoreXHRPatch", void 0), W(this, "_restoreFetchPatch", void 0), W(this, "_startCapturing", () => {
      var e, t, i, r;
      R(this._restoreXHRPatch) && (null === (e = _.__PosthogExtensions__) || void 0 === e || null === (t = e.tracingHeadersPatchFns) || void 0 === t || t._patchXHR(this.instance.sessionManager));
      R(this._restoreFetchPatch) && (null === (i = _.__PosthogExtensions__) || void 0 === i || null === (r = i.tracingHeadersPatchFns) || void 0 === r || r._patchFetch(this.instance.sessionManager));
    }), this.instance = e;
  }
  _loadScript(e) {
    var t, i, r;
    null !== (t = _.__PosthogExtensions__) && void 0 !== t && t.tracingHeadersPatchFns && e(), null === (i = _.__PosthogExtensions__) || void 0 === i || null === (r = i.loadExternalDependency) || void 0 === r || r.call(i, this.instance, "tracing-headers", t => {
      if (t) return Kn.error("failed to load script", t);
      e();
    });
  }
  startIfEnabledOrStop() {
    var e, t;
    this.instance.config.__add_tracing_headers ? this._loadScript(this._startCapturing) : (null === (e = this._restoreXHRPatch) || void 0 === e || e.call(this), null === (t = this._restoreFetchPatch) || void 0 === t || t.call(this), this._restoreXHRPatch = void 0, this._restoreFetchPatch = void 0);
  }
}
var Qn;
!function (e) {
  e[e.PENDING = -1] = "PENDING", e[e.DENIED = 0] = "DENIED", e[e.GRANTED = 1] = "GRANTED";
}(Qn || (Qn = {}));
class Zn {
  constructor(e) {
    this.instance = e;
  }
  get config() {
    return this.instance.config;
  }
  get consent() {
    return this.getDnt() ? Qn.DENIED : this.storedConsent;
  }
  isOptedOut() {
    return this.consent === Qn.DENIED || this.consent === Qn.PENDING && this.config.opt_out_capturing_by_default;
  }
  isOptedIn() {
    return !this.isOptedOut();
  }
  optInOut(e) {
    this.storage.set(this.storageKey, e ? 1 : 0, this.config.cookie_expiration, this.config.cross_subdomain_cookie, this.config.secure_cookie);
  }
  reset() {
    this.storage.remove(this.storageKey, this.config.cross_subdomain_cookie);
  }
  get storageKey() {
    var {
      token: e,
      opt_out_capturing_cookie_prefix: t
    } = this.instance.config;
    return (t || "__ph_opt_in_out_") + e;
  }
  get storedConsent() {
    var e = this.storage.get(this.storageKey);
    return "1" === e ? Qn.GRANTED : "0" === e ? Qn.DENIED : Qn.PENDING;
  }
  get storage() {
    if (!this._storage) {
      var e = this.config.opt_out_capturing_persistence_type;
      this._storage = "localStorage" === e ? ct : lt;
      var t = "localStorage" === e ? lt : ct;
      t.get(this.storageKey) && (this._storage.get(this.storageKey) || this.optInOut("1" === t.get(this.storageKey)), t.remove(this.storageKey, this.config.cross_subdomain_cookie));
    }
    return this._storage;
  }
  getDnt() {
    return !!this.config.respect_dnt && !!oe([null == o ? void 0 : o.doNotTrack, null == o ? void 0 : o.msDoNotTrack, _.doNotTrack], e => m([!0, 1, "1", "yes"], e));
  }
}
var eo = B("[ExceptionAutocapture]");
class to {
  constructor(e) {
    var i;
    W(this, "originalOnUnhandledRejectionHandler", void 0), W(this, "startCapturing", () => {
      var e, i, r, s;
      if (t && this.isEnabled && !this.hasHandlers && !this.isCapturing) {
        var n = null === (e = _.__PosthogExtensions__) || void 0 === e || null === (i = e.errorWrappingFunctions) || void 0 === i ? void 0 : i.wrapOnError,
          o = null === (r = _.__PosthogExtensions__) || void 0 === r || null === (s = r.errorWrappingFunctions) || void 0 === s ? void 0 : s.wrapUnhandledRejection;
        if (n && o) try {
          this.unwrapOnError = n(this.captureException.bind(this)), this.unwrapUnhandledRejection = o(this.captureException.bind(this));
        } catch (e) {
          eo.error("failed to start", e), this.stopCapturing();
        } else eo.error("failed to load error wrapping functions - cannot start");
      }
    }), this.instance = e, this.remoteEnabled = !(null === (i = this.instance.persistence) || void 0 === i || !i.props[he]), this.startIfEnabled();
  }
  get isEnabled() {
    var e;
    return null !== (e = this.remoteEnabled) && void 0 !== e && e;
  }
  get isCapturing() {
    var e;
    return !(null == t || null === (e = t.onerror) || void 0 === e || !e.__POSTHOG_INSTRUMENTED__);
  }
  get hasHandlers() {
    return this.originalOnUnhandledRejectionHandler || this.unwrapOnError;
  }
  startIfEnabled() {
    this.isEnabled && !this.isCapturing && (eo.info("enabled, starting..."), this.loadScript(this.startCapturing));
  }
  loadScript(e) {
    var t, i;
    this.hasHandlers && e(), null === (t = _.__PosthogExtensions__) || void 0 === t || null === (i = t.loadExternalDependency) || void 0 === i || i.call(t, this.instance, "exception-autocapture", t => {
      if (t) return eo.error("failed to load script", t);
      e();
    });
  }
  stopCapturing() {
    var e, t;
    null === (e = this.unwrapOnError) || void 0 === e || e.call(this), null === (t = this.unwrapUnhandledRejection) || void 0 === t || t.call(this);
  }
  onRemoteConfig(e) {
    var t = e.autocaptureExceptions;
    this.remoteEnabled = !!t || !1, this.instance.persistence && this.instance.persistence.register({
      [he]: this.remoteEnabled
    }), this.startIfEnabled();
  }
  captureException(e) {
    var t = this.instance.requestRouter.endpointFor("ui");
    e.$exception_personURL = "".concat(t, "/project/").concat(this.instance.config.token, "/person/").concat(this.instance.get_distinct_id()), this.instance.exceptions.sendExceptionEvent(e);
  }
}
var io = B("[Web Vitals]"),
  ro = 9e5;
class so {
  constructor(e) {
    var t;
    W(this, "_enabledServerSide", !1), W(this, "_initialized", !1), W(this, "buffer", {
      url: void 0,
      metrics: [],
      firstMetricTimestamp: void 0
    }), W(this, "_flushToCapture", () => {
      clearTimeout(this._delayedFlushTimer), 0 !== this.buffer.metrics.length && (this.instance.capture("$web_vitals", this.buffer.metrics.reduce((e, t) => j(j({}, e), {}, {
        ["$web_vitals_".concat(t.name, "_event")]: j({}, t),
        ["$web_vitals_".concat(t.name, "_value")]: t.value
      }), {})), this.buffer = {
        url: void 0,
        metrics: [],
        firstMetricTimestamp: void 0
      });
    }), W(this, "_addToBuffer", e => {
      var t,
        i = null === (t = this.instance.sessionManager) || void 0 === t ? void 0 : t.checkAndGetSessionAndWindowId(!0);
      if (R(i)) io.error("Could not read session ID. Dropping metrics!");else {
        this.buffer = this.buffer || {
          url: void 0,
          metrics: [],
          firstMetricTimestamp: void 0
        };
        var r = this._currentURL();
        if (!R(r)) if (O(null == e ? void 0 : e.name) || O(null == e ? void 0 : e.value)) io.error("Invalid metric received", e);else if (this._maxAllowedValue && e.value >= this._maxAllowedValue) io.error("Ignoring metric with value >= " + this._maxAllowedValue, e);else this.buffer.url !== r && (this._flushToCapture(), this._delayedFlushTimer = setTimeout(this._flushToCapture, this.flushToCaptureTimeoutMs)), R(this.buffer.url) && (this.buffer.url = r), this.buffer.firstMetricTimestamp = R(this.buffer.firstMetricTimestamp) ? Date.now() : this.buffer.firstMetricTimestamp, e.attribution && e.attribution.interactionTargetElement && (e.attribution.interactionTargetElement = void 0), this.buffer.metrics.push(j(j({}, e), {}, {
          $current_url: r,
          $session_id: i.sessionId,
          $window_id: i.windowId,
          timestamp: Date.now()
        })), this.buffer.metrics.length === this.allowedMetrics.length && this._flushToCapture();
      }
    }), W(this, "_startCapturing", () => {
      var e,
        t,
        i,
        r,
        s = _.__PosthogExtensions__;
      R(s) || R(s.postHogWebVitalsCallbacks) || ({
        onLCP: e,
        onCLS: t,
        onFCP: i,
        onINP: r
      } = s.postHogWebVitalsCallbacks), e && t && i && r ? (this.allowedMetrics.indexOf("LCP") > -1 && e(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("CLS") > -1 && t(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("FCP") > -1 && i(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("INP") > -1 && r(this._addToBuffer.bind(this)), this._initialized = !0) : io.error("web vitals callbacks not loaded - not starting");
    }), this.instance = e, this._enabledServerSide = !(null === (t = this.instance.persistence) || void 0 === t || !t.props[_e]), this.startIfEnabled();
  }
  get allowedMetrics() {
    var e,
      t,
      i = C(this.instance.config.capture_performance) ? null === (e = this.instance.config.capture_performance) || void 0 === e ? void 0 : e.web_vitals_allowed_metrics : void 0;
    return R(i) ? (null === (t = this.instance.persistence) || void 0 === t ? void 0 : t.props[ve]) || ["CLS", "FCP", "INP", "LCP"] : i;
  }
  get flushToCaptureTimeoutMs() {
    return (C(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals_delayed_flush_ms : void 0) || 5e3;
  }
  get _maxAllowedValue() {
    var e = C(this.instance.config.capture_performance) && M(this.instance.config.capture_performance.__web_vitals_max_value) ? this.instance.config.capture_performance.__web_vitals_max_value : ro;
    return 0 < e && e <= 6e4 ? ro : e;
  }
  get isEnabled() {
    var e = C(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals : void 0;
    return L(e) ? e : this._enabledServerSide;
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (io.info("enabled, starting..."), this.loadScript(this._startCapturing));
  }
  onRemoteConfig(e) {
    var t = C(e.capturePerformance) && !!e.capturePerformance.web_vitals,
      i = C(e.capturePerformance) ? e.capturePerformance.web_vitals_allowed_metrics : void 0;
    this.instance.persistence && (this.instance.persistence.register({
      [_e]: t
    }), this.instance.persistence.register({
      [ve]: i
    })), this._enabledServerSide = t, this.startIfEnabled();
  }
  loadScript(e) {
    var t, i, r;
    null !== (t = _.__PosthogExtensions__) && void 0 !== t && t.postHogWebVitalsCallbacks && e(), null === (i = _.__PosthogExtensions__) || void 0 === i || null === (r = i.loadExternalDependency) || void 0 === r || r.call(i, this.instance, "web-vitals", t => {
      t ? io.error("failed to load script", t) : e();
    });
  }
  _currentURL() {
    var e = t ? t.location.href : void 0;
    return e || io.error("Could not determine current URL"), e;
  }
}
var no = {
  icontains: (e, i) => !!t && i.href.toLowerCase().indexOf(e.toLowerCase()) > -1,
  not_icontains: (e, i) => !!t && -1 === i.href.toLowerCase().indexOf(e.toLowerCase()),
  regex: (e, i) => !!t && bt(i.href, e),
  not_regex: (e, i) => !!t && !bt(i.href, e),
  exact: (e, t) => t.href === e,
  is_not: (e, t) => t.href !== e
};
class oo {
  constructor(e) {
    var t = this;
    W(this, "getWebExperimentsAndEvaluateDisplayLogic", function () {
      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      t.getWebExperiments(e => {
        oo.logInfo("retrieved web experiments from the server"), t._flagToExperiments = new Map(), e.forEach(e => {
          if (e.feature_flag_key) {
            var i;
            if (t._flagToExperiments) oo.logInfo("setting flag key ", e.feature_flag_key, " to web experiment ", e), null === (i = t._flagToExperiments) || void 0 === i || i.set(e.feature_flag_key, e);
            var r = t.instance.getFeatureFlag(e.feature_flag_key);
            F(r) && e.variants[r] && t.applyTransforms(e.name, r, e.variants[r].transforms);
          } else if (e.variants) for (var s in e.variants) {
            var n = e.variants[s];
            oo.matchesTestVariant(n) && t.applyTransforms(e.name, s, n.transforms);
          }
        });
      }, e);
    }), this.instance = e, this.instance.onFeatureFlags(e => {
      this.onFeatureFlags(e);
    });
  }
  onFeatureFlags(e) {
    if (this._is_bot()) oo.logInfo("Refusing to render web experiment since the viewer is a likely bot");else if (!this.instance.config.disable_web_experiments) {
      if (O(this._flagToExperiments)) return this._flagToExperiments = new Map(), this.loadIfEnabled(), void this.previewWebExperiment();
      oo.logInfo("applying feature flags", e), e.forEach(e => {
        var t;
        if (this._flagToExperiments && null !== (t = this._flagToExperiments) && void 0 !== t && t.has(e)) {
          var i,
            r = this.instance.getFeatureFlag(e),
            s = null === (i = this._flagToExperiments) || void 0 === i ? void 0 : i.get(e);
          r && null != s && s.variants[r] && this.applyTransforms(s.name, r, s.variants[r].transforms);
        }
      });
    }
  }
  previewWebExperiment() {
    var e = oo.getWindowLocation();
    if (null != e && e.search) {
      var t = wt(null == e ? void 0 : e.search, "__experiment_id"),
        i = wt(null == e ? void 0 : e.search, "__experiment_variant");
      t && i && (oo.logInfo("previewing web experiments ".concat(t, " && ").concat(i)), this.getWebExperiments(e => {
        this.showPreviewWebExperiment(parseInt(t), i, e);
      }, !1, !0));
    }
  }
  loadIfEnabled() {
    this.instance.config.disable_web_experiments || this.getWebExperimentsAndEvaluateDisplayLogic();
  }
  getWebExperiments(e, t, i) {
    if (this.instance.config.disable_web_experiments && !i) return e([]);
    var r = this.instance.get_property("$web_experiments");
    if (r && !t) return e(r);
    this.instance._send_request({
      url: this.instance.requestRouter.endpointFor("api", "/api/web_experiments/?token=".concat(this.instance.config.token)),
      method: "GET",
      callback: t => {
        if (200 !== t.statusCode || !t.json) return e([]);
        var i = t.json.experiments || [];
        return e(i);
      }
    });
  }
  showPreviewWebExperiment(e, t, i) {
    var r = i.filter(t => t.id === e);
    r && r.length > 0 && (oo.logInfo("Previewing web experiment [".concat(r[0].name, "] with variant [").concat(t, "]")), this.applyTransforms(r[0].name, t, r[0].variants[t].transforms));
  }
  static matchesTestVariant(e) {
    return !O(e.conditions) && oo.matchUrlConditions(e) && oo.matchUTMConditions(e);
  }
  static matchUrlConditions(e) {
    var t;
    if (O(e.conditions) || O(null === (t = e.conditions) || void 0 === t ? void 0 : t.url)) return !0;
    var i,
      r,
      s,
      n = oo.getWindowLocation();
    return !!n && (null === (i = e.conditions) || void 0 === i || !i.url || no[null !== (r = null === (s = e.conditions) || void 0 === s ? void 0 : s.urlMatchType) && void 0 !== r ? r : "icontains"](e.conditions.url, n));
  }
  static getWindowLocation() {
    return null == t ? void 0 : t.location;
  }
  static matchUTMConditions(e) {
    var t;
    if (O(e.conditions) || O(null === (t = e.conditions) || void 0 === t ? void 0 : t.utm)) return !0;
    var i = Ei.campaignParams();
    if (i.utm_source) {
      var r,
        s,
        n,
        o,
        a,
        l,
        u,
        c,
        d,
        h,
        _,
        p,
        v,
        g,
        f,
        m,
        b = null === (r = e.conditions) || void 0 === r || null === (s = r.utm) || void 0 === s || !s.utm_campaign || (null === (n = e.conditions) || void 0 === n || null === (o = n.utm) || void 0 === o ? void 0 : o.utm_campaign) == i.utm_campaign,
        y = null === (a = e.conditions) || void 0 === a || null === (l = a.utm) || void 0 === l || !l.utm_source || (null === (u = e.conditions) || void 0 === u || null === (c = u.utm) || void 0 === c ? void 0 : c.utm_source) == i.utm_source,
        w = null === (d = e.conditions) || void 0 === d || null === (h = d.utm) || void 0 === h || !h.utm_medium || (null === (_ = e.conditions) || void 0 === _ || null === (p = _.utm) || void 0 === p ? void 0 : p.utm_medium) == i.utm_medium,
        S = null === (v = e.conditions) || void 0 === v || null === (g = v.utm) || void 0 === g || !g.utm_term || (null === (f = e.conditions) || void 0 === f || null === (m = f.utm) || void 0 === m ? void 0 : m.utm_term) == i.utm_term;
      return b && w && S && y;
    }
    return !1;
  }
  static logInfo(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    q.info("[WebExperiments] ".concat(e), i);
  }
  applyTransforms(e, t, i) {
    this._is_bot() ? oo.logInfo("Refusing to render web experiment since the viewer is a likely bot") : "control" !== t ? i.forEach(i => {
      if (i.selector) {
        var r;
        oo.logInfo("applying transform of variant ".concat(t, " for experiment ").concat(e, " "), i);
        var s = null === (r = document) || void 0 === r ? void 0 : r.querySelectorAll(i.selector);
        null == s || s.forEach(e => {
          var t = e;
          i.attributes && i.attributes.forEach(e => {
            switch (e.name) {
              case "text":
                t.innerText = e.value;
                break;
              case "html":
                t.innerHTML = e.value;
                break;
              case "cssClass":
                t.className = e.value;
                break;
              default:
                t.setAttribute(e.name, e.value);
            }
          }), i.text && (t.innerText = i.text), i.html && (t.parentElement ? t.parentElement.innerHTML = i.html : t.innerHTML = i.html), i.css && t.setAttribute("style", i.css);
        });
      }
    }) : oo.logInfo("Control variants leave the page unmodified.");
  }
  _is_bot() {
    return o && this.instance ? Mn(o, this.instance.config.custom_blocked_useragents) : void 0;
  }
}
class ao {
  constructor(e) {
    this.instance = e;
  }
  sendExceptionEvent(e) {
    this.instance.capture("$exception", e, {
      _noTruncate: !0,
      _batchKey: "exceptionEvent"
    });
  }
}
var lo = ["$set_once", "$set"],
  uo = B("[SiteApps]");
class co {
  constructor(e) {
    this.instance = e, this.bufferedInvocations = [], this.apps = {};
  }
  get isEnabled() {
    return !!this.instance.config.opt_in_site_apps;
  }
  eventCollector(e, t) {
    if (t) {
      var i = this.globalsForEvent(t);
      this.bufferedInvocations.push(i), this.bufferedInvocations.length > 1e3 && (this.bufferedInvocations = this.bufferedInvocations.slice(10));
    }
  }
  get siteAppLoaders() {
    var e, t;
    return null === (e = _._POSTHOG_REMOTE_CONFIG) || void 0 === e || null === (t = e[this.instance.config.token]) || void 0 === t ? void 0 : t.siteApps;
  }
  init() {
    if (this.isEnabled) {
      var e = this.instance._addCaptureHook(this.eventCollector.bind(this));
      this.stopBuffering = () => {
        e(), this.bufferedInvocations = [], this.stopBuffering = void 0;
      };
    }
  }
  globalsForEvent(e) {
    var t, i, r, s, n, o, a;
    if (!e) throw new Error("Event payload is required");
    var l = {},
      u = this.instance.get_property("$groups") || [],
      c = this.instance.get_property("$stored_group_properties") || {};
    for (var [d, h] of Object.entries(c)) l[d] = {
      id: u[d],
      type: d,
      properties: h
    };
    var {
      $set_once: _,
      $set: p
    } = e;
    return {
      event: j(j({}, V(e, lo)), {}, {
        properties: j(j(j({}, e.properties), p ? {
          $set: j(j({}, null !== (t = null === (i = e.properties) || void 0 === i ? void 0 : i.$set) && void 0 !== t ? t : {}), p)
        } : {}), _ ? {
          $set_once: j(j({}, null !== (r = null === (s = e.properties) || void 0 === s ? void 0 : s.$set_once) && void 0 !== r ? r : {}), _)
        } : {}),
        elements_chain: null !== (n = null === (o = e.properties) || void 0 === o ? void 0 : o.$elements_chain) && void 0 !== n ? n : "",
        distinct_id: null === (a = e.properties) || void 0 === a ? void 0 : a.distinct_id
      }),
      person: {
        properties: this.instance.get_property("$stored_person_properties")
      },
      groups: l
    };
  }
  setupSiteApp(e) {
    var t = {
      id: e.id,
      loaded: !1,
      errored: !1
    };
    this.apps[e.id] = t;
    var i = i => {
      var r;
      for (var s of (this.apps[e.id].errored = !i, this.apps[e.id].loaded = !0, uo.info("Site app with id ".concat(e.id, " ").concat(i ? "loaded" : "errored")), i && this.bufferedInvocations.length && (uo.info("Processing ".concat(this.bufferedInvocations.length, " events for site app with id ").concat(e.id)), this.bufferedInvocations.forEach(e => {
        var i;
        return null === (i = t.processEvent) || void 0 === i ? void 0 : i.call(t, e);
      })), Object.values(this.apps))) if (!s.loaded) return;
      null === (r = this.stopBuffering) || void 0 === r || r.call(this);
    };
    try {
      var {
        processEvent: r
      } = e.init({
        posthog: this.instance,
        callback: e => {
          i(e);
        }
      });
      r && (t.processEvent = r);
    } catch (t) {
      uo.error("Error while initializing PostHog app with config id ".concat(e.id), t), i(!1);
    }
  }
  onCapturedEvent(e) {
    if (0 !== Object.keys(this.apps).length) {
      var t = this.globalsForEvent(e);
      for (var i of Object.values(this.apps)) try {
        var r;
        null === (r = i.processEvent) || void 0 === r || r.call(i, t);
      } catch (t) {
        uo.error("Error while processing event ".concat(e.event, " for site app ").concat(i.id), t);
      }
    }
  }
  onRemoteConfig(e) {
    var t,
      i,
      r,
      s = this;
    if (null !== (t = this.siteAppLoaders) && void 0 !== t && t.length) {
      if (!this.isEnabled) return void uo.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
      for (var n of this.siteAppLoaders) this.setupSiteApp(n);
      this.instance.on("eventCaptured", e => this.onCapturedEvent(e));
    } else if (null === (i = this.stopBuffering) || void 0 === i || i.call(this), null !== (r = e.siteApps) && void 0 !== r && r.length) if (this.isEnabled) {
      var o = function (e, t) {
        var i, r;
        _["__$$ph_site_app_".concat(e)] = s.instance, null === (i = _.__PosthogExtensions__) || void 0 === i || null === (r = i.loadSiteApp) || void 0 === r || r.call(i, s.instance, t, t => {
          if (t) return uo.error("Error while initializing PostHog app with config id ".concat(e), t);
        });
      };
      for (var {
        id: a,
        url: l
      } of e.siteApps) o(a, l);
    } else uo.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
  }
}
function ho(e, t, i) {
  return ys({
    distinct_id: e,
    userPropertiesToSet: t,
    userPropertiesToSetOnce: i
  });
}
var _o = {},
  po = () => {},
  vo = "posthog",
  go = !fs && -1 === (null == h ? void 0 : h.indexOf("MSIE")) && -1 === (null == h ? void 0 : h.indexOf("Mozilla")),
  fo = () => {
    var e;
    return {
      api_host: "https://us.i.posthog.com",
      ui_host: null,
      token: "",
      autocapture: !0,
      rageclick: !0,
      cross_subdomain_cookie: ne(null == a ? void 0 : a.location),
      persistence: "localStorage+cookie",
      persistence_name: "",
      loaded: po,
      save_campaign_params: !0,
      custom_campaign_params: [],
      custom_blocked_useragents: [],
      save_referrer: !0,
      capture_pageview: !0,
      capture_pageleave: "if_capture_pageview",
      debug: l && F(null == l ? void 0 : l.search) && -1 !== l.search.indexOf("__posthog_debug=true") || !1,
      cookie_expiration: 365,
      upgrade: !1,
      disable_session_recording: !1,
      disable_persistence: !1,
      disable_web_experiments: !0,
      disable_surveys: !1,
      disable_external_dependency_loading: !1,
      enable_recording_console_log: void 0,
      secure_cookie: "https:" === (null == t || null === (e = t.location) || void 0 === e ? void 0 : e.protocol),
      ip: !0,
      opt_out_capturing_by_default: !1,
      opt_out_persistence_by_default: !1,
      opt_out_useragent_filter: !1,
      opt_out_capturing_persistence_type: "localStorage",
      opt_out_capturing_cookie_prefix: null,
      opt_in_site_apps: !1,
      property_denylist: [],
      respect_dnt: !1,
      sanitize_properties: null,
      request_headers: {},
      request_batching: !0,
      properties_string_max_length: 65535,
      session_recording: {},
      mask_all_element_attributes: !1,
      mask_all_text: !1,
      mask_personal_data_properties: !1,
      custom_personal_data_properties: [],
      advanced_disable_decide: !1,
      advanced_disable_feature_flags: !1,
      advanced_disable_feature_flags_on_first_load: !1,
      advanced_disable_toolbar_metrics: !1,
      feature_flag_request_timeout_ms: 3e3,
      on_request_error: e => {
        var t = "Bad HTTP status: " + e.statusCode + " " + e.text;
        q.error(t);
      },
      get_device_id: e => e,
      capture_performance: void 0,
      name: "posthog",
      bootstrap: {},
      disable_compression: !1,
      session_idle_timeout_seconds: 1800,
      person_profiles: "identified_only",
      before_send: void 0,
      _onCapture: po
    };
  },
  mo = e => {
    var t = {};
    R(e.process_person) || (t.person_profiles = e.process_person), R(e.xhr_headers) || (t.request_headers = e.xhr_headers), R(e.cookie_name) || (t.persistence_name = e.cookie_name), R(e.disable_cookie) || (t.disable_persistence = e.disable_cookie), R(e.store_google) || (t.save_campaign_params = e.store_google), R(e.verbose) || (t.debug = e.verbose);
    var i = K({}, t, e);
    return x(e.property_blacklist) && (R(e.property_denylist) ? i.property_denylist = e.property_blacklist : x(e.property_denylist) ? i.property_denylist = [...e.property_blacklist, ...e.property_denylist] : q.error("Invalid value for property_denylist config: " + e.property_denylist)), i;
  };
class bo {
  constructor() {
    W(this, "__forceAllowLocalhost", !1);
  }
  get _forceAllowLocalhost() {
    return this.__forceAllowLocalhost;
  }
  set _forceAllowLocalhost(e) {
    q.error("WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"), this.__forceAllowLocalhost = e;
  }
}
class yo {
  get decideEndpointWasHit() {
    var e, t;
    return null !== (e = null === (t = this.featureFlags) || void 0 === t ? void 0 : t.hasLoadedFlags) && void 0 !== e && e;
  }
  constructor() {
    W(this, "webPerformance", new bo()), W(this, "version", p.LIB_VERSION), W(this, "_internalEventEmitter", new wn()), this.config = fo(), this.SentryIntegration = $s, this.sentryIntegration = e => function (e, t) {
      var i = Ts(e, t);
      return {
        name: Fs,
        processEvent: e => i(e)
      };
    }(this, e), this.__request_queue = [], this.__loaded = !1, this.analyticsDefaultEndpoint = "/e/", this._initialPageviewCaptured = !1, this._initialPersonProfilesConfig = null, this._cachedIdentify = null, this.featureFlags = new Ye(this), this.toolbar = new ps(this), this.scrollManager = new zn(this), this.pageViewManager = new Ls(this), this.surveys = new Cn(this), this.experiments = new oo(this), this.exceptions = new ao(this), this.rateLimiter = new Rn(this), this.requestRouter = new Rs(this), this.consent = new Zn(this), this.people = {
      set: (e, t, i) => {
        var r = F(e) ? {
          [e]: t
        } : e;
        this.setPersonProperties(r), null == i || i({});
      },
      set_once: (e, t, i) => {
        var r = F(e) ? {
          [e]: t
        } : e;
        this.setPersonProperties(void 0, r), null == i || i({});
      }
    }, this.on("eventCaptured", e => q.info('send "'.concat(null == e ? void 0 : e.event, '"'), e));
  }
  init(e, t, i) {
    if (i && i !== vo) {
      var r,
        s = null !== (r = _o[i]) && void 0 !== r ? r : new yo();
      return s._init(e, t, i), _o[i] = s, _o[vo][i] = s, s;
    }
    return this._init(e, t, i);
  }
  _init(i) {
    var r,
      s,
      n,
      o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      a = arguments.length > 2 ? arguments[2] : void 0;
    if (R(i) || T(i)) return q.critical("PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"), this;
    if (this.__loaded) return q.warn("You have already initialized PostHog! Re-initializing is a no-op"), this;
    this.__loaded = !0, this.config = {}, this._triggered_notifs = [], o.person_profiles && (this._initialPersonProfilesConfig = o.person_profiles), this.set_config(K({}, fo(), mo(o), {
      name: a,
      token: i
    })), this.config.on_xhr_error && q.error("on_xhr_error is deprecated. Use on_request_error instead"), this.compression = o.disable_compression ? void 0 : e.GZipJS, this.persistence = new xi(this.config), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new xi(j(j({}, this.config), {}, {
      persistence: "sessionStorage"
    }));
    var l = j({}, this.persistence.props),
      u = j({}, this.sessionPersistence.props);
    if (this._requestQueue = new vs(e => this._send_retriable_request(e)), this._retryQueue = new ks(this), this.__request_queue = [], this.config.__preview_experimental_cookieless_mode || (this.sessionManager = new Cs(this), this.sessionPropsManager = new Tn(this, this.sessionManager, this.persistence)), new Xn(this).startIfEnabledOrStop(), this.siteApps = new co(this), null === (r = this.siteApps) || void 0 === r || r.init(), this.config.__preview_experimental_cookieless_mode || (this.sessionRecording = new as(this), this.sessionRecording.startIfEnabledOrStop()), this.config.disable_scroll_properties || this.scrollManager.startMeasuringScrollPosition(), this.autocapture = new Yn(this), this.autocapture.startIfEnabled(), this.surveys.loadIfEnabled(), this.heatmaps = new Un(this), this.heatmaps.startIfEnabled(), this.webVitalsAutocapture = new so(this), this.exceptionObserver = new to(this), this.exceptionObserver.startIfEnabled(), this.deadClicksAutocapture = new qn(this, Nn), this.deadClicksAutocapture.startIfEnabled(), p.DEBUG = p.DEBUG || this.config.debug, p.DEBUG && q.info("Starting in debug mode", {
      this: this,
      config: o,
      thisC: j({}, this.config),
      p: l,
      s: u
    }), this._sync_opt_out_with_persistence(), void 0 !== (null === (s = o.bootstrap) || void 0 === s ? void 0 : s.distinctID)) {
      var c,
        d,
        h = this.config.get_device_id(it()),
        _ = null !== (c = o.bootstrap) && void 0 !== c && c.isIdentifiedID ? h : o.bootstrap.distinctID;
      this.persistence.set_property(Me, null !== (d = o.bootstrap) && void 0 !== d && d.isIdentifiedID ? "identified" : "anonymous"), this.register({
        distinct_id: o.bootstrap.distinctID,
        $device_id: _
      });
    }
    if (this._hasBootstrappedFeatureFlags()) {
      var v,
        g,
        f = Object.keys((null === (v = o.bootstrap) || void 0 === v ? void 0 : v.featureFlags) || {}).filter(e => {
          var t, i;
          return !(null === (t = o.bootstrap) || void 0 === t || null === (i = t.featureFlags) || void 0 === i || !i[e]);
        }).reduce((e, t) => {
          var i, r;
          return e[t] = (null === (i = o.bootstrap) || void 0 === i || null === (r = i.featureFlags) || void 0 === r ? void 0 : r[t]) || !1, e;
        }, {}),
        m = Object.keys((null === (g = o.bootstrap) || void 0 === g ? void 0 : g.featureFlagPayloads) || {}).filter(e => f[e]).reduce((e, t) => {
          var i, r, s, n;
          null !== (i = o.bootstrap) && void 0 !== i && null !== (r = i.featureFlagPayloads) && void 0 !== r && r[t] && (e[t] = null === (s = o.bootstrap) || void 0 === s || null === (n = s.featureFlagPayloads) || void 0 === n ? void 0 : n[t]);
          return e;
        }, {});
      this.featureFlags.receivedFeatureFlags({
        featureFlags: f,
        featureFlagPayloads: m
      });
    }
    if (this.config.__preview_experimental_cookieless_mode) this.register_once({
      distinct_id: Ue,
      $device_id: null
    }, "");else if (!this.get_distinct_id()) {
      var b = this.config.get_device_id(it());
      this.register_once({
        distinct_id: b,
        $device_id: b
      }, ""), this.persistence.set_property(Me, "anonymous");
    }
    return null == t || null === (n = t.addEventListener) || void 0 === n || n.call(t, "onpagehide" in self ? "pagehide" : "unload", this._handle_unload.bind(this)), this.toolbar.maybeLoadToolbar(), o.segment ? Ms(this, () => this._loaded()) : this._loaded(), I(this.config._onCapture) && this.config._onCapture !== po && (q.warn("onCapture is deprecated. Please use `before_send` instead"), this.on("eventCaptured", e => this.config._onCapture(e.event, e))), this;
  }
  _onRemoteConfig(t) {
    var i, r, s, n, o, l, u, c;
    if (!a || !a.body) return q.info("document not ready yet, trying again in 500 milliseconds..."), void setTimeout(() => {
      this._onRemoteConfig(t);
    }, 500);
    this.compression = void 0, t.supportedCompression && !this.config.disable_compression && (this.compression = m(t.supportedCompression, e.GZipJS) ? e.GZipJS : m(t.supportedCompression, e.Base64) ? e.Base64 : void 0), null !== (i = t.analytics) && void 0 !== i && i.endpoint && (this.analyticsDefaultEndpoint = t.analytics.endpoint), this.set_config({
      person_profiles: this._initialPersonProfilesConfig ? this._initialPersonProfilesConfig : "identified_only"
    }), null === (r = this.siteApps) || void 0 === r || r.onRemoteConfig(t), null === (s = this.sessionRecording) || void 0 === s || s.onRemoteConfig(t), null === (n = this.autocapture) || void 0 === n || n.onRemoteConfig(t), null === (o = this.heatmaps) || void 0 === o || o.onRemoteConfig(t), this.surveys.onRemoteConfig(t), null === (l = this.webVitalsAutocapture) || void 0 === l || l.onRemoteConfig(t), null === (u = this.exceptionObserver) || void 0 === u || u.onRemoteConfig(t), null === (c = this.deadClicksAutocapture) || void 0 === c || c.onRemoteConfig(t);
  }
  _loaded() {
    try {
      this.config.loaded(this);
    } catch (e) {
      q.critical("`loaded` function failed", e);
    }
    this._start_queue_if_opted_in(), this.config.capture_pageview && setTimeout(() => {
      this.consent.isOptedIn() && this._captureInitialPageview();
    }, 1), new us(this).load(), this.featureFlags.decide();
  }
  _start_queue_if_opted_in() {
    var e;
    this.has_opted_out_capturing() || this.config.request_batching && (null === (e = this._requestQueue) || void 0 === e || e.enable());
  }
  _dom_loaded() {
    this.has_opted_out_capturing() || J(this.__request_queue, e => this._send_retriable_request(e)), this.__request_queue = [], this._start_queue_if_opted_in();
  }
  _handle_unload() {
    var e, t;
    this.config.request_batching ? (this._shouldCapturePageleave() && this.capture("$pageleave"), null === (e = this._requestQueue) || void 0 === e || e.unload(), null === (t = this._retryQueue) || void 0 === t || t.unload()) : this._shouldCapturePageleave() && this.capture("$pageleave", null, {
      transport: "sendBeacon"
    });
  }
  _send_request(e) {
    this.__loaded && (go ? this.__request_queue.push(e) : this.rateLimiter.isServerRateLimited(e.batchKey) || (e.transport = e.transport || this.config.api_transport, e.url = bs(e.url, {
      ip: this.config.ip ? 1 : 0
    }), e.headers = j({}, this.config.request_headers), e.compression = "best-available" === e.compression ? this.compression : e.compression, e.fetchOptions = e.fetchOptions || this.config.fetch_options, (e => {
      var t,
        i,
        r,
        s = j({}, e);
      s.timeout = s.timeout || 6e4, s.url = bs(s.url, {
        _: new Date().getTime().toString(),
        ver: p.LIB_VERSION,
        compression: s.compression
      });
      var n = null !== (t = s.transport) && void 0 !== t ? t : "fetch",
        o = null !== (i = null === (r = oe(Ss, e => e.transport === n)) || void 0 === r ? void 0 : r.method) && void 0 !== i ? i : Ss[0].method;
      if (!o) throw new Error("No available transport method");
      o(s);
    })(j(j({}, e), {}, {
      callback: t => {
        var i, r, s;
        (this.rateLimiter.checkForLimiting(t), t.statusCode >= 400) && (null === (r = (s = this.config).on_request_error) || void 0 === r || r.call(s, t));
        null === (i = e.callback) || void 0 === i || i.call(e, t);
      }
    }))));
  }
  _send_retriable_request(e) {
    this._retryQueue ? this._retryQueue.retriableRequest(e) : this._send_request(e);
  }
  _execute_array(e) {
    var t,
      i = [],
      r = [],
      s = [];
    J(e, e => {
      e && (t = e[0], x(t) ? s.push(e) : I(e) ? e.call(this) : x(e) && "alias" === t ? i.push(e) : x(e) && -1 !== t.indexOf("capture") && I(this[t]) ? s.push(e) : r.push(e));
    });
    var n = function (e, t) {
      J(e, function (e) {
        if (x(e[0])) {
          var i = t;
          Y(e, function (e) {
            i = i[e[0]].apply(i, e.slice(1));
          });
        } else this[e[0]].apply(this, e.slice(1));
      }, t);
    };
    n(i, this), n(r, this), n(s, this);
  }
  _hasBootstrappedFeatureFlags() {
    var e, t;
    return (null === (e = this.config.bootstrap) || void 0 === e ? void 0 : e.featureFlags) && Object.keys(null === (t = this.config.bootstrap) || void 0 === t ? void 0 : t.featureFlags).length > 0 || !1;
  }
  push(e) {
    this._execute_array([e]);
  }
  capture(e, t, i) {
    var r;
    if (this.__loaded && this.persistence && this.sessionPersistence && this._requestQueue) {
      if (!this.consent.isOptedOut()) if (!R(e) && F(e)) {
        if (this.config.opt_out_useragent_filter || !this._is_bot()) {
          var s = null != i && i.skip_client_rate_limiting ? void 0 : this.rateLimiter.clientRateLimitContext();
          if (null == s || !s.isRateLimited) {
            this.sessionPersistence.update_search_keyword(), this.config.save_campaign_params && this.sessionPersistence.update_campaign_params(), this.config.save_referrer && this.sessionPersistence.update_referrer_info(), (this.config.save_campaign_params || this.config.save_referrer) && this.persistence.set_initial_person_info();
            var n = new Date(),
              o = (null == i ? void 0 : i.timestamp) || n,
              a = it(),
              l = {
                uuid: a,
                event: e,
                properties: this._calculate_event_properties(e, t || {}, o, a)
              };
            s && (l.properties.$lib_rate_limit_remaining_tokens = s.remainingTokens), (null == i ? void 0 : i.$set) && (l.$set = null == i ? void 0 : i.$set);
            var u = this._calculate_set_once_properties(null == i ? void 0 : i.$set_once);
            u && (l.$set_once = u), (l = ie(l, null != i && i._noTruncate ? null : this.config.properties_string_max_length)).timestamp = o, R(null == i ? void 0 : i.timestamp) || (l.properties.$event_time_override_provided = !0, l.properties.$event_time_override_system_time = n);
            var c = j(j({}, l.properties.$set), l.$set);
            if (P(c) || this.setPersonPropertiesForFlags(c), !O(this.config.before_send)) {
              var d = this._runBeforeSend(l);
              if (!d) return;
              l = d;
            }
            this._internalEventEmitter.emit("eventCaptured", l);
            var h = {
              method: "POST",
              url: null !== (r = null == i ? void 0 : i._url) && void 0 !== r ? r : this.requestRouter.endpointFor("api", this.analyticsDefaultEndpoint),
              data: l,
              compression: "best-available",
              batchKey: null == i ? void 0 : i._batchKey
            };
            return !this.config.request_batching || i && (null == i || !i._batchKey) || null != i && i.send_instantly ? this._send_retriable_request(h) : this._requestQueue.enqueue(h), l;
          }
          q.critical("This capture call is ignored due to client rate limiting.");
        }
      } else q.error("No event name provided to posthog.capture");
    } else q.uninitializedWarning("posthog.capture");
  }
  _addCaptureHook(e) {
    return this.on("eventCaptured", t => e(t.event, t));
  }
  _calculate_event_properties(e, t, i, r) {
    if (i = i || new Date(), !this.persistence || !this.sessionPersistence) return t;
    var s = this.persistence.remove_event_timer(e),
      n = j({}, t);
    if (n.token = this.config.token, this.config.__preview_experimental_cookieless_mode && (n.$cookieless_mode = !0), "$snapshot" === e) {
      var o = j(j({}, this.persistence.properties()), this.sessionPersistence.properties());
      return n.distinct_id = o.distinct_id, (!F(n.distinct_id) && !M(n.distinct_id) || T(n.distinct_id)) && q.error("Invalid distinct_id for replay event. This indicates a bug in your implementation"), n;
    }
    var l,
      u = Ei.properties({
        maskPersonalDataProperties: this.config.mask_personal_data_properties,
        customPersonalDataProperties: this.config.custom_personal_data_properties
      });
    if (this.sessionManager) {
      var {
        sessionId: c,
        windowId: d
      } = this.sessionManager.checkAndGetSessionAndWindowId();
      n.$session_id = c, n.$window_id = d;
    }
    if (this.sessionRecording && (n.$recording_status = this.sessionRecording.status), this.requestRouter.region === xs.CUSTOM && (n.$lib_custom_api_host = this.config.api_host), l = "$pageview" === e ? this.pageViewManager.doPageView(i, r) : "$pageleave" === e ? this.pageViewManager.doPageLeave(i) : this.pageViewManager.doEvent(), n = K(n, l), "$pageview" === e && a && (n.title = a.title), !R(s)) {
      var _ = i.getTime() - s;
      n.$duration = parseFloat((_ / 1e3).toFixed(3));
    }
    h && this.config.opt_out_useragent_filter && (n.$browser_type = this._is_bot() ? "bot" : "browser"), (n = K({}, u, this.persistence.properties(), this.sessionPersistence.properties(), n)).$is_identified = this._isIdentified(), x(this.config.property_denylist) ? Y(this.config.property_denylist, function (e) {
      delete n[e];
    }) : q.error("Invalid value for property_denylist config: " + this.config.property_denylist + " or property_blacklist config: " + this.config.property_blacklist);
    var p = this.config.sanitize_properties;
    p && (q.error("sanitize_properties is deprecated. Use before_send instead"), n = p(n, e));
    var v = this._hasPersonProcessing();
    return n.$process_person_profile = v, v && this._requirePersonProcessing("_calculate_event_properties"), n;
  }
  _calculate_set_once_properties(e) {
    if (!this.persistence || !this._hasPersonProcessing()) return e;
    var t = K({}, this.persistence.get_initial_props(), e || {}),
      i = this.config.sanitize_properties;
    return i && (q.error("sanitize_properties is deprecated. Use before_send instead"), t = i(t, "$set_once")), P(t) ? void 0 : t;
  }
  register(e, t) {
    var i;
    null === (i = this.persistence) || void 0 === i || i.register(e, t);
  }
  register_once(e, t, i) {
    var r;
    null === (r = this.persistence) || void 0 === r || r.register_once(e, t, i);
  }
  register_for_session(e) {
    var t;
    null === (t = this.sessionPersistence) || void 0 === t || t.register(e);
  }
  unregister(e) {
    var t;
    null === (t = this.persistence) || void 0 === t || t.unregister(e);
  }
  unregister_for_session(e) {
    var t;
    null === (t = this.sessionPersistence) || void 0 === t || t.unregister(e);
  }
  _register_single(e, t) {
    this.register({
      [e]: t
    });
  }
  getFeatureFlag(e, t) {
    return this.featureFlags.getFeatureFlag(e, t);
  }
  getFeatureFlagPayload(e) {
    var t = this.featureFlags.getFeatureFlagPayload(e);
    try {
      return JSON.parse(t);
    } catch (e) {
      return t;
    }
  }
  isFeatureEnabled(e, t) {
    return this.featureFlags.isFeatureEnabled(e, t);
  }
  reloadFeatureFlags() {
    this.featureFlags.reloadFeatureFlags();
  }
  updateEarlyAccessFeatureEnrollment(e, t) {
    this.featureFlags.updateEarlyAccessFeatureEnrollment(e, t);
  }
  getEarlyAccessFeatures(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.featureFlags.getEarlyAccessFeatures(e, t);
  }
  on(e, t) {
    return this._internalEventEmitter.on(e, t);
  }
  onFeatureFlags(e) {
    return this.featureFlags.onFeatureFlags(e);
  }
  onSessionId(e) {
    var t, i;
    return null !== (t = null === (i = this.sessionManager) || void 0 === i ? void 0 : i.onSessionId(e)) && void 0 !== t ? t : () => {};
  }
  getSurveys(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getSurveys(e, t);
  }
  getActiveMatchingSurveys(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getActiveMatchingSurveys(e, t);
  }
  renderSurvey(e, t) {
    this.surveys.renderSurvey(e, t);
  }
  canRenderSurvey(e) {
    this.surveys.canRenderSurvey(e);
  }
  getNextSurveyStep(e, t, i) {
    return this.surveys.getNextSurveyStep(e, t, i);
  }
  identify(e, t, i) {
    if (!this.__loaded || !this.persistence) return q.uninitializedWarning("posthog.identify");
    if (M(e) && (e = e.toString(), q.warn("The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string.")), e) {
      if (["distinct_id", "distinctid"].includes(e.toLowerCase())) q.critical('The string "'.concat(e, '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.'));else if (this._requirePersonProcessing("posthog.identify")) {
        var r = this.get_distinct_id();
        if (this.register({
          $user_id: e
        }), !this.get_property("$device_id")) {
          var s = r;
          this.register_once({
            $had_persisted_distinct_id: !0,
            $device_id: s
          }, "");
        }
        e !== r && e !== this.get_property(le) && (this.unregister(le), this.register({
          distinct_id: e
        }));
        var n = "anonymous" === (this.persistence.get_property(Me) || "anonymous");
        e !== r && n ? (this.persistence.set_property(Me, "identified"), this.setPersonPropertiesForFlags(t || {}, !1), this.capture("$identify", {
          distinct_id: e,
          $anon_distinct_id: r
        }, {
          $set: t || {},
          $set_once: i || {}
        }), this.featureFlags.setAnonymousDistinctId(r), this._cachedIdentify = ho(e, t, i)) : (t || i) && (this._cachedIdentify !== ho(e, t, i) ? (this.setPersonProperties(t, i), this._cachedIdentify = ho(e, t, i)) : q.info("A duplicate posthog.identify call was made with the same properties. It has been ignored.")), e !== r && (this.reloadFeatureFlags(), this.unregister(Oe));
      }
    } else q.error("Unique user id has not been set in posthog.identify");
  }
  setPersonProperties(e, t) {
    (e || t) && this._requirePersonProcessing("posthog.setPersonProperties") && (this.setPersonPropertiesForFlags(e || {}), this.capture("$set", {
      $set: e || {},
      $set_once: t || {}
    }));
  }
  group(e, t, i) {
    if (e && t) {
      if (this._requirePersonProcessing("posthog.group")) {
        var r = this.getGroups();
        r[e] !== t && this.resetGroupPropertiesForFlags(e), this.register({
          $groups: j(j({}, r), {}, {
            [e]: t
          })
        }), i && (this.capture("$groupidentify", {
          $group_type: e,
          $group_key: t,
          $group_set: i
        }), this.setGroupPropertiesForFlags({
          [e]: i
        })), r[e] === t || i || this.reloadFeatureFlags();
      }
    } else q.error("posthog.group requires a group type and group key");
  }
  resetGroups() {
    this.register({
      $groups: {}
    }), this.resetGroupPropertiesForFlags(), this.reloadFeatureFlags();
  }
  setPersonPropertiesForFlags(e) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.featureFlags.setPersonPropertiesForFlags(e, t);
  }
  resetPersonPropertiesForFlags() {
    this.featureFlags.resetPersonPropertiesForFlags();
  }
  setGroupPropertiesForFlags(e) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._requirePersonProcessing("posthog.setGroupPropertiesForFlags") && this.featureFlags.setGroupPropertiesForFlags(e, t);
  }
  resetGroupPropertiesForFlags(e) {
    this.featureFlags.resetGroupPropertiesForFlags(e);
  }
  reset(e) {
    var t, i, r, s;
    if (q.info("reset"), !this.__loaded) return q.uninitializedWarning("posthog.reset");
    var n = this.get_property("$device_id");
    if (this.consent.reset(), null === (t = this.persistence) || void 0 === t || t.clear(), null === (i = this.sessionPersistence) || void 0 === i || i.clear(), this.surveys.reset(), null === (r = this.persistence) || void 0 === r || r.set_property(Me, "anonymous"), null === (s = this.sessionManager) || void 0 === s || s.resetSessionId(), this._cachedIdentify = null, this.config.__preview_experimental_cookieless_mode) this.register_once({
      distinct_id: Ue,
      $device_id: null
    }, "");else {
      var o = this.config.get_device_id(it());
      this.register_once({
        distinct_id: o,
        $device_id: e ? o : n
      }, "");
    }
    this.register({
      $last_posthog_reset: new Date().toISOString()
    }, 1);
  }
  get_distinct_id() {
    return this.get_property("distinct_id");
  }
  getGroups() {
    return this.get_property("$groups") || {};
  }
  get_session_id() {
    var e, t;
    return null !== (e = null === (t = this.sessionManager) || void 0 === t ? void 0 : t.checkAndGetSessionAndWindowId(!0).sessionId) && void 0 !== e ? e : "";
  }
  get_session_replay_url(e) {
    if (!this.sessionManager) return "";
    var {
        sessionId: t,
        sessionStartTimestamp: i
      } = this.sessionManager.checkAndGetSessionAndWindowId(!0),
      r = this.requestRouter.endpointFor("ui", "/project/".concat(this.config.token, "/replay/").concat(t));
    if (null != e && e.withTimestamp && i) {
      var s,
        n = null !== (s = e.timestampLookBack) && void 0 !== s ? s : 10;
      if (!i) return r;
      var o = Math.max(Math.floor((new Date().getTime() - i) / 1e3) - n, 0);
      r += "?t=".concat(o);
    }
    return r;
  }
  alias(e, t) {
    return e === this.get_property(ae) ? (q.critical("Attempting to create alias for existing People user - aborting."), -2) : this._requirePersonProcessing("posthog.alias") ? (R(t) && (t = this.get_distinct_id()), e !== t ? (this._register_single(le, e), this.capture("$create_alias", {
      alias: e,
      distinct_id: t
    })) : (q.warn("alias matches current distinct_id - skipping api call."), this.identify(e), -1)) : void 0;
  }
  set_config(e) {
    var t,
      i,
      r,
      s,
      n = j({}, this.config);
    C(e) && (K(this.config, mo(e)), null === (t = this.persistence) || void 0 === t || t.update_config(this.config, n), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new xi(j(j({}, this.config), {}, {
      persistence: "sessionStorage"
    })), ct.is_supported() && "true" === ct.get("ph_debug") && (this.config.debug = !0), this.config.debug && (p.DEBUG = !0, q.info("set_config", {
      config: e,
      oldConfig: n,
      newConfig: j({}, this.config)
    })), null === (i = this.sessionRecording) || void 0 === i || i.startIfEnabledOrStop(), null === (r = this.autocapture) || void 0 === r || r.startIfEnabled(), null === (s = this.heatmaps) || void 0 === s || s.startIfEnabled(), this.surveys.loadIfEnabled(), this._sync_opt_out_with_persistence());
  }
  startSessionRecording(e) {
    var t = !0 === e,
      i = {
        sampling: t || !(null == e || !e.sampling),
        linked_flag: t || !(null == e || !e.linked_flag),
        url_trigger: t || !(null == e || !e.url_trigger),
        event_trigger: t || !(null == e || !e.event_trigger)
      };
    if (Object.values(i).some(Boolean)) {
      var r, s, n, o, a;
      if (null === (r = this.sessionManager) || void 0 === r || r.checkAndGetSessionAndWindowId(), i.sampling) null === (s = this.sessionRecording) || void 0 === s || s.overrideSampling();
      if (i.linked_flag) null === (n = this.sessionRecording) || void 0 === n || n.overrideLinkedFlag();
      if (i.url_trigger) null === (o = this.sessionRecording) || void 0 === o || o.overrideTrigger("url");
      if (i.event_trigger) null === (a = this.sessionRecording) || void 0 === a || a.overrideTrigger("event");
    }
    this.set_config({
      disable_session_recording: !1
    });
  }
  stopSessionRecording() {
    this.set_config({
      disable_session_recording: !0
    });
  }
  sessionRecordingStarted() {
    var e;
    return !(null === (e = this.sessionRecording) || void 0 === e || !e.started);
  }
  captureException(e, t) {
    var i,
      r = new Error("PostHog syntheticException"),
      s = I(null === (i = _.__PosthogExtensions__) || void 0 === i ? void 0 : i.parseErrorAsProperties) ? j(j({}, _.__PosthogExtensions__.parseErrorAsProperties([e.message, void 0, void 0, void 0, e], {
        syntheticException: r
      })), t) : j({
        $exception_level: "error",
        $exception_list: [{
          type: e.name,
          value: e.message,
          mechanism: {
            handled: !0,
            synthetic: !1
          }
        }]
      }, t);
    this.exceptions.sendExceptionEvent(s);
  }
  loadToolbar(e) {
    return this.toolbar.loadToolbar(e);
  }
  get_property(e) {
    var t;
    return null === (t = this.persistence) || void 0 === t ? void 0 : t.props[e];
  }
  getSessionProperty(e) {
    var t;
    return null === (t = this.sessionPersistence) || void 0 === t ? void 0 : t.props[e];
  }
  toString() {
    var e,
      t = null !== (e = this.config.name) && void 0 !== e ? e : vo;
    return t !== vo && (t = vo + "." + t), t;
  }
  _isIdentified() {
    var e, t;
    return "identified" === (null === (e = this.persistence) || void 0 === e ? void 0 : e.get_property(Me)) || "identified" === (null === (t = this.sessionPersistence) || void 0 === t ? void 0 : t.get_property(Me));
  }
  _hasPersonProcessing() {
    var e, t, i, r;
    return !("never" === this.config.person_profiles || "identified_only" === this.config.person_profiles && !this._isIdentified() && P(this.getGroups()) && (null === (e = this.persistence) || void 0 === e || null === (t = e.props) || void 0 === t || !t[le]) && (null === (i = this.persistence) || void 0 === i || null === (r = i.props) || void 0 === r || !r[Be]));
  }
  _shouldCapturePageleave() {
    return !0 === this.config.capture_pageleave || "if_capture_pageview" === this.config.capture_pageleave && this.config.capture_pageview;
  }
  createPersonProfile() {
    this._hasPersonProcessing() || this._requirePersonProcessing("posthog.createPersonProfile") && this.setPersonProperties({}, {});
  }
  _requirePersonProcessing(e) {
    return "never" === this.config.person_profiles ? (q.error(e + ' was called, but process_person is set to "never". This call will be ignored.'), !1) : (this._register_single(Be, !0), !0);
  }
  _sync_opt_out_with_persistence() {
    var e,
      t,
      i,
      r,
      s = this.consent.isOptedOut(),
      n = this.config.opt_out_persistence_by_default,
      o = this.config.disable_persistence || s && !!n;
    (null === (e = this.persistence) || void 0 === e ? void 0 : e.disabled) !== o && (null === (i = this.persistence) || void 0 === i || i.set_disabled(o));
    (null === (t = this.sessionPersistence) || void 0 === t ? void 0 : t.disabled) !== o && (null === (r = this.sessionPersistence) || void 0 === r || r.set_disabled(o));
  }
  opt_in_capturing(e) {
    var t;
    (this.consent.optInOut(!0), this._sync_opt_out_with_persistence(), R(null == e ? void 0 : e.captureEventName) || null != e && e.captureEventName) && this.capture(null !== (t = null == e ? void 0 : e.captureEventName) && void 0 !== t ? t : "$opt_in", null == e ? void 0 : e.captureProperties, {
      send_instantly: !0
    });
    this.config.capture_pageview && this._captureInitialPageview();
  }
  opt_out_capturing() {
    this.consent.optInOut(!1), this._sync_opt_out_with_persistence();
  }
  has_opted_in_capturing() {
    return this.consent.isOptedIn();
  }
  has_opted_out_capturing() {
    return this.consent.isOptedOut();
  }
  clear_opt_in_out_capturing() {
    this.consent.reset(), this._sync_opt_out_with_persistence();
  }
  _is_bot() {
    return o ? Mn(o, this.config.custom_blocked_useragents) : void 0;
  }
  _captureInitialPageview() {
    a && !this._initialPageviewCaptured && (this._initialPageviewCaptured = !0, this.capture("$pageview", {
      title: a.title
    }, {
      send_instantly: !0
    }));
  }
  debug(e) {
    !1 === e ? (null == t || t.console.log("You've disabled debug mode."), localStorage && localStorage.removeItem("ph_debug"), this.set_config({
      debug: !1
    })) : (null == t || t.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."), localStorage && localStorage.setItem("ph_debug", "true"), this.set_config({
      debug: !0
    }));
  }
  _runBeforeSend(e) {
    if (O(this.config.before_send)) return e;
    var t = x(this.config.before_send) ? this.config.before_send : [this.config.before_send],
      i = e;
    for (var r of t) {
      if (i = r(i), O(i)) {
        var s = "Event '".concat(e.event, "' was rejected in beforeSend function");
        return D(e.event) ? q.warn("".concat(s, ". This can cause unexpected behavior.")) : q.info(s), null;
      }
      i.properties && !P(i.properties) || q.warn("Event '".concat(e.event, "' has no properties after beforeSend function, this is likely an error."));
    }
    return i;
  }
  getPageViewId() {
    var e;
    return null === (e = this.pageViewManager._currentPageview) || void 0 === e ? void 0 : e.pageViewId;
  }
}
!function (e, t) {
  for (var i = 0; i < t.length; i++) e.prototype[t[i]] = ee(e.prototype[t[i]]);
}(yo, ["identify"]);
var wo,
  So = (wo = _o[vo] = new yo(), function () {
    function e() {
      e.done || (e.done = !0, go = !1, Y(_o, function (e) {
        e._dom_loaded();
      }));
    }
    null != a && a.addEventListener && ("complete" === a.readyState ? e() : a.addEventListener("DOMContentLoaded", e, !1)), t && re(t, "load", e, !0);
  }(), wo);

;// ./src/analytics/posthog.ts
let isInitialized=false;const Analytics={init:()=>{if(isInitialized){return;}const key="phc_dsyjMkyBUgnCpPLfXiU83mSkdBs7MR8KQZGijxrtvkA";if(!key){log("PostHog key not found, skipping analytics initialization");return;}So.init(key,{api_host:"https://eu.i.posthog.com",person_profiles:"identified_only",// or 'always' to create profiles for anonymous users as well
capture_pageview:false,capture_pageleave:"if_capture_pageview",autocapture:false});isInitialized=true;},postFeaturesExecutedEvent:event=>{So.capture("features_executed",_objectSpread2(_objectSpread2({},event),{},{citizenId:getCitizenId(),stuffVersion:getStuffVersion()}));}};
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[7].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[7].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[7].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[7].use[4]!./src/features/improved-storage/StaticStyles.scss
var StaticStyles = __webpack_require__(515);
;// ./src/features/improved-storage/StaticStyles.scss

      
      
      
      
      
      
      
      
      

var StaticStyles_options = {};

StaticStyles_options.styleTagTransform = (styleTagTransform_default());
StaticStyles_options.setAttributes = (setAttributesWithoutAttributes_default());

      StaticStyles_options.insert = insertBySelector_default().bind(null, "head");
    
StaticStyles_options.domAPI = (styleDomAPI_default());
StaticStyles_options.insertStyleElement = (insertStyleElement_default());

var StaticStyles_update = injectStylesIntoStyleTag_default()(StaticStyles/* default */.A, StaticStyles_options);




       /* harmony default export */ const improved_storage_StaticStyles = (StaticStyles/* default */.A && StaticStyles/* default */.A.locals ? StaticStyles/* default */.A.locals : undefined);

;// ./src/angularjs-utils.ts
function getAngularjsControllerScope(controllerName){var controllerScope=getAngularjsControllerScopeOrNull(controllerName);if(!controllerScope){throw new Error("Controller ".concat(controllerName," not found"));}return controllerScope;}function getAngularjsControllerScopeOrNull(controllerName){var controllerElement=document.querySelector("[ng-controller=\"".concat(controllerName,"\"]"));var controllerScope=angular.element(controllerElement).scope();if(!controllerScope){return null;}return controllerScope;}function wrapAngularjsCallback(controller,field,callback){let where=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'before';var originalCallback=controller[field];controller[field]=function(){if(where==='before'){callback.apply(this,arguments);}originalCallback.apply(this,arguments);if(where==='after'){callback.apply(this,arguments);}};}function executeInAngularScope(callback){const scope=angular.element(document.body).scope();scope.$apply(callback);}
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/improved-storage/components/TotalLabel.module.scss
var TotalLabel_module = __webpack_require__(212);
;// ./src/features/improved-storage/components/TotalLabel.module.scss

      
      
      
      
      
      
      
      
      

var TotalLabel_module_options = {};

TotalLabel_module_options.styleTagTransform = (styleTagTransform_default());
TotalLabel_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      TotalLabel_module_options.insert = insertBySelector_default().bind(null, "head");
    
TotalLabel_module_options.domAPI = (styleDomAPI_default());
TotalLabel_module_options.insertStyleElement = (insertStyleElement_default());

var TotalLabel_module_update = injectStylesIntoStyleTag_default()(TotalLabel_module/* default */.A, TotalLabel_module_options);




       /* harmony default export */ const components_TotalLabel_module = (TotalLabel_module/* default */.A && TotalLabel_module/* default */.A.locals ? TotalLabel_module/* default */.A.locals : undefined);

;// ./src/features/improved-storage/components/TotalLabel.tsx
function createTotalLabelRootElement(){const rootElement=document.createElement("div");rootElement.classList.add(components_TotalLabel_module.TotalLabelRoot);return rootElement;}const TotalLabel=props=>{const[total,setTotal]=(0,react.useState)(0);(0,react.useEffect)(()=>{props.total.onValueChange(setTotal);},[props.total]);return/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:"Total: "}),/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{className:components_TotalLabel_module.TotalValue,children:[formatNumber(Math.floor(total))," ",getCitizenshipCurrencyName()]})]});};
;// ./src/hooks/external-property.ts
class ExternalProperty{constructor(initialValue){this.initialValue=initialValue;this.value=this.initialValue;this.callbacks=[];}update(newValue){this.value=newValue;this.callbacks.forEach(callback=>callback(newValue));}onValueChange(callback){this.callbacks.push(callback);callback(this.value);}}
;// ./src/utils/time.ts
async function waitFor(ms){return new Promise(resolve=>setTimeout(resolve,ms));}async function retry(callback){let maxRetries=arguments.length>1&&arguments[1]!==undefined?arguments[1]:3;let retryDelayMs=arguments.length>2&&arguments[2]!==undefined?arguments[2]:300;let retries=0;while(true){try{return await callback();}catch(error){if(retries>=maxRetries){throw error;}retries++;log("Retrying...");await waitFor(retryDelayMs);}}}async function retryNullish(callback){let message=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"Nullish value";let maxRetries=arguments.length>2&&arguments[2]!==undefined?arguments[2]:3;let retryDelayMs=arguments.length>3&&arguments[3]!==undefined?arguments[3]:300;let retries=0;while(true){const result=callback();if(result){return result;}if(retries>=maxRetries){throw new Error("Retries exceeded ".concat(message));}retries++;log("".concat(retries,"/").concat(maxRetries," Retrying... ").concat(message));await waitFor(retryDelayMs);}}async function countTimeSpent(callback){const start=Date.now();const result=await callback();const end=Date.now();return{result,timeSpent:end-start};}
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/improved-storage/components/ItemsSectionToggle.module.scss
var ItemsSectionToggle_module = __webpack_require__(893);
;// ./src/features/improved-storage/components/ItemsSectionToggle.module.scss

      
      
      
      
      
      
      
      
      

var ItemsSectionToggle_module_options = {};

ItemsSectionToggle_module_options.styleTagTransform = (styleTagTransform_default());
ItemsSectionToggle_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      ItemsSectionToggle_module_options.insert = insertBySelector_default().bind(null, "head");
    
ItemsSectionToggle_module_options.domAPI = (styleDomAPI_default());
ItemsSectionToggle_module_options.insertStyleElement = (insertStyleElement_default());

var ItemsSectionToggle_module_update = injectStylesIntoStyleTag_default()(ItemsSectionToggle_module/* default */.A, ItemsSectionToggle_module_options);




       /* harmony default export */ const components_ItemsSectionToggle_module = (ItemsSectionToggle_module/* default */.A && ItemsSectionToggle_module/* default */.A.locals ? ItemsSectionToggle_module/* default */.A.locals : undefined);

;// ./src/features/improved-storage/components/ItemsSectionToggle.tsx
const ItemsSectionToggle=props=>{var _props$initialIsOpene;const[isOpened,setIsOpened]=(0,react.useState)((_props$initialIsOpene=props.initialIsOpened)!==null&&_props$initialIsOpene!==void 0?_props$initialIsOpene:true);(0,react.useEffect)(()=>{const section=ensure(document.getElementById(props.sectionId));const sectionWrapper=ensure(section.querySelector(".storage_section_wrapper"));if(isOpened){sectionWrapper.classList.remove(components_ItemsSectionToggle_module.Hidden);}else{sectionWrapper.classList.add(components_ItemsSectionToggle_module.Hidden);}},[isOpened,props.sectionId]);return/*#__PURE__*/(0,jsx_runtime.jsx)("button",{className:components_ItemsSectionToggle_module.sectionToggle,onClick:()=>setIsOpened(!isOpened),children:isOpened?"Hide":"Show"});};
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/improved-storage/components/TotalFood.module.scss
var TotalFood_module = __webpack_require__(374);
;// ./src/features/improved-storage/components/TotalFood.module.scss

      
      
      
      
      
      
      
      
      

var TotalFood_module_options = {};

TotalFood_module_options.styleTagTransform = (styleTagTransform_default());
TotalFood_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      TotalFood_module_options.insert = insertBySelector_default().bind(null, "head");
    
TotalFood_module_options.domAPI = (styleDomAPI_default());
TotalFood_module_options.insertStyleElement = (insertStyleElement_default());

var TotalFood_module_update = injectStylesIntoStyleTag_default()(TotalFood_module/* default */.A, TotalFood_module_options);




       /* harmony default export */ const components_TotalFood_module = (TotalFood_module/* default */.A && TotalFood_module/* default */.A.locals ? TotalFood_module/* default */.A.locals : undefined);

;// ./src/features/improved-storage/components/TotalFood.tsx
const TotalFood=props=>{return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_TotalFood_module.ValueSection,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("img",{className:components_TotalFood_module.FoodIcon,src:"https://www.erepublik.net/images/icons/industry/1/q1.png",alt:"Food"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{className:components_TotalFood_module.EnergyValue,children:[formatNumber(props.totalEnergy)," HP"]})]})});};
;// ./src/requests/inventory-json-data-request.ts
let InventoryJson;(function(_InventoryJson){function sendRequest(request){const response=fetch("https://www.erepublik.com/en/main/inventory-json",{method:"GET",headers:_objectSpread2({"content-type":"application/json"},getCookieHeaders())});return response.then(response=>response.json());}_InventoryJson.sendRequest=sendRequest;})(InventoryJson||(InventoryJson={}));
;// ./src/utils/legacy-storage-settings.ts
function getStuffStorage(){return localStorage.getItem('stuff');}const LegacyStorageSettings={isImproveInventoryEnabled:()=>{const stuff=getStuffStorage();if(!stuff){return true;}const jsonStuff=JSON.parse(stuff);return!jsonStuff.improveInventory;},isSideInventoryEnabled:()=>{const stuff=getStuffStorage();if(!stuff){return true;}const jsonStuff=JSON.parse(stuff);return!jsonStuff.displayStorage;}};
;// ./src/features/improved-storage/index.tsx
const ImprovedStorage=createFeature({id:"improved_storage",name:"Improved Storage",canExecute:url=>url.href.includes("/main/inventory"),isSettingEnabled:()=>LegacyStorageSettings.isImproveInventoryEnabled(),execute:async()=>{// when the extension is being loaded on the inventory page, the main storage may not be loaded yet
await retryNullish(()=>document.querySelector("#mainStorage"),"Main storage not found",20,100);/**
     * All the styles are loaded and applied immediately for all the views.
     * Adding this class make these static styles scoped, so that they only apply to this view.
     */document.body.classList.add("su-improved-storage");makeSectionsToggleable();displayTotalFood();await retryNullish(()=>document.querySelector("#sell_offers .offers_product"),"Sell offers not found",20,100);// order matters start
displayTotalPriceOnSellOffer();applyMaxItemsOnSellOffer();// order matters end
autoOpenSellTab();}});async function applyMaxItemsOnSellOffer(){const storageController=getAngularjsControllerScope("StorageController");const sellItemsController=getAngularjsControllerScope("ErpkSellItemsController");console.log({storageController,sellItemsController});const itemsCache=await retry(()=>buildItemsCache(storageController.inventory.items));wrapAngularjsCallback(sellItemsController,"onProductChange",function(industryId,quality){var _item$amountForSale;const item=itemsCache.get("".concat(industryId,"_").concat(quality));if(!item){log("Item not found in cache: ".concat(industryId,"_").concat(quality),itemsCache);return;}this.inputs.quantity=(_item$amountForSale=item.amountForSale)!==null&&_item$amountForSale!==void 0?_item$amountForSale:1;},"before");// Autofill Food Q1
executeInAngularScope(()=>{// @ts-ignore
sellItemsController.onProductChange(1,1);});}async function displayTotalPriceOnSellOffer(){const sellItemsController=getAngularjsControllerScope("ErpkSellItemsController");const totalProperty=new ExternalProperty(0);renderElementWithRoot(/*#__PURE__*/(0,jsx_runtime.jsx)(TotalLabel,{total:totalProperty}),createTotalLabelRootElement()).after(document.querySelector("#sell_offers th.offers_quantity>input"));const offersQuantityInput=await retryNullish(()=>document.querySelector("#sell_offers .offers_quantity input"),"Offers quantity input not found");const pricePerUnitInput=await retryNullish(()=>document.querySelector("#sell_offers .offers_price input"),"Price per unit input not found");offersQuantityInput.addEventListener("input",updateTotalPrice);pricePerUnitInput.addEventListener("input",updateTotalPrice);function updateTotalPrice(){var _offersQuantityInput$,_pricePerUnitInput$va;const total=Number((_offersQuantityInput$=offersQuantityInput===null||offersQuantityInput===void 0?void 0:offersQuantityInput.value)!==null&&_offersQuantityInput$!==void 0?_offersQuantityInput$:0)*Number((_pricePerUnitInput$va=pricePerUnitInput===null||pricePerUnitInput===void 0?void 0:pricePerUnitInput.value)!==null&&_pricePerUnitInput$va!==void 0?_pricePerUnitInput$va:0);console.log(offersQuantityInput===null||offersQuantityInput===void 0?void 0:offersQuantityInput.value,pricePerUnitInput===null||pricePerUnitInput===void 0?void 0:pricePerUnitInput.value);console.log("Total price",total);totalProperty.update(total);}wrapAngularjsCallback(sellItemsController,"onProductChange",function(){updateTotalPrice();},"after");waitFor(1).then(()=>{updateTotalPrice();});}async function autoOpenSellTab(){await retry(()=>{const sellTab=document.querySelector("#inventory_sell");if(!sellTab){throw new Error("Sell tab not found");}if(sellTab.classList.contains("down")){return;}sellTab.click();});}function buildItemsCache(itemGroups){const itemsCache=new Map();for(const group of itemGroups){for(const item of group.items){if(!item.id){continue;}let id=item.id;if(id.startsWith("raw_")){id=id.replace("raw_","");}itemsCache.set(id,item);}}return itemsCache;}function makeSectionsToggleable(){const inventoryItems=document.querySelectorAll("#inventoryItems > div");inventoryItems.forEach(item=>{// We care only about the ng-repeat sections
if(!item.getAttribute("ng-repeat")){return;}const isOpened=item.id!=="assembly";renderElement(/*#__PURE__*/(0,jsx_runtime.jsx)(ItemsSectionToggle,{sectionId:item.id,initialIsOpened:isOpened})).after(item.querySelector(".section_separator > .top_left > div"));});}async function displayTotalFood(){const storageController=getAngularjsControllerScope("StorageController");let totalFoodEnergy=0;await retry(()=>{totalFoodEnergy=0;storageController.inventory.items.forEach(group=>{group.items.forEach(item=>{if(item.type==="food"){var _item$attributes$stor;// For some reason the energy string ("+2") has some weird bytes around it
// bytes: [ 226, 129, 160, 43, 50, 226, 129, 160 ], where 43 is "+" and 50 is "2"
// the regex below removes these bytes, so that it can be nicely parsed to a number
const energyWithoutHiddenSpaces=item.attributes.energy.replace(/[\u2060]/g,"");totalFoodEnergy+=((_item$attributes$stor=item.attributes.storage)!==null&&_item$attributes$stor!==void 0?_item$attributes$stor:0)*energyWithoutHiddenSpaces;}});});});renderElement(/*#__PURE__*/(0,jsx_runtime.jsx)(TotalFood,{totalEnergy:totalFoodEnergy})).before(document.querySelector("#mainStorage >.section_separator > .top_right > .used_storage_wrapper"));}
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/side-inventory/components/SideInventory.module.scss
var SideInventory_module = __webpack_require__(281);
;// ./src/features/side-inventory/components/SideInventory.module.scss

      
      
      
      
      
      
      
      
      

var SideInventory_module_options = {};

SideInventory_module_options.styleTagTransform = (styleTagTransform_default());
SideInventory_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      SideInventory_module_options.insert = insertBySelector_default().bind(null, "head");
    
SideInventory_module_options.domAPI = (styleDomAPI_default());
SideInventory_module_options.insertStyleElement = (insertStyleElement_default());

var SideInventory_module_update = injectStylesIntoStyleTag_default()(SideInventory_module/* default */.A, SideInventory_module_options);




       /* harmony default export */ const components_SideInventory_module = (SideInventory_module/* default */.A && SideInventory_module/* default */.A.locals ? SideInventory_module/* default */.A.locals : undefined);

;// ./src/features/side-inventory/components/SideInventory.tsx
function createSideInventoryRootElement(){const rootElement=document.createElement("div");rootElement.classList.add(components_SideInventory_module.SideInventoryRoot);return rootElement;}const SideInventory=props=>{return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:components_SideInventory_module.SideInventory,children:props.items.map(item=>{var _item$attributes;return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_SideInventory_module.Item,title:item.name,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("img",{className:components_SideInventory_module.Img,src:item.icon,alt:item.name}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:classnames_default()(components_SideInventory_module.Text,{[components_SideInventory_module.IsActive]:(_item$attributes=item.attributes)===null||_item$attributes===void 0?void 0:_item$attributes.active}),children:item.amountDisplay})]},item.id);})});};
;// ./src/features/side-inventory/index.tsx
const typesToSkip=new Set(["currency","vehicle_blueprint"// "booster"
]);const SideInventoryFeature=createFeature({id:"side_inventory",name:"Side Inventory",// Everywhere apart from the storage page itself
canExecute:url=>!url.href.includes("/main/inventory"),isSettingEnabled:()=>LegacyStorageSettings.isSideInventoryEnabled(),execute:async()=>{const response=await InventoryJson.sendRequest({});const items=response.flatMap(group=>group.items);const filteredItems=items.filter(item=>item.type&&!typesToSkip.has(item.type)).filter(item=>{var _item$attributes;return!((_item$attributes=item.attributes)!==null&&_item$attributes!==void 0&&_item$attributes.inProduction);});renderElementWithRoot(/*#__PURE__*/(0,jsx_runtime.jsx)(SideInventory,{items:filteredItems}),createSideInventoryRootElement()).after(document.querySelector("#container"));}});
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[8].use[3]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[8].use[4]!./src/features/main-page/components/StorageInfo.module.scss
var StorageInfo_module = __webpack_require__(472);
;// ./src/features/main-page/components/StorageInfo.module.scss

      
      
      
      
      
      
      
      
      

var StorageInfo_module_options = {};

StorageInfo_module_options.styleTagTransform = (styleTagTransform_default());
StorageInfo_module_options.setAttributes = (setAttributesWithoutAttributes_default());

      StorageInfo_module_options.insert = insertBySelector_default().bind(null, "head");
    
StorageInfo_module_options.domAPI = (styleDomAPI_default());
StorageInfo_module_options.insertStyleElement = (insertStyleElement_default());

var StorageInfo_module_update = injectStylesIntoStyleTag_default()(StorageInfo_module/* default */.A, StorageInfo_module_options);




       /* harmony default export */ const components_StorageInfo_module = (StorageInfo_module/* default */.A && StorageInfo_module/* default */.A.locals ? StorageInfo_module/* default */.A.locals : undefined);

;// ./src/features/main-page/components/StorageInfo.tsx
const StorageInfo=props=>{return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_StorageInfo_module.StorageInfo,children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_StorageInfo_module.MainRow,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("img",{className:components_StorageInfo_module.Image,src:"https://www.erepublik.com/images/modules/manager/storage_build_icon.png",alt:"Storage"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("strong",{className:components_StorageInfo_module.MainText,children:[formatNumber(props.free)," "]}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{className:components_StorageInfo_module.SecondaryText,children:"FREE"})]})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:components_StorageInfo_module.SupportingRow,children:[formatNumber(props.current)," / ",formatNumber(props.total)]})]});};
;// ./src/requests/inventory-html-request.ts
let InventoryHtml;(function(_InventoryHtml){function sendRequest(request){const response=fetch("https://www.erepublik.com/en/main/inventory",{method:"GET",headers:_objectSpread2({"content-type":"text/html"},getCookieHeaders())});return response.then(response=>response.text());}_InventoryHtml.sendRequest=sendRequest;})(InventoryHtml||(InventoryHtml={}));
;// ./src/features/main-page/index.tsx
const MainPageFeature=createFeature({id:"main_page",name:"Main Page",canExecute:url=>isOnHomepage(),execute:async()=>{storageInfo();}});async function storageInfo(){const html=await InventoryHtml.sendRequest({});const parser=new DOMParser();const doc=parser.parseFromString(html,"text/html");const selectors=".used_storage_wrapper .used_storage";const currencyAmount=doc.querySelector(selectors);if(!currencyAmount){console.error("Element with selector '".concat(selectors,"' not found"));return;}const originalTitle="title";const rawValues=currencyAmount.getAttribute(originalTitle);if(!rawValues){console.error("Element with selector '".concat(selectors,"' has no ").concat(originalTitle," attribute"));return;}const{current,total}=parseValues(rawValues);const free=total-current;renderElement(/*#__PURE__*/(0,jsx_runtime.jsx)(StorageInfo,{current:current,total:total,free:free})).after(document.querySelector(".sidebar .currency_amount"));}/**
 * Converts a string like "1,234 / 5,678" to an object with current and total properties
 */function parseValues(input){// Split the input by '/' and trim whitespace from each part
const[currentStr,totalStr]=input.split('/').map(part=>part.trim());// Helper function to remove commas and convert to a number
const toNumber=str=>{return Number(str.replace(/,/g,''));// Remove commas and convert to number
};return{current:toNumber(currentStr),total:toNumber(totalStr)};}
;// ./src/index.tsx
log("React script has successfully started");const features=[AnAmazingJourneyFeature,ImprovedStorage,SideInventoryFeature,MainPageFeature];async function onUrlChange(){Analytics.init();log("Found ".concat(features.length," features. Executing..."));let executedWithSuccess=0;const executionStatuses={};const promises=features.map(async(feature,index)=>{const counterString="[".concat(index+1,"/").concat(features.length,"]");if(!feature.canExecute(window.location)){log("".concat(counterString," [SKIP] [").concat(feature.name,"] cannot execute on this page"));executionStatuses[feature.id]={skipped:"Disabled on this page"};return;}if(feature.isSettingEnabled&&!feature.isSettingEnabled()){log("".concat(counterString," [SKIP] [").concat(feature.name,"] is disabled in settings"));executionStatuses[feature.id]={skipped:"Disabled in settings"};return;}try{log("".concat(counterString," [").concat(feature.name,"] executing..."));const{timeSpent}=await countTimeSpent(()=>feature.execute());log("".concat(counterString," [").concat(feature.name,"] executed successfully in ").concat(formatNumber(timeSpent),"ms"));executedWithSuccess++;executionStatuses[feature.id]={success:true,timeSpentMs:timeSpent};}catch(e){var _e$toString;error("Feature ".concat(feature.name," failed to execute"));error(e);executionStatuses[feature.id]={success:false,error:(_e$toString=e===null||e===void 0?void 0:e.toString())!==null&&_e$toString!==void 0?_e$toString:"Unknown error"};}});const{timeSpent}=await countTimeSpent(()=>Promise.all(promises));log("[SUCCESS] ".concat(executedWithSuccess,"/").concat(features.length," features started successfully in ").concat(formatNumber(timeSpent),"ms"));Analytics.postFeaturesExecutedEvent({features:executionStatuses,totalTimeSpentMs:timeSpent});}if(document.readyState==="loading"){document.addEventListener("DOMContentLoaded",watchForUrlChange);}else{watchForUrlChange();}function watchForUrlChange(){// Call `onUrlChange()` every time the page URL changes, including on first load.
addLocationChangeCallback(()=>{// Greasemonkey doesn't bubble errors up to the onUrlChange console,
// so we have to catch them manually and log them
onUrlChange().catch(e=>{log(e);});});}
})();

/******/ })()
;
//# sourceMappingURL=main.js.map;
  })(window.originalMap);
}